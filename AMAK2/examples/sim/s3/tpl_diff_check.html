<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<style>body{background-color:white;}</style>
<script src="data:application/x-javascript;base64,KGZ1bmN0aW9uKCkgewogIC8vIElmIHdpbmRvdy5IVE1MV2lkZ2V0cyBpcyBhbHJlYWR5IGRlZmluZWQsIHRoZW4gdXNlIGl0OyBvdGhlcndpc2UgY3JlYXRlIGEKICAvLyBuZXcgb2JqZWN0LiBUaGlzIGFsbG93cyBwcmVjZWRpbmcgY29kZSB0byBzZXQgb3B0aW9ucyB0aGF0IGFmZmVjdCB0aGUKICAvLyBpbml0aWFsaXphdGlvbiBwcm9jZXNzICh0aG91Z2ggbm9uZSBjdXJyZW50bHkgZXhpc3QpLgogIHdpbmRvdy5IVE1MV2lkZ2V0cyA9IHdpbmRvdy5IVE1MV2lkZ2V0cyB8fCB7fTsKCiAgLy8gU2VlIGlmIHdlJ3JlIHJ1bm5pbmcgaW4gYSB2aWV3ZXIgcGFuZS4gSWYgbm90LCB3ZSdyZSBpbiBhIHdlYiBicm93c2VyLgogIHZhciB2aWV3ZXJNb2RlID0gd2luZG93LkhUTUxXaWRnZXRzLnZpZXdlck1vZGUgPQogICAgICAvXGJ2aWV3ZXJfcGFuZT0xXGIvLnRlc3Qod2luZG93LmxvY2F0aW9uKTsKCiAgLy8gU2VlIGlmIHdlJ3JlIHJ1bm5pbmcgaW4gU2hpbnkgbW9kZS4gSWYgbm90LCBpdCdzIGEgc3RhdGljIGRvY3VtZW50LgogIC8vIE5vdGUgdGhhdCBzdGF0aWMgd2lkZ2V0cyBjYW4gYXBwZWFyIGluIGJvdGggU2hpbnkgYW5kIHN0YXRpYyBtb2RlcywgYnV0CiAgLy8gb2J2aW91c2x5LCBTaGlueSB3aWRnZXRzIGNhbiBvbmx5IGFwcGVhciBpbiBTaGlueSBhcHBzL2RvY3VtZW50cy4KICB2YXIgc2hpbnlNb2RlID0gd2luZG93LkhUTUxXaWRnZXRzLnNoaW55TW9kZSA9CiAgICAgIHR5cGVvZih3aW5kb3cuU2hpbnkpICE9PSAidW5kZWZpbmVkIiAmJiAhIXdpbmRvdy5TaGlueS5vdXRwdXRCaW5kaW5nczsKCiAgLy8gV2UgY2FuJ3QgY291bnQgb24galF1ZXJ5IGJlaW5nIGF2YWlsYWJsZSwgc28gd2UgaW1wbGVtZW50IG91ciBvd24KICAvLyB2ZXJzaW9uIGlmIG5lY2Vzc2FyeS4KICBmdW5jdGlvbiBxdWVyeVNlbGVjdG9yQWxsKHNjb3BlLCBzZWxlY3RvcikgewogICAgaWYgKHR5cGVvZihqUXVlcnkpICE9PSAidW5kZWZpbmVkIiAmJiBzY29wZSBpbnN0YW5jZW9mIGpRdWVyeSkgewogICAgICByZXR1cm4gc2NvcGUuZmluZChzZWxlY3Rvcik7CiAgICB9CiAgICBpZiAoc2NvcGUucXVlcnlTZWxlY3RvckFsbCkgewogICAgICByZXR1cm4gc2NvcGUucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7CiAgICB9CiAgfQoKICBmdW5jdGlvbiBhc0FycmF5KHZhbHVlKSB7CiAgICBpZiAodmFsdWUgPT09IG51bGwpCiAgICAgIHJldHVybiBbXTsKICAgIGlmICgkLmlzQXJyYXkodmFsdWUpKQogICAgICByZXR1cm4gdmFsdWU7CiAgICByZXR1cm4gW3ZhbHVlXTsKICB9CgogIC8vIEltcGxlbWVudCBqUXVlcnkncyBleHRlbmQKICBmdW5jdGlvbiBleHRlbmQodGFyZ2V0IC8qLCAuLi4gKi8pIHsKICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDEpIHsKICAgICAgcmV0dXJuIHRhcmdldDsKICAgIH0KICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7CiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07CiAgICAgIGZvciAodmFyIHByb3AgaW4gc291cmNlKSB7CiAgICAgICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShwcm9wKSkgewogICAgICAgICAgdGFyZ2V0W3Byb3BdID0gc291cmNlW3Byb3BdOwogICAgICAgIH0KICAgICAgfQogICAgfQogICAgcmV0dXJuIHRhcmdldDsKICB9CgogIC8vIElFOCBkb2Vzbid0IHN1cHBvcnQgQXJyYXkuZm9yRWFjaC4KICBmdW5jdGlvbiBmb3JFYWNoKHZhbHVlcywgY2FsbGJhY2ssIHRoaXNBcmcpIHsKICAgIGlmICh2YWx1ZXMuZm9yRWFjaCkgewogICAgICB2YWx1ZXMuZm9yRWFjaChjYWxsYmFjaywgdGhpc0FyZyk7CiAgICB9IGVsc2UgewogICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykgewogICAgICAgIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgdmFsdWVzW2ldLCBpLCB2YWx1ZXMpOwogICAgICB9CiAgICB9CiAgfQoKICAvLyBSZXBsYWNlcyB0aGUgc3BlY2lmaWVkIG1ldGhvZCB3aXRoIHRoZSByZXR1cm4gdmFsdWUgb2YgZnVuY1NvdXJjZS4KICAvLwogIC8vIE5vdGUgdGhhdCBmdW5jU291cmNlIHNob3VsZCBub3QgQkUgdGhlIG5ldyBtZXRob2QsIGl0IHNob3VsZCBiZSBhIGZ1bmN0aW9uCiAgLy8gdGhhdCBSRVRVUk5TIHRoZSBuZXcgbWV0aG9kLiBmdW5jU291cmNlIHJlY2VpdmVzIGEgc2luZ2xlIGFyZ3VtZW50IHRoYXQgaXMKICAvLyB0aGUgb3ZlcnJpZGRlbiBtZXRob2QsIGl0IGNhbiBiZSBjYWxsZWQgZnJvbSB0aGUgbmV3IG1ldGhvZC4gVGhlIG92ZXJyaWRkZW4KICAvLyBtZXRob2QgY2FuIGJlIGNhbGxlZCBsaWtlIGEgcmVndWxhciBmdW5jdGlvbiwgaXQgaGFzIHRoZSB0YXJnZXQgcGVybWFuZW50bHkKICAvLyBib3VuZCB0byBpdCBzbyAidGhpcyIgd2lsbCB3b3JrIGNvcnJlY3RseS4KICBmdW5jdGlvbiBvdmVycmlkZU1ldGhvZCh0YXJnZXQsIG1ldGhvZE5hbWUsIGZ1bmNTb3VyY2UpIHsKICAgIHZhciBzdXBlckZ1bmMgPSB0YXJnZXRbbWV0aG9kTmFtZV0gfHwgZnVuY3Rpb24oKSB7fTsKICAgIHZhciBzdXBlckZ1bmNCb3VuZCA9IGZ1bmN0aW9uKCkgewogICAgICByZXR1cm4gc3VwZXJGdW5jLmFwcGx5KHRhcmdldCwgYXJndW1lbnRzKTsKICAgIH07CiAgICB0YXJnZXRbbWV0aG9kTmFtZV0gPSBmdW5jU291cmNlKHN1cGVyRnVuY0JvdW5kKTsKICB9CgogIC8vIEFkZCBhIG1ldGhvZCB0byBkZWxlZ2F0b3IgdGhhdCwgd2hlbiBpbnZva2VkLCBjYWxscwogIC8vIGRlbGVnYXRlZS5tZXRob2ROYW1lLiBJZiB0aGVyZSBpcyBubyBzdWNoIG1ldGhvZCBvbgogIC8vIHRoZSBkZWxlZ2F0ZWUsIGJ1dCB0aGVyZSB3YXMgb25lIG9uIGRlbGVnYXRvciBiZWZvcmUKICAvLyBkZWxlZ2F0ZU1ldGhvZCB3YXMgY2FsbGVkLCB0aGVuIHRoZSBvcmlnaW5hbCB2ZXJzaW9uCiAgLy8gaXMgaW52b2tlZCBpbnN0ZWFkLgogIC8vIEZvciBleGFtcGxlOgogIC8vCiAgLy8gdmFyIGEgPSB7CiAgLy8gICBtZXRob2QxOiBmdW5jdGlvbigpIHsgY29uc29sZS5sb2coJ2ExJyk7IH0KICAvLyAgIG1ldGhvZDI6IGZ1bmN0aW9uKCkgeyBjb25zb2xlLmxvZygnYTInKTsgfQogIC8vIH07CiAgLy8gdmFyIGIgPSB7CiAgLy8gICBtZXRob2QxOiBmdW5jdGlvbigpIHsgY29uc29sZS5sb2coJ2IxJyk7IH0KICAvLyB9OwogIC8vIGRlbGVnYXRlTWV0aG9kKGEsIGIsICJtZXRob2QxIik7CiAgLy8gZGVsZWdhdGVNZXRob2QoYSwgYiwgIm1ldGhvZDIiKTsKICAvLyBhLm1ldGhvZDEoKTsKICAvLyBhLm1ldGhvZDIoKTsKICAvLwogIC8vIFRoZSBvdXRwdXQgd291bGQgYmUgImIxIiwgImEyIi4KICBmdW5jdGlvbiBkZWxlZ2F0ZU1ldGhvZChkZWxlZ2F0b3IsIGRlbGVnYXRlZSwgbWV0aG9kTmFtZSkgewogICAgdmFyIGluaGVyaXRlZCA9IGRlbGVnYXRvclttZXRob2ROYW1lXTsKICAgIGRlbGVnYXRvclttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkgewogICAgICB2YXIgdGFyZ2V0ID0gZGVsZWdhdGVlOwogICAgICB2YXIgbWV0aG9kID0gZGVsZWdhdGVlW21ldGhvZE5hbWVdOwoKICAgICAgLy8gVGhlIG1ldGhvZCBkb2Vzbid0IGV4aXN0IG9uIHRoZSBkZWxlZ2F0ZWUuIEluc3RlYWQsCiAgICAgIC8vIGNhbGwgdGhlIG1ldGhvZCBvbiB0aGUgZGVsZWdhdG9yLCBpZiBpdCBleGlzdHMuCiAgICAgIGlmICghbWV0aG9kKSB7CiAgICAgICAgdGFyZ2V0ID0gZGVsZWdhdG9yOwogICAgICAgIG1ldGhvZCA9IGluaGVyaXRlZDsKICAgICAgfQoKICAgICAgaWYgKG1ldGhvZCkgewogICAgICAgIHJldHVybiBtZXRob2QuYXBwbHkodGFyZ2V0LCBhcmd1bWVudHMpOwogICAgICB9CiAgICB9OwogIH0KCiAgLy8gSW1wbGVtZW50IGEgdmFndWUgZmFjc2ltaWxpZSBvZiBqUXVlcnkncyBkYXRhIG1ldGhvZAogIGZ1bmN0aW9uIGVsZW1lbnREYXRhKGVsLCBuYW1lLCB2YWx1ZSkgewogICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMikgewogICAgICByZXR1cm4gZWxbImh0bWx3aWRnZXRfZGF0YV8iICsgbmFtZV07CiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMykgewogICAgICBlbFsiaHRtbHdpZGdldF9kYXRhXyIgKyBuYW1lXSA9IHZhbHVlOwogICAgICByZXR1cm4gZWw7CiAgICB9IGVsc2UgewogICAgICB0aHJvdyBuZXcgRXJyb3IoIldyb25nIG51bWJlciBvZiBhcmd1bWVudHMgZm9yIGVsZW1lbnREYXRhOiAiICsKICAgICAgICBhcmd1bWVudHMubGVuZ3RoKTsKICAgIH0KICB9CgogIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzQ0NjE3MC9lc2NhcGUtc3RyaW5nLWZvci11c2UtaW4tamF2YXNjcmlwdC1yZWdleAogIGZ1bmN0aW9uIGVzY2FwZVJlZ0V4cChzdHIpIHsKICAgIHJldHVybiBzdHIucmVwbGFjZSgvW1wtXFtcXVwvXHtcfVwoXClcKlwrXD9cLlxcXF5cJFx8XS9nLCAiXFwkJiIpOwogIH0KCiAgZnVuY3Rpb24gaGFzQ2xhc3MoZWwsIGNsYXNzTmFtZSkgewogICAgdmFyIHJlID0gbmV3IFJlZ0V4cCgiXFxiIiArIGVzY2FwZVJlZ0V4cChjbGFzc05hbWUpICsgIlxcYiIpOwogICAgcmV0dXJuIHJlLnRlc3QoZWwuY2xhc3NOYW1lKTsKICB9CgogIC8vIGVsZW1lbnRzIC0gYXJyYXkgKG9yIGFycmF5LWxpa2Ugb2JqZWN0KSBvZiBIVE1MIGVsZW1lbnRzCiAgLy8gY2xhc3NOYW1lIC0gY2xhc3MgbmFtZSB0byB0ZXN0IGZvcgogIC8vIGluY2x1ZGUgLSBpZiB0cnVlLCBvbmx5IHJldHVybiBlbGVtZW50cyB3aXRoIGdpdmVuIGNsYXNzTmFtZTsKICAvLyAgIGlmIGZhbHNlLCBvbmx5IHJldHVybiBlbGVtZW50cyAqd2l0aG91dCogZ2l2ZW4gY2xhc3NOYW1lCiAgZnVuY3Rpb24gZmlsdGVyQnlDbGFzcyhlbGVtZW50cywgY2xhc3NOYW1lLCBpbmNsdWRlKSB7CiAgICB2YXIgcmVzdWx0cyA9IFtdOwogICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykgewogICAgICBpZiAoaGFzQ2xhc3MoZWxlbWVudHNbaV0sIGNsYXNzTmFtZSkgPT0gaW5jbHVkZSkKICAgICAgICByZXN1bHRzLnB1c2goZWxlbWVudHNbaV0pOwogICAgfQogICAgcmV0dXJuIHJlc3VsdHM7CiAgfQoKICBmdW5jdGlvbiBvbihvYmosIGV2ZW50TmFtZSwgZnVuYykgewogICAgaWYgKG9iai5hZGRFdmVudExpc3RlbmVyKSB7CiAgICAgIG9iai5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgZnVuYywgZmFsc2UpOwogICAgfSBlbHNlIGlmIChvYmouYXR0YWNoRXZlbnQpIHsKICAgICAgb2JqLmF0dGFjaEV2ZW50KGV2ZW50TmFtZSwgZnVuYyk7CiAgICB9CiAgfQoKICBmdW5jdGlvbiBvZmYob2JqLCBldmVudE5hbWUsIGZ1bmMpIHsKICAgIGlmIChvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcikKICAgICAgb2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBmdW5jLCBmYWxzZSk7CiAgICBlbHNlIGlmIChvYmouZGV0YWNoRXZlbnQpIHsKICAgICAgb2JqLmRldGFjaEV2ZW50KGV2ZW50TmFtZSwgZnVuYyk7CiAgICB9CiAgfQoKICAvLyBUcmFuc2xhdGUgYXJyYXkgb2YgdmFsdWVzIHRvIHRvcC9yaWdodC9ib3R0b20vbGVmdCwgYXMgdXN1YWwgd2l0aAogIC8vIHRoZSAicGFkZGluZyIgQ1NTIHByb3BlcnR5CiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL3BhZGRpbmcKICBmdW5jdGlvbiB1bnBhY2tQYWRkaW5nKHZhbHVlKSB7CiAgICBpZiAodHlwZW9mKHZhbHVlKSA9PT0gIm51bWJlciIpCiAgICAgIHZhbHVlID0gW3ZhbHVlXTsKICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDEpIHsKICAgICAgcmV0dXJuIHt0b3A6IHZhbHVlWzBdLCByaWdodDogdmFsdWVbMF0sIGJvdHRvbTogdmFsdWVbMF0sIGxlZnQ6IHZhbHVlWzBdfTsKICAgIH0KICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDIpIHsKICAgICAgcmV0dXJuIHt0b3A6IHZhbHVlWzBdLCByaWdodDogdmFsdWVbMV0sIGJvdHRvbTogdmFsdWVbMF0sIGxlZnQ6IHZhbHVlWzFdfTsKICAgIH0KICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDMpIHsKICAgICAgcmV0dXJuIHt0b3A6IHZhbHVlWzBdLCByaWdodDogdmFsdWVbMV0sIGJvdHRvbTogdmFsdWVbMl0sIGxlZnQ6IHZhbHVlWzFdfTsKICAgIH0KICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDQpIHsKICAgICAgcmV0dXJuIHt0b3A6IHZhbHVlWzBdLCByaWdodDogdmFsdWVbMV0sIGJvdHRvbTogdmFsdWVbMl0sIGxlZnQ6IHZhbHVlWzNdfTsKICAgIH0KICB9CgogIC8vIENvbnZlcnQgYW4gdW5wYWNrZWQgcGFkZGluZyBvYmplY3QgdG8gYSBDU1MgdmFsdWUKICBmdW5jdGlvbiBwYWRkaW5nVG9Dc3MocGFkZGluZ09iaikgewogICAgcmV0dXJuIHBhZGRpbmdPYmoudG9wICsgInB4ICIgKyBwYWRkaW5nT2JqLnJpZ2h0ICsgInB4ICIgKyBwYWRkaW5nT2JqLmJvdHRvbSArICJweCAiICsgcGFkZGluZ09iai5sZWZ0ICsgInB4IjsKICB9CgogIC8vIE1ha2VzIGEgbnVtYmVyIHN1aXRhYmxlIGZvciBDU1MKICBmdW5jdGlvbiBweCh4KSB7CiAgICBpZiAodHlwZW9mKHgpID09PSAibnVtYmVyIikKICAgICAgcmV0dXJuIHggKyAicHgiOwogICAgZWxzZQogICAgICByZXR1cm4geDsKICB9CgogIC8vIFJldHJpZXZlcyBydW50aW1lIHdpZGdldCBzaXppbmcgaW5mb3JtYXRpb24gZm9yIGFuIGVsZW1lbnQuCiAgLy8gVGhlIHJldHVybiB2YWx1ZSBpcyBlaXRoZXIgbnVsbCwgb3IgYW4gb2JqZWN0IHdpdGggZmlsbCwgcGFkZGluZywKICAvLyBkZWZhdWx0V2lkdGgsIGRlZmF1bHRIZWlnaHQgZmllbGRzLgogIGZ1bmN0aW9uIHNpemluZ1BvbGljeShlbCkgewogICAgdmFyIHNpemluZ0VsID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcigic2NyaXB0W2RhdGEtZm9yPSciICsgZWwuaWQgKyAiJ11bdHlwZT0nYXBwbGljYXRpb24vaHRtbHdpZGdldC1zaXppbmcnXSIpOwogICAgaWYgKCFzaXppbmdFbCkKICAgICAgcmV0dXJuIG51bGw7CiAgICB2YXIgc3AgPSBKU09OLnBhcnNlKHNpemluZ0VsLnRleHRDb250ZW50IHx8IHNpemluZ0VsLnRleHQgfHwgInt9Iik7CiAgICBpZiAodmlld2VyTW9kZSkgewogICAgICByZXR1cm4gc3Audmlld2VyOwogICAgfSBlbHNlIHsKICAgICAgcmV0dXJuIHNwLmJyb3dzZXI7CiAgICB9CiAgfQoKICAvLyBAcGFyYW0gdGFza3MgQXJyYXkgb2Ygc3RyaW5ncyAob3IgZmFsc3kgdmFsdWUsIGluIHdoaWNoIGNhc2Ugbm8tb3ApLgogIC8vICAgRWFjaCBlbGVtZW50IG11c3QgYmUgYSB2YWxpZCBKYXZhU2NyaXB0IGV4cHJlc3Npb24gdGhhdCB5aWVsZHMgYQogIC8vICAgZnVuY3Rpb24uIE9yLCBjYW4gYmUgYW4gYXJyYXkgb2Ygb2JqZWN0cyB3aXRoICJjb2RlIiBhbmQgImRhdGEiCiAgLy8gICBwcm9wZXJ0aWVzOyBpbiB0aGlzIGNhc2UsIHRoZSAiY29kZSIgcHJvcGVydHkgc2hvdWxkIGJlIGEgc3RyaW5nCiAgLy8gICBvZiBKUyB0aGF0J3MgYW4gZXhwciB0aGF0IHlpZWxkcyBhIGZ1bmN0aW9uLCBhbmQgImRhdGEiIHNob3VsZCBiZQogIC8vICAgYW4gb2JqZWN0IHRoYXQgd2lsbCBiZSBhZGRlZCBhcyBhbiBhZGRpdGlvbmFsIGFyZ3VtZW50IHdoZW4gdGhhdAogIC8vICAgZnVuY3Rpb24gaXMgY2FsbGVkLgogIC8vIEBwYXJhbSB0YXJnZXQgVGhlIG9iamVjdCB0aGF0IHdpbGwgYmUgInRoaXMiIGZvciBlYWNoIGZ1bmN0aW9uCiAgLy8gICBleGVjdXRpb24uCiAgLy8gQHBhcmFtIGFyZ3MgQXJyYXkgb2YgYXJndW1lbnRzIHRvIGJlIHBhc3NlZCB0byB0aGUgZnVuY3Rpb25zLiAoVGhlCiAgLy8gICBzYW1lIGFyZ3VtZW50cyB3aWxsIGJlIHBhc3NlZCB0byBhbGwgZnVuY3Rpb25zLikKICBmdW5jdGlvbiBldmFsQW5kUnVuKHRhc2tzLCB0YXJnZXQsIGFyZ3MpIHsKICAgIGlmICh0YXNrcykgewogICAgICBmb3JFYWNoKHRhc2tzLCBmdW5jdGlvbih0YXNrKSB7CiAgICAgICAgdmFyIHRoZXNlQXJncyA9IGFyZ3M7CiAgICAgICAgaWYgKHR5cGVvZih0YXNrKSA9PT0gIm9iamVjdCIpIHsKICAgICAgICAgIHRoZXNlQXJncyA9IHRoZXNlQXJncy5jb25jYXQoW3Rhc2suZGF0YV0pOwogICAgICAgICAgdGFzayA9IHRhc2suY29kZTsKICAgICAgICB9CiAgICAgICAgdmFyIHRhc2tGdW5jID0gdHJ5RXZhbCh0YXNrKTsKICAgICAgICBpZiAodHlwZW9mKHRhc2tGdW5jKSAhPT0gImZ1bmN0aW9uIikgewogICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJUYXNrIG11c3QgYmUgYSBmdW5jdGlvbiEgU291cmNlOlxuIiArIHRhc2spOwogICAgICAgIH0KICAgICAgICB0YXNrRnVuYy5hcHBseSh0YXJnZXQsIHRoZXNlQXJncyk7CiAgICAgIH0pOwogICAgfQogIH0KCiAgLy8gQXR0ZW1wdCBldmFsKCkgYm90aCB3aXRoIGFuZCB3aXRob3V0IGVuY2xvc2luZyBpbiBwYXJlbnRoZXNlcy4KICAvLyBOb3RlIHRoYXQgZW5jbG9zaW5nIGNvZXJjZXMgYSBmdW5jdGlvbiBkZWNsYXJhdGlvbiBpbnRvCiAgLy8gYW4gZXhwcmVzc2lvbiB0aGF0IGV2YWwoKSBjYW4gcGFyc2UKICAvLyAob3RoZXJ3aXNlLCBhIFN5bnRheEVycm9yIGlzIHRocm93bikKICBmdW5jdGlvbiB0cnlFdmFsKGNvZGUpIHsKICAgIHZhciByZXN1bHQgPSBudWxsOwogICAgdHJ5IHsKICAgICAgcmVzdWx0ID0gZXZhbChjb2RlKTsKICAgIH0gY2F0Y2goZXJyb3IpIHsKICAgICAgaWYgKCFlcnJvciBpbnN0YW5jZW9mIFN5bnRheEVycm9yKSB7CiAgICAgICAgdGhyb3cgZXJyb3I7CiAgICAgIH0KICAgICAgdHJ5IHsKICAgICAgICByZXN1bHQgPSBldmFsKCIoIiArIGNvZGUgKyAiKSIpOwogICAgICB9IGNhdGNoKGUpIHsKICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIFN5bnRheEVycm9yKSB7CiAgICAgICAgICB0aHJvdyBlcnJvcjsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgdGhyb3cgZTsKICAgICAgICB9CiAgICAgIH0KICAgIH0KICAgIHJldHVybiByZXN1bHQ7CiAgfQoKICBmdW5jdGlvbiBpbml0U2l6aW5nKGVsKSB7CiAgICB2YXIgc2l6aW5nID0gc2l6aW5nUG9saWN5KGVsKTsKICAgIGlmICghc2l6aW5nKQogICAgICByZXR1cm47CgogICAgdmFyIGNlbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCJodG1sd2lkZ2V0X2NvbnRhaW5lciIpOwogICAgaWYgKCFjZWwpCiAgICAgIHJldHVybjsKCiAgICBpZiAodHlwZW9mKHNpemluZy5wYWRkaW5nKSAhPT0gInVuZGVmaW5lZCIpIHsKICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5tYXJnaW4gPSAiMCI7CiAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUucGFkZGluZyA9IHBhZGRpbmdUb0Nzcyh1bnBhY2tQYWRkaW5nKHNpemluZy5wYWRkaW5nKSk7CiAgICB9CgogICAgaWYgKHNpemluZy5maWxsKSB7CiAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3cgPSAiaGlkZGVuIjsKICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS53aWR0aCA9ICIxMDAlIjsKICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5oZWlnaHQgPSAiMTAwJSI7CiAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS53aWR0aCA9ICIxMDAlIjsKICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLmhlaWdodCA9ICIxMDAlIjsKICAgICAgaWYgKGNlbCkgewogICAgICAgIGNlbC5zdHlsZS5wb3NpdGlvbiA9ICJhYnNvbHV0ZSI7CiAgICAgICAgdmFyIHBhZCA9IHVucGFja1BhZGRpbmcoc2l6aW5nLnBhZGRpbmcpOwogICAgICAgIGNlbC5zdHlsZS50b3AgPSBwYWQudG9wICsgInB4IjsKICAgICAgICBjZWwuc3R5bGUucmlnaHQgPSBwYWQucmlnaHQgKyAicHgiOwogICAgICAgIGNlbC5zdHlsZS5ib3R0b20gPSBwYWQuYm90dG9tICsgInB4IjsKICAgICAgICBjZWwuc3R5bGUubGVmdCA9IHBhZC5sZWZ0ICsgInB4IjsKICAgICAgICBlbC5zdHlsZS53aWR0aCA9ICIxMDAlIjsKICAgICAgICBlbC5zdHlsZS5oZWlnaHQgPSAiMTAwJSI7CiAgICAgIH0KCiAgICAgIHJldHVybiB7CiAgICAgICAgZ2V0V2lkdGg6IGZ1bmN0aW9uKCkgeyByZXR1cm4gY2VsLm9mZnNldFdpZHRoOyB9LAogICAgICAgIGdldEhlaWdodDogZnVuY3Rpb24oKSB7IHJldHVybiBjZWwub2Zmc2V0SGVpZ2h0OyB9CiAgICAgIH07CgogICAgfSBlbHNlIHsKICAgICAgZWwuc3R5bGUud2lkdGggPSBweChzaXppbmcud2lkdGgpOwogICAgICBlbC5zdHlsZS5oZWlnaHQgPSBweChzaXppbmcuaGVpZ2h0KTsKCiAgICAgIHJldHVybiB7CiAgICAgICAgZ2V0V2lkdGg6IGZ1bmN0aW9uKCkgeyByZXR1cm4gZWwub2Zmc2V0V2lkdGg7IH0sCiAgICAgICAgZ2V0SGVpZ2h0OiBmdW5jdGlvbigpIHsgcmV0dXJuIGVsLm9mZnNldEhlaWdodDsgfQogICAgICB9OwogICAgfQogIH0KCiAgLy8gRGVmYXVsdCBpbXBsZW1lbnRhdGlvbnMgZm9yIG1ldGhvZHMKICB2YXIgZGVmYXVsdHMgPSB7CiAgICBmaW5kOiBmdW5jdGlvbihzY29wZSkgewogICAgICByZXR1cm4gcXVlcnlTZWxlY3RvckFsbChzY29wZSwgIi4iICsgdGhpcy5uYW1lKTsKICAgIH0sCiAgICByZW5kZXJFcnJvcjogZnVuY3Rpb24oZWwsIGVycikgewogICAgICB2YXIgJGVsID0gJChlbCk7CgogICAgICB0aGlzLmNsZWFyRXJyb3IoZWwpOwoKICAgICAgLy8gQWRkIGFsbCB0aGVzZSBlcnJvciBjbGFzc2VzLCBhcyBTaGlueSBkb2VzCiAgICAgIHZhciBlcnJDbGFzcyA9ICJzaGlueS1vdXRwdXQtZXJyb3IiOwogICAgICBpZiAoZXJyLnR5cGUgIT09IG51bGwpIHsKICAgICAgICAvLyB1c2UgdGhlIGNsYXNzZXMgb2YgdGhlIGVycm9yIGNvbmRpdGlvbiBhcyBDU1MgY2xhc3MgbmFtZXMKICAgICAgICBlcnJDbGFzcyA9IGVyckNsYXNzICsgIiAiICsgJC5tYXAoYXNBcnJheShlcnIudHlwZSksIGZ1bmN0aW9uKHR5cGUpIHsKICAgICAgICAgIHJldHVybiBlcnJDbGFzcyArICItIiArIHR5cGU7CiAgICAgICAgfSkuam9pbigiICIpOwogICAgICB9CiAgICAgIGVyckNsYXNzID0gZXJyQ2xhc3MgKyAiIGh0bWx3aWRnZXRzLWVycm9yIjsKCiAgICAgIC8vIElzIGVsIGlubGluZSBvciBibG9jaz8gSWYgaW5saW5lIG9yIGlubGluZS1ibG9jaywganVzdCBkaXNwbGF5Om5vbmUgaXQKICAgICAgLy8gYW5kIGFkZCBhbiBpbmxpbmUgZXJyb3IuCiAgICAgIHZhciBkaXNwbGF5ID0gJGVsLmNzcygiZGlzcGxheSIpOwogICAgICAkZWwuZGF0YSgicmVzdG9yZS1kaXNwbGF5LW1vZGUiLCBkaXNwbGF5KTsKCiAgICAgIGlmIChkaXNwbGF5ID09PSAiaW5saW5lIiB8fCBkaXNwbGF5ID09PSAiaW5saW5lLWJsb2NrIikgewogICAgICAgICRlbC5oaWRlKCk7CiAgICAgICAgaWYgKGVyci5tZXNzYWdlICE9PSAiIikgewogICAgICAgICAgdmFyIGVycm9yU3BhbiA9ICQoIjxzcGFuPiIpLmFkZENsYXNzKGVyckNsYXNzKTsKICAgICAgICAgIGVycm9yU3Bhbi50ZXh0KGVyci5tZXNzYWdlKTsKICAgICAgICAgICRlbC5hZnRlcihlcnJvclNwYW4pOwogICAgICAgIH0KICAgICAgfSBlbHNlIGlmIChkaXNwbGF5ID09PSAiYmxvY2siKSB7CiAgICAgICAgLy8gSWYgYmxvY2ssIGFkZCBhbiBlcnJvciBqdXN0IGFmdGVyIHRoZSBlbCwgc2V0IHZpc2liaWxpdHk6bm9uZSBvbiB0aGUKICAgICAgICAvLyBlbCwgYW5kIHBvc2l0aW9uIHRoZSBlcnJvciB0byBiZSBvbiB0b3Agb2YgdGhlIGVsLgogICAgICAgIC8vIE1hcmsgaXQgd2l0aCBhIHVuaXF1ZSBJRCBhbmQgQ1NTIGNsYXNzIHNvIHdlIGNhbiByZW1vdmUgaXQgbGF0ZXIuCiAgICAgICAgJGVsLmNzcygidmlzaWJpbGl0eSIsICJoaWRkZW4iKTsKICAgICAgICBpZiAoZXJyLm1lc3NhZ2UgIT09ICIiKSB7CiAgICAgICAgICB2YXIgZXJyb3JEaXYgPSAkKCI8ZGl2PiIpLmFkZENsYXNzKGVyckNsYXNzKS5jc3MoInBvc2l0aW9uIiwgImFic29sdXRlIikKICAgICAgICAgICAgLmNzcygidG9wIiwgZWwub2Zmc2V0VG9wKQogICAgICAgICAgICAuY3NzKCJsZWZ0IiwgZWwub2Zmc2V0TGVmdCkKICAgICAgICAgICAgLy8gc2V0dGluZyB3aWR0aCBjYW4gcHVzaCBvdXQgdGhlIHBhZ2Ugc2l6ZSwgZm9yY2luZyBvdGhlcndpc2UKICAgICAgICAgICAgLy8gdW5uZWNlc3Nhcnkgc2Nyb2xsYmFycyB0byBhcHBlYXIgYW5kIG1ha2luZyBpdCBpbXBvc3NpYmxlIGZvcgogICAgICAgICAgICAvLyB0aGUgZWxlbWVudCB0byBzaHJpbms7IHNvIHVzZSBtYXgtd2lkdGggaW5zdGVhZAogICAgICAgICAgICAuY3NzKCJtYXhXaWR0aCIsIGVsLm9mZnNldFdpZHRoKQogICAgICAgICAgICAuY3NzKCJoZWlnaHQiLCBlbC5vZmZzZXRIZWlnaHQpOwogICAgICAgICAgZXJyb3JEaXYudGV4dChlcnIubWVzc2FnZSk7CiAgICAgICAgICAkZWwuYWZ0ZXIoZXJyb3JEaXYpOwoKICAgICAgICAgIC8vIFJlYWxseSBkdW1iIHdheSB0byBrZWVwIHRoZSBzaXplL3Bvc2l0aW9uIG9mIHRoZSBlcnJvciBpbiBzeW5jIHdpdGgKICAgICAgICAgIC8vIHRoZSBwYXJlbnQgZWxlbWVudCBhcyB0aGUgd2luZG93IGlzIHJlc2l6ZWQgb3Igd2hhdGV2ZXIuCiAgICAgICAgICB2YXIgaW50SWQgPSBzZXRJbnRlcnZhbChmdW5jdGlvbigpIHsKICAgICAgICAgICAgaWYgKCFlcnJvckRpdlswXS5wYXJlbnRFbGVtZW50KSB7CiAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRJZCk7CiAgICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGVycm9yRGl2CiAgICAgICAgICAgICAgLmNzcygidG9wIiwgZWwub2Zmc2V0VG9wKQogICAgICAgICAgICAgIC5jc3MoImxlZnQiLCBlbC5vZmZzZXRMZWZ0KQogICAgICAgICAgICAgIC5jc3MoIm1heFdpZHRoIiwgZWwub2Zmc2V0V2lkdGgpCiAgICAgICAgICAgICAgLmNzcygiaGVpZ2h0IiwgZWwub2Zmc2V0SGVpZ2h0KTsKICAgICAgICAgIH0sIDUwMCk7CiAgICAgICAgfQogICAgICB9CiAgICB9LAogICAgY2xlYXJFcnJvcjogZnVuY3Rpb24oZWwpIHsKICAgICAgdmFyICRlbCA9ICQoZWwpOwogICAgICB2YXIgZGlzcGxheSA9ICRlbC5kYXRhKCJyZXN0b3JlLWRpc3BsYXktbW9kZSIpOwogICAgICAkZWwuZGF0YSgicmVzdG9yZS1kaXNwbGF5LW1vZGUiLCBudWxsKTsKCiAgICAgIGlmIChkaXNwbGF5ID09PSAiaW5saW5lIiB8fCBkaXNwbGF5ID09PSAiaW5saW5lLWJsb2NrIikgewogICAgICAgIGlmIChkaXNwbGF5KQogICAgICAgICAgJGVsLmNzcygiZGlzcGxheSIsIGRpc3BsYXkpOwogICAgICAgICQoZWwubmV4dFNpYmxpbmcpLmZpbHRlcigiLmh0bWx3aWRnZXRzLWVycm9yIikucmVtb3ZlKCk7CiAgICAgIH0gZWxzZSBpZiAoZGlzcGxheSA9PT0gImJsb2NrIil7CiAgICAgICAgJGVsLmNzcygidmlzaWJpbGl0eSIsICJpbmhlcml0Iik7CiAgICAgICAgJChlbC5uZXh0U2libGluZykuZmlsdGVyKCIuaHRtbHdpZGdldHMtZXJyb3IiKS5yZW1vdmUoKTsKICAgICAgfQogICAgfSwKICAgIHNpemluZzoge30KICB9OwoKICAvLyBDYWxsZWQgYnkgd2lkZ2V0IGJpbmRpbmdzIHRvIHJlZ2lzdGVyIGEgbmV3IHR5cGUgb2Ygd2lkZ2V0LiBUaGUgZGVmaW5pdGlvbgogIC8vIG9iamVjdCBjYW4gY29udGFpbiB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6CiAgLy8gLSBuYW1lIChyZXF1aXJlZCkgLSBBIHN0cmluZyBpbmRpY2F0aW5nIHRoZSBiaW5kaW5nIG5hbWUsIHdoaWNoIHdpbGwgYmUKICAvLyAgIHVzZWQgYnkgZGVmYXVsdCBhcyB0aGUgQ1NTIGNsYXNzbmFtZSB0byBsb29rIGZvci4KICAvLyAtIGluaXRpYWxpemUgKG9wdGlvbmFsKSAtIEEgZnVuY3Rpb24oZWwpIHRoYXQgd2lsbCBiZSBjYWxsZWQgb25jZSBwZXIKICAvLyAgIHdpZGdldCBlbGVtZW50OyBpZiBhIHZhbHVlIGlzIHJldHVybmVkLCBpdCB3aWxsIGJlIHBhc3NlZCBhcyB0aGUgdGhpcmQKICAvLyAgIHZhbHVlIHRvIHJlbmRlclZhbHVlLgogIC8vIC0gcmVuZGVyVmFsdWUgKHJlcXVpcmVkKSAtIEEgZnVuY3Rpb24oZWwsIGRhdGEsIGluaXRWYWx1ZSkgdGhhdCB3aWxsIGJlCiAgLy8gICBjYWxsZWQgd2l0aCBkYXRhLiBTdGF0aWMgY29udGV4dHMgd2lsbCBjYXVzZSB0aGlzIHRvIGJlIGNhbGxlZCBvbmNlIHBlcgogIC8vICAgZWxlbWVudDsgU2hpbnkgYXBwcyB3aWxsIGNhdXNlIHRoaXMgdG8gYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzIHBlcgogIC8vICAgZWxlbWVudCwgYXMgdGhlIGRhdGEgY2hhbmdlcy4KICB3aW5kb3cuSFRNTFdpZGdldHMud2lkZ2V0ID0gZnVuY3Rpb24oZGVmaW5pdGlvbikgewogICAgaWYgKCFkZWZpbml0aW9uLm5hbWUpIHsKICAgICAgdGhyb3cgbmV3IEVycm9yKCJXaWRnZXQgbXVzdCBoYXZlIGEgbmFtZSIpOwogICAgfQogICAgaWYgKCFkZWZpbml0aW9uLnR5cGUpIHsKICAgICAgdGhyb3cgbmV3IEVycm9yKCJXaWRnZXQgbXVzdCBoYXZlIGEgdHlwZSIpOwogICAgfQogICAgLy8gQ3VycmVudGx5IHdlIG9ubHkgc3VwcG9ydCBvdXRwdXQgd2lkZ2V0cwogICAgaWYgKGRlZmluaXRpb24udHlwZSAhPT0gIm91dHB1dCIpIHsKICAgICAgdGhyb3cgbmV3IEVycm9yKCJVbnJlY29nbml6ZWQgd2lkZ2V0IHR5cGUgJyIgKyBkZWZpbml0aW9uLnR5cGUgKyAiJyIpOwogICAgfQogICAgLy8gVE9ETzogVmVyaWZ5IHRoYXQgLm5hbWUgaXMgYSB2YWxpZCBDU1MgY2xhc3NuYW1lCgogICAgLy8gU3VwcG9ydCBuZXctc3R5bGUgaW5zdGFuY2UtYm91bmQgZGVmaW5pdGlvbnMuIE9sZC1zdHlsZSBjbGFzcy1ib3VuZAogICAgLy8gZGVmaW5pdGlvbnMgaGF2ZSBvbmUgd2lkZ2V0ICJvYmplY3QiIHBlciB3aWRnZXQgcGVyIHR5cGUvY2xhc3Mgb2YKICAgIC8vIHdpZGdldDsgdGhlIHJlbmRlclZhbHVlIGFuZCByZXNpemUgbWV0aG9kcyBvbiBzdWNoIHdpZGdldCBvYmplY3RzCiAgICAvLyB0YWtlIGVsIGFuZCBpbnN0YW5jZSBhcmd1bWVudHMsIGJlY2F1c2UgdGhlIHdpZGdldCBvYmplY3QgY2FuJ3QKICAgIC8vIHN0b3JlIHRoZW0uIE5ldy1zdHlsZSBpbnN0YW5jZS1ib3VuZCBkZWZpbml0aW9ucyBoYXZlIG9uZSB3aWRnZXQKICAgIC8vIG9iamVjdCBwZXIgd2lkZ2V0IGluc3RhbmNlOyB0aGUgZGVmaW5pdGlvbiB0aGF0J3MgcGFzc2VkIGluIGRvZXNuJ3QKICAgIC8vIHByb3ZpZGUgcmVuZGVyVmFsdWUgb3IgcmVzaXplIG1ldGhvZHMgYXQgYWxsLCBqdXN0IHRoZSBzaW5nbGUgbWV0aG9kCiAgICAvLyAgIGZhY3RvcnkoZWwsIHdpZHRoLCBoZWlnaHQpCiAgICAvLyB3aGljaCByZXR1cm5zIGFuIG9iamVjdCB0aGF0IGhhcyByZW5kZXJWYWx1ZSh4KSBhbmQgcmVzaXplKHcsIGgpLgogICAgLy8gVGhpcyBlbmFibGVzIGEgZmFyIG1vcmUgbmF0dXJhbCBwcm9ncmFtbWluZyBzdHlsZSBmb3IgdGhlIHdpZGdldAogICAgLy8gYXV0aG9yLCB3aG8gY2FuIHN0b3JlIHBlci1pbnN0YW5jZSBzdGF0ZSB1c2luZyBlaXRoZXIgT08tc3R5bGUKICAgIC8vIGluc3RhbmNlIGZpZWxkcyBvciBmdW5jdGlvbmFsLXN0eWxlIGNsb3N1cmUgdmFyaWFibGVzIChJIGd1ZXNzIHRoaXMKICAgIC8vIGlzIGluIGNvbnRyYXN0IHRvIHdoYXQgY2FuIG9ubHkgYmUgY2FsbGVkIEMtc3R5bGUgcHNldWRvLU9PIHdoaWNoIGlzCiAgICAvLyB3aGF0IHdlIHJlcXVpcmVkIGJlZm9yZSkuCiAgICBpZiAoZGVmaW5pdGlvbi5mYWN0b3J5KSB7CiAgICAgIGRlZmluaXRpb24gPSBjcmVhdGVMZWdhY3lEZWZpbml0aW9uQWRhcHRlcihkZWZpbml0aW9uKTsKICAgIH0KCiAgICBpZiAoIWRlZmluaXRpb24ucmVuZGVyVmFsdWUpIHsKICAgICAgdGhyb3cgbmV3IEVycm9yKCJXaWRnZXQgbXVzdCBoYXZlIGEgcmVuZGVyVmFsdWUgZnVuY3Rpb24iKTsKICAgIH0KCiAgICAvLyBGb3Igc3RhdGljIHJlbmRlcmluZyAobm9uLVNoaW55KSwgdXNlIGEgc2ltcGxlIHdpZGdldCByZWdpc3RyYXRpb24KICAgIC8vIHNjaGVtZS4gV2UgYWxzbyB1c2UgdGhpcyBzY2hlbWUgZm9yIFNoaW55IGFwcHMvZG9jdW1lbnRzIHRoYXQgYWxzbwogICAgLy8gY29udGFpbiBzdGF0aWMgd2lkZ2V0cy4KICAgIHdpbmRvdy5IVE1MV2lkZ2V0cy53aWRnZXRzID0gd2luZG93LkhUTUxXaWRnZXRzLndpZGdldHMgfHwgW107CiAgICAvLyBNZXJnZSBkZWZhdWx0cyBpbnRvIHRoZSBkZWZpbml0aW9uOyBkb24ndCBtdXRhdGUgdGhlIG9yaWdpbmFsIGRlZmluaXRpb24uCiAgICB2YXIgc3RhdGljQmluZGluZyA9IGV4dGVuZCh7fSwgZGVmYXVsdHMsIGRlZmluaXRpb24pOwogICAgb3ZlcnJpZGVNZXRob2Qoc3RhdGljQmluZGluZywgImZpbmQiLCBmdW5jdGlvbihzdXBlcmZ1bmMpIHsKICAgICAgcmV0dXJuIGZ1bmN0aW9uKHNjb3BlKSB7CiAgICAgICAgdmFyIHJlc3VsdHMgPSBzdXBlcmZ1bmMoc2NvcGUpOwogICAgICAgIC8vIEZpbHRlciBvdXQgU2hpbnkgb3V0cHV0cywgd2Ugb25seSB3YW50IHRoZSBzdGF0aWMga2luZAogICAgICAgIHJldHVybiBmaWx0ZXJCeUNsYXNzKHJlc3VsdHMsICJodG1sLXdpZGdldC1vdXRwdXQiLCBmYWxzZSk7CiAgICAgIH07CiAgICB9KTsKICAgIHdpbmRvdy5IVE1MV2lkZ2V0cy53aWRnZXRzLnB1c2goc3RhdGljQmluZGluZyk7CgogICAgaWYgKHNoaW55TW9kZSkgewogICAgICAvLyBTaGlueSBpcyBydW5uaW5nLiBSZWdpc3RlciB0aGUgZGVmaW5pdGlvbiB3aXRoIGFuIG91dHB1dCBiaW5kaW5nLgogICAgICAvLyBUaGUgZGVmaW5pdGlvbiBpdHNlbGYgd2lsbCBub3QgYmUgdGhlIG91dHB1dCBiaW5kaW5nLCBpbnN0ZWFkCiAgICAgIC8vIHdlIHdpbGwgbWFrZSBhbiBvdXRwdXQgYmluZGluZyBvYmplY3QgdGhhdCBkZWxlZ2F0ZXMgdG8gdGhlCiAgICAgIC8vIGRlZmluaXRpb24uIFRoaXMgaXMgYmVjYXVzZSB3ZSBmb29saXNobHkgdXNlZCB0aGUgc2FtZSBtZXRob2QKICAgICAgLy8gbmFtZSAocmVuZGVyVmFsdWUpIGZvciBodG1sd2lkZ2V0cyBkZWZpbml0aW9uIGFuZCBTaGlueSBiaW5kaW5ncwogICAgICAvLyBidXQgdGhleSBhY3R1YWxseSBoYXZlIHF1aXRlIGRpZmZlcmVudCBzZW1hbnRpY3MgKHRoZSBTaGlueQogICAgICAvLyBiaW5kaW5ncyByZWNlaXZlIGRhdGEgdGhhdCBpbmNsdWRlcyBsb3RzIG9mIG1ldGFkYXRhIHRoYXQgaXQKICAgICAgLy8gc3RyaXBzIG9mZiBiZWZvcmUgY2FsbGluZyBodG1sd2lkZ2V0cyByZW5kZXJWYWx1ZSkuIFdlIGNhbid0CiAgICAgIC8vIGp1c3QgaWdub3JlIHRoZSBkaWZmZXJlbmNlIGJlY2F1c2UgaW4gc29tZSB3aWRnZXRzIGl0J3MgaGVscGZ1bAogICAgICAvLyB0byBjYWxsIHRoaXMucmVuZGVyVmFsdWUoKSBmcm9tIGluc2lkZSBvZiByZXNpemUoKSwgYW5kIGlmCiAgICAgIC8vIHdlJ3JlIG5vdCBkZWxlZ2F0aW5nLCB0aGVuIHRoYXQgY2FsbCB3aWxsIGdvIHRvIHRoZSBTaGlueQogICAgICAvLyB2ZXJzaW9uIGluc3RlYWQgb2YgdGhlIGh0bWx3aWRnZXRzIHZlcnNpb24uCgogICAgICAvLyBNZXJnZSBkZWZhdWx0cyB3aXRoIGRlZmluaXRpb24sIHdpdGhvdXQgbXV0YXRpbmcgZWl0aGVyLgogICAgICB2YXIgYmluZGluZ0RlZiA9IGV4dGVuZCh7fSwgZGVmYXVsdHMsIGRlZmluaXRpb24pOwoKICAgICAgLy8gVGhpcyBvYmplY3Qgd2lsbCBiZSBvdXIgYWN0dWFsIFNoaW55IGJpbmRpbmcuCiAgICAgIHZhciBzaGlueUJpbmRpbmcgPSBuZXcgU2hpbnkuT3V0cHV0QmluZGluZygpOwoKICAgICAgLy8gV2l0aCBhIGZldyBleGNlcHRpb25zLCB3ZSdsbCB3YW50IHRvIHNpbXBseSB1c2UgdGhlIGJpbmRpbmdEZWYncwogICAgICAvLyB2ZXJzaW9uIG9mIG1ldGhvZHMgaWYgdGhleSBhcmUgYXZhaWxhYmxlLCBvdGhlcndpc2UgZmFsbCBiYWNrIHRvCiAgICAgIC8vIFNoaW55J3MgZGVmYXVsdHMuIE5PVEU6IElmIFNoaW55J3Mgb3V0cHV0IGJpbmRpbmdzIGdhaW4gYWRkaXRpb25hbAogICAgICAvLyBtZXRob2RzIGluIHRoZSBmdXR1cmUsIGFuZCB3ZSB3YW50IHRoZW0gdG8gYmUgb3ZlcnJpZGVhYmxlIGJ5CiAgICAgIC8vIEhUTUxXaWRnZXQgYmluZGluZyBkZWZpbml0aW9ucywgdGhlbiB3ZSdsbCBuZWVkIHRvIGFkZCB0aGVtIHRvIHRoaXMKICAgICAgLy8gbGlzdC4KICAgICAgZGVsZWdhdGVNZXRob2Qoc2hpbnlCaW5kaW5nLCBiaW5kaW5nRGVmLCAiZ2V0SWQiKTsKICAgICAgZGVsZWdhdGVNZXRob2Qoc2hpbnlCaW5kaW5nLCBiaW5kaW5nRGVmLCAib25WYWx1ZUNoYW5nZSIpOwogICAgICBkZWxlZ2F0ZU1ldGhvZChzaGlueUJpbmRpbmcsIGJpbmRpbmdEZWYsICJvblZhbHVlRXJyb3IiKTsKICAgICAgZGVsZWdhdGVNZXRob2Qoc2hpbnlCaW5kaW5nLCBiaW5kaW5nRGVmLCAicmVuZGVyRXJyb3IiKTsKICAgICAgZGVsZWdhdGVNZXRob2Qoc2hpbnlCaW5kaW5nLCBiaW5kaW5nRGVmLCAiY2xlYXJFcnJvciIpOwogICAgICBkZWxlZ2F0ZU1ldGhvZChzaGlueUJpbmRpbmcsIGJpbmRpbmdEZWYsICJzaG93UHJvZ3Jlc3MiKTsKCiAgICAgIC8vIFRoZSBmaW5kLCByZW5kZXJWYWx1ZSwgYW5kIHJlc2l6ZSBhcmUgaGFuZGxlZCBkaWZmZXJlbnRseSwgYmVjYXVzZSB3ZQogICAgICAvLyB3YW50IHRvIGFjdHVhbGx5IGRlY29yYXRlIHRoZSBiZWhhdmlvciBvZiB0aGUgYmluZGluZ0RlZiBtZXRob2RzLgoKICAgICAgc2hpbnlCaW5kaW5nLmZpbmQgPSBmdW5jdGlvbihzY29wZSkgewogICAgICAgIHZhciByZXN1bHRzID0gYmluZGluZ0RlZi5maW5kKHNjb3BlKTsKCiAgICAgICAgLy8gT25seSByZXR1cm4gZWxlbWVudHMgdGhhdCBhcmUgU2hpbnkgb3V0cHV0cywgbm90IHN0YXRpYyBvbmVzCiAgICAgICAgdmFyIGR5bmFtaWNSZXN1bHRzID0gcmVzdWx0cy5maWx0ZXIoIi5odG1sLXdpZGdldC1vdXRwdXQiKTsKCiAgICAgICAgLy8gSXQncyBwb3NzaWJsZSB0aGF0IHdoYXRldmVyIGNhdXNlZCBTaGlueSB0byB0aGluayB0aGVyZSBtaWdodCBiZQogICAgICAgIC8vIG5ldyBkeW5hbWljIG91dHB1dHMsIGFsc28gY2F1c2VkIHRoZXJlIHRvIGJlIG5ldyBzdGF0aWMgb3V0cHV0cy4KICAgICAgICAvLyBTaW5jZSB0aGVyZSBtaWdodCBiZSBsb3RzIG9mIGRpZmZlcmVudCBodG1sd2lkZ2V0cyBiaW5kaW5ncywgd2UKICAgICAgICAvLyBzY2hlZHVsZSBleGVjdXRpb24gZm9yIGxhdGVyLS1ubyBuZWVkIHRvIHN0YXRpY1JlbmRlciBtdWx0aXBsZQogICAgICAgIC8vIHRpbWVzLgogICAgICAgIGlmIChyZXN1bHRzLmxlbmd0aCAhPT0gZHluYW1pY1Jlc3VsdHMubGVuZ3RoKQogICAgICAgICAgc2NoZWR1bGVTdGF0aWNSZW5kZXIoKTsKCiAgICAgICAgcmV0dXJuIGR5bmFtaWNSZXN1bHRzOwogICAgICB9OwoKICAgICAgLy8gV3JhcCByZW5kZXJWYWx1ZSB0byBoYW5kbGUgaW5pdGlhbGl6YXRpb24sIHdoaWNoIHVuZm9ydHVuYXRlbHkgaXNuJ3QKICAgICAgLy8gc3VwcG9ydGVkIG5hdGl2ZWx5IGJ5IFNoaW55IGF0IHRoZSB0aW1lIG9mIHRoaXMgd3JpdGluZy4KCiAgICAgIHNoaW55QmluZGluZy5yZW5kZXJWYWx1ZSA9IGZ1bmN0aW9uKGVsLCBkYXRhKSB7CiAgICAgICAgU2hpbnkucmVuZGVyRGVwZW5kZW5jaWVzKGRhdGEuZGVwcyk7CiAgICAgICAgLy8gUmVzb2x2ZSBzdHJpbmdzIG1hcmtlZCBhcyBqYXZhc2NyaXB0IGxpdGVyYWxzIHRvIG9iamVjdHMKICAgICAgICBpZiAoIShkYXRhLmV2YWxzIGluc3RhbmNlb2YgQXJyYXkpKSBkYXRhLmV2YWxzID0gW2RhdGEuZXZhbHNdOwogICAgICAgIGZvciAodmFyIGkgPSAwOyBkYXRhLmV2YWxzICYmIGkgPCBkYXRhLmV2YWxzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICB3aW5kb3cuSFRNTFdpZGdldHMuZXZhbHVhdGVTdHJpbmdNZW1iZXIoZGF0YS54LCBkYXRhLmV2YWxzW2ldKTsKICAgICAgICB9CiAgICAgICAgaWYgKCFiaW5kaW5nRGVmLnJlbmRlck9uTnVsbFZhbHVlKSB7CiAgICAgICAgICBpZiAoZGF0YS54ID09PSBudWxsKSB7CiAgICAgICAgICAgIGVsLnN0eWxlLnZpc2liaWxpdHkgPSAiaGlkZGVuIjsKICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgZWwuc3R5bGUudmlzaWJpbGl0eSA9ICJpbmhlcml0IjsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKCFlbGVtZW50RGF0YShlbCwgImluaXRpYWxpemVkIikpIHsKICAgICAgICAgIGluaXRTaXppbmcoZWwpOwoKICAgICAgICAgIGVsZW1lbnREYXRhKGVsLCAiaW5pdGlhbGl6ZWQiLCB0cnVlKTsKICAgICAgICAgIGlmIChiaW5kaW5nRGVmLmluaXRpYWxpemUpIHsKICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGJpbmRpbmdEZWYuaW5pdGlhbGl6ZShlbCwgZWwub2Zmc2V0V2lkdGgsCiAgICAgICAgICAgICAgZWwub2Zmc2V0SGVpZ2h0KTsKICAgICAgICAgICAgZWxlbWVudERhdGEoZWwsICJpbml0X3Jlc3VsdCIsIHJlc3VsdCk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGJpbmRpbmdEZWYucmVuZGVyVmFsdWUoZWwsIGRhdGEueCwgZWxlbWVudERhdGEoZWwsICJpbml0X3Jlc3VsdCIpKTsKICAgICAgICBldmFsQW5kUnVuKGRhdGEuanNIb29rcy5yZW5kZXIsIGVsZW1lbnREYXRhKGVsLCAiaW5pdF9yZXN1bHQiKSwgW2VsLCBkYXRhLnhdKTsKICAgICAgfTsKCiAgICAgIC8vIE9ubHkgb3ZlcnJpZGUgcmVzaXplIGlmIGJpbmRpbmdEZWYgaW1wbGVtZW50cyBpdAogICAgICBpZiAoYmluZGluZ0RlZi5yZXNpemUpIHsKICAgICAgICBzaGlueUJpbmRpbmcucmVzaXplID0gZnVuY3Rpb24oZWwsIHdpZHRoLCBoZWlnaHQpIHsKICAgICAgICAgIC8vIFNoaW55IGNhbiBjYWxsIHJlc2l6ZSBiZWZvcmUgaW5pdGlhbGl6ZS9yZW5kZXJWYWx1ZSBoYXZlIGJlZW4KICAgICAgICAgIC8vIGNhbGxlZCwgd2hpY2ggZG9lc24ndCBtYWtlIHNlbnNlIGZvciB3aWRnZXRzLgogICAgICAgICAgaWYgKGVsZW1lbnREYXRhKGVsLCAiaW5pdGlhbGl6ZWQiKSkgewogICAgICAgICAgICBiaW5kaW5nRGVmLnJlc2l6ZShlbCwgd2lkdGgsIGhlaWdodCwgZWxlbWVudERhdGEoZWwsICJpbml0X3Jlc3VsdCIpKTsKICAgICAgICAgIH0KICAgICAgICB9OwogICAgICB9CgogICAgICBTaGlueS5vdXRwdXRCaW5kaW5ncy5yZWdpc3RlcihzaGlueUJpbmRpbmcsIGJpbmRpbmdEZWYubmFtZSk7CiAgICB9CiAgfTsKCiAgdmFyIHNjaGVkdWxlU3RhdGljUmVuZGVyVGltZXJJZCA9IG51bGw7CiAgZnVuY3Rpb24gc2NoZWR1bGVTdGF0aWNSZW5kZXIoKSB7CiAgICBpZiAoIXNjaGVkdWxlU3RhdGljUmVuZGVyVGltZXJJZCkgewogICAgICBzY2hlZHVsZVN0YXRpY1JlbmRlclRpbWVySWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgewogICAgICAgIHNjaGVkdWxlU3RhdGljUmVuZGVyVGltZXJJZCA9IG51bGw7CiAgICAgICAgd2luZG93LkhUTUxXaWRnZXRzLnN0YXRpY1JlbmRlcigpOwogICAgICB9LCAxKTsKICAgIH0KICB9CgogIC8vIFJlbmRlciBzdGF0aWMgd2lkZ2V0cyBhZnRlciB0aGUgZG9jdW1lbnQgZmluaXNoZXMgbG9hZGluZwogIC8vIFN0YXRpY2FsbHkgcmVuZGVyIGFsbCBlbGVtZW50cyB0aGF0IGFyZSBvZiB0aGlzIHdpZGdldCdzIGNsYXNzCiAgd2luZG93LkhUTUxXaWRnZXRzLnN0YXRpY1JlbmRlciA9IGZ1bmN0aW9uKCkgewogICAgdmFyIGJpbmRpbmdzID0gd2luZG93LkhUTUxXaWRnZXRzLndpZGdldHMgfHwgW107CiAgICBmb3JFYWNoKGJpbmRpbmdzLCBmdW5jdGlvbihiaW5kaW5nKSB7CiAgICAgIHZhciBtYXRjaGVzID0gYmluZGluZy5maW5kKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCk7CiAgICAgIGZvckVhY2gobWF0Y2hlcywgZnVuY3Rpb24oZWwpIHsKICAgICAgICB2YXIgc2l6ZU9iaiA9IGluaXRTaXppbmcoZWwsIGJpbmRpbmcpOwoKICAgICAgICBpZiAoaGFzQ2xhc3MoZWwsICJodG1sLXdpZGdldC1zdGF0aWMtYm91bmQiKSkKICAgICAgICAgIHJldHVybjsKICAgICAgICBlbC5jbGFzc05hbWUgPSBlbC5jbGFzc05hbWUgKyAiIGh0bWwtd2lkZ2V0LXN0YXRpYy1ib3VuZCI7CgogICAgICAgIHZhciBpbml0UmVzdWx0OwogICAgICAgIGlmIChiaW5kaW5nLmluaXRpYWxpemUpIHsKICAgICAgICAgIGluaXRSZXN1bHQgPSBiaW5kaW5nLmluaXRpYWxpemUoZWwsCiAgICAgICAgICAgIHNpemVPYmogPyBzaXplT2JqLmdldFdpZHRoKCkgOiBlbC5vZmZzZXRXaWR0aCwKICAgICAgICAgICAgc2l6ZU9iaiA/IHNpemVPYmouZ2V0SGVpZ2h0KCkgOiBlbC5vZmZzZXRIZWlnaHQKICAgICAgICAgICk7CiAgICAgICAgICBlbGVtZW50RGF0YShlbCwgImluaXRfcmVzdWx0IiwgaW5pdFJlc3VsdCk7CiAgICAgICAgfQoKICAgICAgICBpZiAoYmluZGluZy5yZXNpemUpIHsKICAgICAgICAgIHZhciBsYXN0U2l6ZSA9IHsKICAgICAgICAgICAgdzogc2l6ZU9iaiA/IHNpemVPYmouZ2V0V2lkdGgoKSA6IGVsLm9mZnNldFdpZHRoLAogICAgICAgICAgICBoOiBzaXplT2JqID8gc2l6ZU9iai5nZXRIZWlnaHQoKSA6IGVsLm9mZnNldEhlaWdodAogICAgICAgICAgfTsKICAgICAgICAgIHZhciByZXNpemVIYW5kbGVyID0gZnVuY3Rpb24oZSkgewogICAgICAgICAgICB2YXIgc2l6ZSA9IHsKICAgICAgICAgICAgICB3OiBzaXplT2JqID8gc2l6ZU9iai5nZXRXaWR0aCgpIDogZWwub2Zmc2V0V2lkdGgsCiAgICAgICAgICAgICAgaDogc2l6ZU9iaiA/IHNpemVPYmouZ2V0SGVpZ2h0KCkgOiBlbC5vZmZzZXRIZWlnaHQKICAgICAgICAgICAgfTsKICAgICAgICAgICAgaWYgKHNpemUudyA9PT0gMCAmJiBzaXplLmggPT09IDApCiAgICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgICBpZiAoc2l6ZS53ID09PSBsYXN0U2l6ZS53ICYmIHNpemUuaCA9PT0gbGFzdFNpemUuaCkKICAgICAgICAgICAgICByZXR1cm47CiAgICAgICAgICAgIGxhc3RTaXplID0gc2l6ZTsKICAgICAgICAgICAgYmluZGluZy5yZXNpemUoZWwsIHNpemUudywgc2l6ZS5oLCBpbml0UmVzdWx0KTsKICAgICAgICAgIH07CgogICAgICAgICAgb24od2luZG93LCAicmVzaXplIiwgcmVzaXplSGFuZGxlcik7CgogICAgICAgICAgLy8gVGhpcyBpcyBuZWVkZWQgZm9yIGNhc2VzIHdoZXJlIHdlJ3JlIHJ1bm5pbmcgaW4gYSBTaGlueQogICAgICAgICAgLy8gYXBwLCBidXQgdGhlIHdpZGdldCBpdHNlbGYgaXMgbm90IGEgU2hpbnkgb3V0cHV0LCBidXQKICAgICAgICAgIC8vIHJhdGhlciBhIHNpbXBsZSBzdGF0aWMgd2lkZ2V0LiBPbmUgZXhhbXBsZSBvZiB0aGlzIGlzCiAgICAgICAgICAvLyBhbiBybWFya2Rvd24gZG9jdW1lbnQgdGhhdCBoYXMgcnVudGltZTpzaGlueSBhbmQgd2lkZ2V0CiAgICAgICAgICAvLyB0aGF0IGlzbid0IGluIGEgcmVuZGVyIGZ1bmN0aW9uLiBTaGlueSBvbmx5IGtub3dzIHRvCiAgICAgICAgICAvLyBjYWxsIHJlc2l6ZSBoYW5kbGVycyBmb3IgU2hpbnkgb3V0cHV0cywgbm90IGZvciBzdGF0aWMKICAgICAgICAgIC8vIHdpZGdldHMsIHNvIHdlIGRvIGl0IG91cnNlbHZlcy4KICAgICAgICAgIGlmICh3aW5kb3cualF1ZXJ5KSB7CiAgICAgICAgICAgIHdpbmRvdy5qUXVlcnkoZG9jdW1lbnQpLm9uKAogICAgICAgICAgICAgICJzaG93bi5odG1sd2lkZ2V0cyBzaG93bi5icy50YWIuaHRtbHdpZGdldHMgc2hvd24uYnMuY29sbGFwc2UuaHRtbHdpZGdldHMiLAogICAgICAgICAgICAgIHJlc2l6ZUhhbmRsZXIKICAgICAgICAgICAgKTsKICAgICAgICAgICAgd2luZG93LmpRdWVyeShkb2N1bWVudCkub24oCiAgICAgICAgICAgICAgImhpZGRlbi5odG1sd2lkZ2V0cyBoaWRkZW4uYnMudGFiLmh0bWx3aWRnZXRzIGhpZGRlbi5icy5jb2xsYXBzZS5odG1sd2lkZ2V0cyIsCiAgICAgICAgICAgICAgcmVzaXplSGFuZGxlcgogICAgICAgICAgICApOwogICAgICAgICAgfQoKICAgICAgICAgIC8vIFRoaXMgaXMgbmVlZGVkIGZvciB0aGUgc3BlY2lmaWMgY2FzZSBvZiBpb3NsaWRlcywgd2hpY2gKICAgICAgICAgIC8vIGZsaXBzIHNsaWRlcyBiZXR3ZWVuIGRpc3BsYXk6bm9uZSBhbmQgZGlzcGxheTpibG9jay4KICAgICAgICAgIC8vIElkZWFsbHkgd2Ugd291bGQgbm90IGhhdmUgdG8gaGF2ZSBpb3NsaWRlLXNwZWNpZmljIGNvZGUKICAgICAgICAgIC8vIGhlcmUsIGJ1dCByYXRoZXIgaGF2ZSBpb3NsaWRlcyByYWlzZSBhIGdlbmVyaWMgZXZlbnQsCiAgICAgICAgICAvLyBidXQgdGhlIHJtYXJrZG93biBwYWNrYWdlIGp1c3Qgd2VudCB0byBDUkFOIHNvIHRoZQogICAgICAgICAgLy8gd2luZG93IHRvIGdldHRpbmcgdGhhdCBmaXhlZCBtYXkgYmUgbG9uZy4KICAgICAgICAgIGlmICh3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcikgewogICAgICAgICAgICAvLyBJdCdzIE9LIHRvIGxpbWl0IHRoaXMgdG8gd2luZG93LmFkZEV2ZW50TGlzdGVuZXIKICAgICAgICAgICAgLy8gYnJvd3NlcnMgYmVjYXVzZSBpb3NsaWRlcyBpdHNlbGYgb25seSBzdXBwb3J0cwogICAgICAgICAgICAvLyBzdWNoIGJyb3dzZXJzLgogICAgICAgICAgICBvbihkb2N1bWVudCwgInNsaWRlZW50ZXIiLCByZXNpemVIYW5kbGVyKTsKICAgICAgICAgICAgb24oZG9jdW1lbnQsICJzbGlkZWxlYXZlIiwgcmVzaXplSGFuZGxlcik7CiAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICB2YXIgc2NyaXB0RGF0YSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoInNjcmlwdFtkYXRhLWZvcj0nIiArIGVsLmlkICsgIiddW3R5cGU9J2FwcGxpY2F0aW9uL2pzb24nXSIpOwogICAgICAgIGlmIChzY3JpcHREYXRhKSB7CiAgICAgICAgICB2YXIgZGF0YSA9IEpTT04ucGFyc2Uoc2NyaXB0RGF0YS50ZXh0Q29udGVudCB8fCBzY3JpcHREYXRhLnRleHQpOwogICAgICAgICAgLy8gUmVzb2x2ZSBzdHJpbmdzIG1hcmtlZCBhcyBqYXZhc2NyaXB0IGxpdGVyYWxzIHRvIG9iamVjdHMKICAgICAgICAgIGlmICghKGRhdGEuZXZhbHMgaW5zdGFuY2VvZiBBcnJheSkpIGRhdGEuZXZhbHMgPSBbZGF0YS5ldmFsc107CiAgICAgICAgICBmb3IgKHZhciBrID0gMDsgZGF0YS5ldmFscyAmJiBrIDwgZGF0YS5ldmFscy5sZW5ndGg7IGsrKykgewogICAgICAgICAgICB3aW5kb3cuSFRNTFdpZGdldHMuZXZhbHVhdGVTdHJpbmdNZW1iZXIoZGF0YS54LCBkYXRhLmV2YWxzW2tdKTsKICAgICAgICAgIH0KICAgICAgICAgIGJpbmRpbmcucmVuZGVyVmFsdWUoZWwsIGRhdGEueCwgaW5pdFJlc3VsdCk7CiAgICAgICAgICBldmFsQW5kUnVuKGRhdGEuanNIb29rcy5yZW5kZXIsIGluaXRSZXN1bHQsIFtlbCwgZGF0YS54XSk7CiAgICAgICAgfQogICAgICB9KTsKICAgIH0pOwoKICAgIGludm9rZVBvc3RSZW5kZXJIYW5kbGVycygpOwogIH0KCgogIGZ1bmN0aW9uIGhhc19qUXVlcnkzKCkgewogICAgaWYgKCF3aW5kb3cualF1ZXJ5KSB7CiAgICAgIHJldHVybiBmYWxzZTsKICAgIH0KICAgIHZhciAkdmVyc2lvbiA9IHdpbmRvdy5qUXVlcnkuZm4uanF1ZXJ5OwogICAgdmFyICRtYWpvcl92ZXJzaW9uID0gcGFyc2VJbnQoJHZlcnNpb24uc3BsaXQoIi4iKVswXSk7CiAgICByZXR1cm4gJG1ham9yX3ZlcnNpb24gPj0gMzsKICB9CgogIC8qCiAgLyBTaGlueSAxLjQgYnVtcGVkIGpRdWVyeSBmcm9tIDEueCB0byAzLnggd2hpY2ggbWVhbnMgalF1ZXJ5J3MKICAvIG9uLXJlYWR5IGhhbmRsZXIgKGkuZS4sICQoZm4pKSBpcyBub3cgYXN5bmNyb25vdXMgKGkuZS4sIGl0IG5vdwogIC8gcmVhbGx5IG1lYW5zICQoc2V0VGltZW91dChmbikpLgogIC8gaHR0cHM6Ly9qcXVlcnkuY29tL3VwZ3JhZGUtZ3VpZGUvMy4wLyNicmVha2luZy1jaGFuZ2UtZG9jdW1lbnQtcmVhZHktaGFuZGxlcnMtYXJlLW5vdy1hc3luY2hyb25vdXMKICAvCiAgLyBTaW5jZSBTaGlueSB1c2VzICQoKSB0byBzY2hlZHVsZSBpbml0U2hpbnksIHNoaW55Pj0xLjQgY2FsbHMgaW5pdFNoaW55CiAgLyBvbmUgdGljayBsYXRlciB0aGFuIGl0IGRpZCBiZWZvcmUsIHdoaWNoIG1lYW5zIHN0YXRpY1JlbmRlcigpIGlzCiAgLyBjYWxsZWQgcmVuZGVyVmFsdWUoKSBlYXJsaWVyIHRoYW4gKGFkdmFuY2VkKSB3aWRnZXQgYXV0aG9ycyBtaWdodCBiZSBleHBlY3RpbmcuCiAgLyBodHRwczovL2dpdGh1Yi5jb20vcnN0dWRpby9zaGlueS9pc3N1ZXMvMjYzMAogIC8KICAvIEZvciBhIGNvbmNyZXRlIGV4YW1wbGUsIGxlYWZsZXQgaGFzIHNvbWUgbWV0aG9kcyAoZS5nLiwgdXBkYXRlQm91bmRzKQogIC8gd2hpY2ggcmVmZXJlbmNlIFNoaW55IG1ldGhvZHMgcmVnaXN0ZXJlZCBpbiBpbml0U2hpbnkgKGUuZy4sIHNldElucHV0VmFsdWUpLgogIC8gU2luY2UgbGVhZmxldCBpcyBwcml2eSB0byB0aGlzIGxpZmUtY3ljbGUsIGl0IGtub3dzIHRvIHVzZSBzZXRUaW1lb3V0KCkgdG8KICAvIGRlbGF5IGV4ZWN1dGlvbiBvZiB0aG9zZSBtZXRob2RzICh1bnRpbCBTaGlueSBtZXRob2RzIGFyZSByZWFkeSkKICAvIGh0dHBzOi8vZ2l0aHViLmNvbS9yc3R1ZGlvL2xlYWZsZXQvYmxvYi8xOGVjOTgxL2phdmFzY3JpcHQvc3JjL2luZGV4LmpzI0wyNjYtTDI2OAogIC8KICAvIElkZWFsbHkgd2lkZ2V0IGF1dGhvcnMgd291bGRuJ3QgbmVlZCB0byB1c2UgdGhpcyBzZXRUaW1lb3V0KCkgaGFjayB0aGF0CiAgLyBsZWFmbGV0IHVzZXMgdG8gY2FsbCBTaGlueSBtZXRob2RzIG9uIGEgc3RhdGljUmVuZGVyKCkuIEluIHRoZSBsb25nIHJ1biwKICAvIHRoZSBsb2dpYyBpbml0U2hpbnkgc2hvdWxkIGJlIGJyb2tlbiB1cCBzbyB0aGF0IG1ldGhvZCByZWdpc3RyYXRpb24gaGFwcGVucwogIC8gcmlnaHQgYXdheSwgYnV0IGJpbmRpbmcgaGFwcGVucyBsYXRlci4KICAqLwogIGZ1bmN0aW9uIG1heWJlU3RhdGljUmVuZGVyTGF0ZXIoKSB7CiAgICBpZiAoc2hpbnlNb2RlICYmIGhhc19qUXVlcnkzKCkpIHsKICAgICAgd2luZG93LmpRdWVyeSh3aW5kb3cuSFRNTFdpZGdldHMuc3RhdGljUmVuZGVyKTsKICAgIH0gZWxzZSB7CiAgICAgIHdpbmRvdy5IVE1MV2lkZ2V0cy5zdGF0aWNSZW5kZXIoKTsKICAgIH0KICB9CgogIGlmIChkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKSB7CiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCJET01Db250ZW50TG9hZGVkIiwgZnVuY3Rpb24oKSB7CiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoIkRPTUNvbnRlbnRMb2FkZWQiLCBhcmd1bWVudHMuY2FsbGVlLCBmYWxzZSk7CiAgICAgIG1heWJlU3RhdGljUmVuZGVyTGF0ZXIoKTsKICAgIH0sIGZhbHNlKTsKICB9IGVsc2UgaWYgKGRvY3VtZW50LmF0dGFjaEV2ZW50KSB7CiAgICBkb2N1bWVudC5hdHRhY2hFdmVudCgib25yZWFkeXN0YXRlY2hhbmdlIiwgZnVuY3Rpb24oKSB7CiAgICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAiY29tcGxldGUiKSB7CiAgICAgICAgZG9jdW1lbnQuZGV0YWNoRXZlbnQoIm9ucmVhZHlzdGF0ZWNoYW5nZSIsIGFyZ3VtZW50cy5jYWxsZWUpOwogICAgICAgIG1heWJlU3RhdGljUmVuZGVyTGF0ZXIoKTsKICAgICAgfQogICAgfSk7CiAgfQoKCiAgd2luZG93LkhUTUxXaWRnZXRzLmdldEF0dGFjaG1lbnRVcmwgPSBmdW5jdGlvbihkZXBuYW1lLCBrZXkpIHsKICAgIC8vIElmIG5vIGtleSwgZGVmYXVsdCB0byB0aGUgZmlyc3QgaXRlbQogICAgaWYgKHR5cGVvZihrZXkpID09PSAidW5kZWZpbmVkIikKICAgICAga2V5ID0gMTsKCiAgICB2YXIgbGluayA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGRlcG5hbWUgKyAiLSIgKyBrZXkgKyAiLWF0dGFjaG1lbnQiKTsKICAgIGlmICghbGluaykgewogICAgICB0aHJvdyBuZXcgRXJyb3IoIkF0dGFjaG1lbnQgIiArIGRlcG5hbWUgKyAiLyIgKyBrZXkgKyAiIG5vdCBmb3VuZCBpbiBkb2N1bWVudCIpOwogICAgfQogICAgcmV0dXJuIGxpbmsuZ2V0QXR0cmlidXRlKCJocmVmIik7CiAgfTsKCiAgd2luZG93LkhUTUxXaWRnZXRzLmRhdGFmcmFtZVRvRDMgPSBmdW5jdGlvbihkZikgewogICAgdmFyIG5hbWVzID0gW107CiAgICB2YXIgbGVuZ3RoOwogICAgZm9yICh2YXIgbmFtZSBpbiBkZikgewogICAgICAgIGlmIChkZi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkKICAgICAgICAgICAgbmFtZXMucHVzaChuYW1lKTsKICAgICAgICBpZiAodHlwZW9mKGRmW25hbWVdKSAhPT0gIm9iamVjdCIgfHwgdHlwZW9mKGRmW25hbWVdLmxlbmd0aCkgPT09ICJ1bmRlZmluZWQiKSB7CiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigiQWxsIGZpZWxkcyBtdXN0IGJlIGFycmF5cyIpOwogICAgICAgIH0gZWxzZSBpZiAodHlwZW9mKGxlbmd0aCkgIT09ICJ1bmRlZmluZWQiICYmIGxlbmd0aCAhPT0gZGZbbmFtZV0ubGVuZ3RoKSB7CiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigiQWxsIGZpZWxkcyBtdXN0IGJlIGFycmF5cyBvZiB0aGUgc2FtZSBsZW5ndGgiKTsKICAgICAgICB9CiAgICAgICAgbGVuZ3RoID0gZGZbbmFtZV0ubGVuZ3RoOwogICAgfQogICAgdmFyIHJlc3VsdHMgPSBbXTsKICAgIHZhciBpdGVtOwogICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgbGVuZ3RoOyByb3crKykgewogICAgICAgIGl0ZW0gPSB7fTsKICAgICAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCBuYW1lcy5sZW5ndGg7IGNvbCsrKSB7CiAgICAgICAgICAgIGl0ZW1bbmFtZXNbY29sXV0gPSBkZltuYW1lc1tjb2xdXVtyb3ddOwogICAgICAgIH0KICAgICAgICByZXN1bHRzLnB1c2goaXRlbSk7CiAgICB9CiAgICByZXR1cm4gcmVzdWx0czsKICB9OwoKICB3aW5kb3cuSFRNTFdpZGdldHMudHJhbnNwb3NlQXJyYXkyRCA9IGZ1bmN0aW9uKGFycmF5KSB7CiAgICAgIGlmIChhcnJheS5sZW5ndGggPT09IDApIHJldHVybiBhcnJheTsKICAgICAgdmFyIG5ld0FycmF5ID0gYXJyYXlbMF0ubWFwKGZ1bmN0aW9uKGNvbCwgaSkgewogICAgICAgICAgcmV0dXJuIGFycmF5Lm1hcChmdW5jdGlvbihyb3cpIHsKICAgICAgICAgICAgICByZXR1cm4gcm93W2ldCiAgICAgICAgICB9KQogICAgICB9KTsKICAgICAgcmV0dXJuIG5ld0FycmF5OwogIH07CiAgLy8gU3BsaXQgdmFsdWUgYXQgc3BsaXRDaGFyLCBidXQgYWxsb3cgc3BsaXRDaGFyIHRvIGJlIGVzY2FwZWQKICAvLyB1c2luZyBlc2NhcGVDaGFyLiBBbnkgb3RoZXIgY2hhcmFjdGVycyBlc2NhcGVkIGJ5IGVzY2FwZUNoYXIKICAvLyB3aWxsIGJlIGluY2x1ZGVkIGFzIHVzdWFsIChpbmNsdWRpbmcgZXNjYXBlQ2hhciBpdHNlbGYpLgogIGZ1bmN0aW9uIHNwbGl0V2l0aEVzY2FwZSh2YWx1ZSwgc3BsaXRDaGFyLCBlc2NhcGVDaGFyKSB7CiAgICB2YXIgcmVzdWx0cyA9IFtdOwogICAgdmFyIGVzY2FwZU1vZGUgPSBmYWxzZTsKICAgIHZhciBjdXJyZW50UmVzdWx0ID0gIiI7CiAgICBmb3IgKHZhciBwb3MgPSAwOyBwb3MgPCB2YWx1ZS5sZW5ndGg7IHBvcysrKSB7CiAgICAgIGlmICghZXNjYXBlTW9kZSkgewogICAgICAgIGlmICh2YWx1ZVtwb3NdID09PSBzcGxpdENoYXIpIHsKICAgICAgICAgIHJlc3VsdHMucHVzaChjdXJyZW50UmVzdWx0KTsKICAgICAgICAgIGN1cnJlbnRSZXN1bHQgPSAiIjsKICAgICAgICB9IGVsc2UgaWYgKHZhbHVlW3Bvc10gPT09IGVzY2FwZUNoYXIpIHsKICAgICAgICAgIGVzY2FwZU1vZGUgPSB0cnVlOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBjdXJyZW50UmVzdWx0ICs9IHZhbHVlW3Bvc107CiAgICAgICAgfQogICAgICB9IGVsc2UgewogICAgICAgIGN1cnJlbnRSZXN1bHQgKz0gdmFsdWVbcG9zXTsKICAgICAgICBlc2NhcGVNb2RlID0gZmFsc2U7CiAgICAgIH0KICAgIH0KICAgIGlmIChjdXJyZW50UmVzdWx0ICE9PSAiIikgewogICAgICByZXN1bHRzLnB1c2goY3VycmVudFJlc3VsdCk7CiAgICB9CiAgICByZXR1cm4gcmVzdWx0czsKICB9CiAgLy8gRnVuY3Rpb24gYXV0aG9yZWQgYnkgWWlodWkvSkogQWxsYWlyZQogIHdpbmRvdy5IVE1MV2lkZ2V0cy5ldmFsdWF0ZVN0cmluZ01lbWJlciA9IGZ1bmN0aW9uKG8sIG1lbWJlcikgewogICAgdmFyIHBhcnRzID0gc3BsaXRXaXRoRXNjYXBlKG1lbWJlciwgJy4nLCAnXFwnKTsKICAgIGZvciAodmFyIGkgPSAwLCBsID0gcGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7CiAgICAgIHZhciBwYXJ0ID0gcGFydHNbaV07CiAgICAgIC8vIHBhcnQgbWF5IGJlIGEgY2hhcmFjdGVyIG9yICdudW1lcmljJyBtZW1iZXIgbmFtZQogICAgICBpZiAobyAhPT0gbnVsbCAmJiB0eXBlb2YgbyA9PT0gIm9iamVjdCIgJiYgcGFydCBpbiBvKSB7CiAgICAgICAgaWYgKGkgPT0gKGwgLSAxKSkgeyAvLyBpZiB3ZSBhcmUgYXQgdGhlIGVuZCBvZiB0aGUgbGluZSB0aGVuIGV2YWx1bGF0ZQogICAgICAgICAgaWYgKHR5cGVvZiBvW3BhcnRdID09PSAic3RyaW5nIikKICAgICAgICAgICAgb1twYXJ0XSA9IHRyeUV2YWwob1twYXJ0XSk7CiAgICAgICAgfSBlbHNlIHsgLy8gb3RoZXJ3aXNlIGNvbnRpbnVlIHRvIG5leHQgZW1iZWRkZWQgb2JqZWN0CiAgICAgICAgICBvID0gb1twYXJ0XTsKICAgICAgICB9CiAgICAgIH0KICAgIH0KICB9OwoKICAvLyBSZXRyaWV2ZSB0aGUgSFRNTFdpZGdldCBpbnN0YW5jZSAoaS5lLiB0aGUgcmV0dXJuIHZhbHVlIG9mIGFuCiAgLy8gSFRNTFdpZGdldCBiaW5kaW5nJ3MgaW5pdGlhbGl6ZSgpIG9yIGZhY3RvcnkoKSBmdW5jdGlvbikKICAvLyBhc3NvY2lhdGVkIHdpdGggYW4gZWxlbWVudCwgb3IgbnVsbCBpZiBub25lLgogIHdpbmRvdy5IVE1MV2lkZ2V0cy5nZXRJbnN0YW5jZSA9IGZ1bmN0aW9uKGVsKSB7CiAgICByZXR1cm4gZWxlbWVudERhdGEoZWwsICJpbml0X3Jlc3VsdCIpOwogIH07CgogIC8vIEZpbmRzIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBzY29wZSB0aGF0IG1hdGNoZXMgdGhlIHNlbGVjdG9yLAogIC8vIGFuZCByZXR1cm5zIHRoZSBIVE1MV2lkZ2V0IGluc3RhbmNlIChpLmUuIHRoZSByZXR1cm4gdmFsdWUgb2YKICAvLyBhbiBIVE1MV2lkZ2V0IGJpbmRpbmcncyBpbml0aWFsaXplKCkgb3IgZmFjdG9yeSgpIGZ1bmN0aW9uKQogIC8vIGFzc29jaWF0ZWQgd2l0aCB0aGF0IGVsZW1lbnQsIGlmIGFueS4gSWYgbm8gZWxlbWVudCBtYXRjaGVzIHRoZQogIC8vIHNlbGVjdG9yLCBvciB0aGUgZmlyc3QgbWF0Y2hpbmcgZWxlbWVudCBoYXMgbm8gSFRNTFdpZGdldAogIC8vIGluc3RhbmNlIGFzc29jaWF0ZWQgd2l0aCBpdCwgdGhlbiBudWxsIGlzIHJldHVybmVkLgogIC8vCiAgLy8gVGhlIHNjb3BlIGFyZ3VtZW50IGlzIG9wdGlvbmFsLCBhbmQgZGVmYXVsdHMgdG8gd2luZG93LmRvY3VtZW50LgogIHdpbmRvdy5IVE1MV2lkZ2V0cy5maW5kID0gZnVuY3Rpb24oc2NvcGUsIHNlbGVjdG9yKSB7CiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxKSB7CiAgICAgIHNlbGVjdG9yID0gc2NvcGU7CiAgICAgIHNjb3BlID0gZG9jdW1lbnQ7CiAgICB9CgogICAgdmFyIGVsID0gc2NvcGUucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7CiAgICBpZiAoZWwgPT09IG51bGwpIHsKICAgICAgcmV0dXJuIG51bGw7CiAgICB9IGVsc2UgewogICAgICByZXR1cm4gd2luZG93LkhUTUxXaWRnZXRzLmdldEluc3RhbmNlKGVsKTsKICAgIH0KICB9OwoKICAvLyBGaW5kcyBhbGwgZWxlbWVudHMgaW4gdGhlIHNjb3BlIHRoYXQgbWF0Y2ggdGhlIHNlbGVjdG9yLCBhbmQKICAvLyByZXR1cm5zIHRoZSBIVE1MV2lkZ2V0IGluc3RhbmNlcyAoaS5lLiB0aGUgcmV0dXJuIHZhbHVlcyBvZgogIC8vIGFuIEhUTUxXaWRnZXQgYmluZGluZydzIGluaXRpYWxpemUoKSBvciBmYWN0b3J5KCkgZnVuY3Rpb24pCiAgLy8gYXNzb2NpYXRlZCB3aXRoIHRoZSBlbGVtZW50cywgaW4gYW4gYXJyYXkuIElmIGVsZW1lbnRzIHRoYXQKICAvLyBtYXRjaCB0aGUgc2VsZWN0b3IgZG9uJ3QgaGF2ZSBhbiBhc3NvY2lhdGVkIEhUTUxXaWRnZXQKICAvLyBpbnN0YW5jZSwgdGhlIHJldHVybmVkIGFycmF5IHdpbGwgY29udGFpbiBudWxscy4KICAvLwogIC8vIFRoZSBzY29wZSBhcmd1bWVudCBpcyBvcHRpb25hbCwgYW5kIGRlZmF1bHRzIHRvIHdpbmRvdy5kb2N1bWVudC4KICB3aW5kb3cuSFRNTFdpZGdldHMuZmluZEFsbCA9IGZ1bmN0aW9uKHNjb3BlLCBzZWxlY3RvcikgewogICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMSkgewogICAgICBzZWxlY3RvciA9IHNjb3BlOwogICAgICBzY29wZSA9IGRvY3VtZW50OwogICAgfQoKICAgIHZhciBub2RlcyA9IHNjb3BlLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpOwogICAgdmFyIHJlc3VsdHMgPSBbXTsKICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHsKICAgICAgcmVzdWx0cy5wdXNoKHdpbmRvdy5IVE1MV2lkZ2V0cy5nZXRJbnN0YW5jZShub2Rlc1tpXSkpOwogICAgfQogICAgcmV0dXJuIHJlc3VsdHM7CiAgfTsKCiAgdmFyIHBvc3RSZW5kZXJIYW5kbGVycyA9IFtdOwogIGZ1bmN0aW9uIGludm9rZVBvc3RSZW5kZXJIYW5kbGVycygpIHsKICAgIHdoaWxlIChwb3N0UmVuZGVySGFuZGxlcnMubGVuZ3RoKSB7CiAgICAgIHZhciBoYW5kbGVyID0gcG9zdFJlbmRlckhhbmRsZXJzLnNoaWZ0KCk7CiAgICAgIGlmIChoYW5kbGVyKSB7CiAgICAgICAgaGFuZGxlcigpOwogICAgICB9CiAgICB9CiAgfQoKICAvLyBSZWdpc3RlciB0aGUgZ2l2ZW4gY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgaW52b2tlZCBhZnRlciB0aGUKICAvLyBuZXh0IHRpbWUgc3RhdGljIHdpZGdldHMgYXJlIHJlbmRlcmVkLgogIHdpbmRvdy5IVE1MV2lkZ2V0cy5hZGRQb3N0UmVuZGVySGFuZGxlciA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7CiAgICBwb3N0UmVuZGVySGFuZGxlcnMucHVzaChjYWxsYmFjayk7CiAgfTsKCiAgLy8gVGFrZXMgYSBuZXctc3R5bGUgaW5zdGFuY2UtYm91bmQgZGVmaW5pdGlvbiwgYW5kIHJldHVybnMgYW4KICAvLyBvbGQtc3R5bGUgY2xhc3MtYm91bmQgZGVmaW5pdGlvbi4gVGhpcyBzYXZlcyB1cyBmcm9tIGhhdmluZwogIC8vIHRvIHJld3JpdGUgYWxsIHRoZSBsb2dpYyBpbiB0aGlzIGZpbGUgdG8gYWNjb21vZGF0ZSBib3RoCiAgLy8gdHlwZXMgb2YgZGVmaW5pdGlvbnMuCiAgZnVuY3Rpb24gY3JlYXRlTGVnYWN5RGVmaW5pdGlvbkFkYXB0ZXIoZGVmbikgewogICAgdmFyIHJlc3VsdCA9IHsKICAgICAgbmFtZTogZGVmbi5uYW1lLAogICAgICB0eXBlOiBkZWZuLnR5cGUsCiAgICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKGVsLCB3aWR0aCwgaGVpZ2h0KSB7CiAgICAgICAgcmV0dXJuIGRlZm4uZmFjdG9yeShlbCwgd2lkdGgsIGhlaWdodCk7CiAgICAgIH0sCiAgICAgIHJlbmRlclZhbHVlOiBmdW5jdGlvbihlbCwgeCwgaW5zdGFuY2UpIHsKICAgICAgICByZXR1cm4gaW5zdGFuY2UucmVuZGVyVmFsdWUoeCk7CiAgICAgIH0sCiAgICAgIHJlc2l6ZTogZnVuY3Rpb24oZWwsIHdpZHRoLCBoZWlnaHQsIGluc3RhbmNlKSB7CiAgICAgICAgcmV0dXJuIGluc3RhbmNlLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTsKICAgICAgfQogICAgfTsKCiAgICBpZiAoZGVmbi5maW5kKQogICAgICByZXN1bHQuZmluZCA9IGRlZm4uZmluZDsKICAgIGlmIChkZWZuLnJlbmRlckVycm9yKQogICAgICByZXN1bHQucmVuZGVyRXJyb3IgPSBkZWZuLnJlbmRlckVycm9yOwogICAgaWYgKGRlZm4uY2xlYXJFcnJvcikKICAgICAgcmVzdWx0LmNsZWFyRXJyb3IgPSBkZWZuLmNsZWFyRXJyb3I7CgogICAgcmV0dXJuIHJlc3VsdDsKICB9Cn0pKCk7Cgo="></script>
<script src="data:application/x-javascript;base64,LyohIGpRdWVyeSB2MS4xMS4xIHwgKGMpIDIwMDUsIDIwMTQgalF1ZXJ5IEZvdW5kYXRpb24sIEluYy4gfCBqcXVlcnkub3JnL2xpY2Vuc2UgKi8KIWZ1bmN0aW9uKGEsYil7Im9iamVjdCI9PXR5cGVvZiBtb2R1bGUmJiJvYmplY3QiPT10eXBlb2YgbW9kdWxlLmV4cG9ydHM/bW9kdWxlLmV4cG9ydHM9YS5kb2N1bWVudD9iKGEsITApOmZ1bmN0aW9uKGEpe2lmKCFhLmRvY3VtZW50KXRocm93IG5ldyBFcnJvcigialF1ZXJ5IHJlcXVpcmVzIGEgd2luZG93IHdpdGggYSBkb2N1bWVudCIpO3JldHVybiBiKGEpfTpiKGEpfSgidW5kZWZpbmVkIiE9dHlwZW9mIHdpbmRvdz93aW5kb3c6dGhpcyxmdW5jdGlvbihhLGIpe3ZhciBjPVtdLGQ9Yy5zbGljZSxlPWMuY29uY2F0LGY9Yy5wdXNoLGc9Yy5pbmRleE9mLGg9e30saT1oLnRvU3RyaW5nLGo9aC5oYXNPd25Qcm9wZXJ0eSxrPXt9LGw9IjEuMTEuMSIsbT1mdW5jdGlvbihhLGIpe3JldHVybiBuZXcgbS5mbi5pbml0KGEsYil9LG49L15bXHNcdUZFRkZceEEwXSt8W1xzXHVGRUZGXHhBMF0rJC9nLG89L14tbXMtLyxwPS8tKFtcZGEtel0pL2dpLHE9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYi50b1VwcGVyQ2FzZSgpfTttLmZuPW0ucHJvdG90eXBlPXtqcXVlcnk6bCxjb25zdHJ1Y3RvcjptLHNlbGVjdG9yOiIiLGxlbmd0aDowLHRvQXJyYXk6ZnVuY3Rpb24oKXtyZXR1cm4gZC5jYWxsKHRoaXMpfSxnZXQ6ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGwhPWE/MD5hP3RoaXNbYSt0aGlzLmxlbmd0aF06dGhpc1thXTpkLmNhbGwodGhpcyl9LHB1c2hTdGFjazpmdW5jdGlvbihhKXt2YXIgYj1tLm1lcmdlKHRoaXMuY29uc3RydWN0b3IoKSxhKTtyZXR1cm4gYi5wcmV2T2JqZWN0PXRoaXMsYi5jb250ZXh0PXRoaXMuY29udGV4dCxifSxlYWNoOmZ1bmN0aW9uKGEsYil7cmV0dXJuIG0uZWFjaCh0aGlzLGEsYil9LG1hcDpmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5wdXNoU3RhY2sobS5tYXAodGhpcyxmdW5jdGlvbihiLGMpe3JldHVybiBhLmNhbGwoYixjLGIpfSkpfSxzbGljZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnB1c2hTdGFjayhkLmFwcGx5KHRoaXMsYXJndW1lbnRzKSl9LGZpcnN0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZXEoMCl9LGxhc3Q6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lcSgtMSl9LGVxOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMubGVuZ3RoLGM9K2ErKDA+YT9iOjApO3JldHVybiB0aGlzLnB1c2hTdGFjayhjPj0wJiZiPmM/W3RoaXNbY11dOltdKX0sZW5kOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucHJldk9iamVjdHx8dGhpcy5jb25zdHJ1Y3RvcihudWxsKX0scHVzaDpmLHNvcnQ6Yy5zb3J0LHNwbGljZTpjLnNwbGljZX0sbS5leHRlbmQ9bS5mbi5leHRlbmQ9ZnVuY3Rpb24oKXt2YXIgYSxiLGMsZCxlLGYsZz1hcmd1bWVudHNbMF18fHt9LGg9MSxpPWFyZ3VtZW50cy5sZW5ndGgsaj0hMTtmb3IoImJvb2xlYW4iPT10eXBlb2YgZyYmKGo9ZyxnPWFyZ3VtZW50c1toXXx8e30saCsrKSwib2JqZWN0Ij09dHlwZW9mIGd8fG0uaXNGdW5jdGlvbihnKXx8KGc9e30pLGg9PT1pJiYoZz10aGlzLGgtLSk7aT5oO2grKylpZihudWxsIT0oZT1hcmd1bWVudHNbaF0pKWZvcihkIGluIGUpYT1nW2RdLGM9ZVtkXSxnIT09YyYmKGomJmMmJihtLmlzUGxhaW5PYmplY3QoYyl8fChiPW0uaXNBcnJheShjKSkpPyhiPyhiPSExLGY9YSYmbS5pc0FycmF5KGEpP2E6W10pOmY9YSYmbS5pc1BsYWluT2JqZWN0KGEpP2E6e30sZ1tkXT1tLmV4dGVuZChqLGYsYykpOnZvaWQgMCE9PWMmJihnW2RdPWMpKTtyZXR1cm4gZ30sbS5leHRlbmQoe2V4cGFuZG86ImpRdWVyeSIrKGwrTWF0aC5yYW5kb20oKSkucmVwbGFjZSgvXEQvZywiIiksaXNSZWFkeTohMCxlcnJvcjpmdW5jdGlvbihhKXt0aHJvdyBuZXcgRXJyb3IoYSl9LG5vb3A6ZnVuY3Rpb24oKXt9LGlzRnVuY3Rpb246ZnVuY3Rpb24oYSl7cmV0dXJuImZ1bmN0aW9uIj09PW0udHlwZShhKX0saXNBcnJheTpBcnJheS5pc0FycmF5fHxmdW5jdGlvbihhKXtyZXR1cm4iYXJyYXkiPT09bS50eXBlKGEpfSxpc1dpbmRvdzpmdW5jdGlvbihhKXtyZXR1cm4gbnVsbCE9YSYmYT09YS53aW5kb3d9LGlzTnVtZXJpYzpmdW5jdGlvbihhKXtyZXR1cm4hbS5pc0FycmF5KGEpJiZhLXBhcnNlRmxvYXQoYSk+PTB9LGlzRW1wdHlPYmplY3Q6ZnVuY3Rpb24oYSl7dmFyIGI7Zm9yKGIgaW4gYSlyZXR1cm4hMTtyZXR1cm4hMH0saXNQbGFpbk9iamVjdDpmdW5jdGlvbihhKXt2YXIgYjtpZighYXx8Im9iamVjdCIhPT1tLnR5cGUoYSl8fGEubm9kZVR5cGV8fG0uaXNXaW5kb3coYSkpcmV0dXJuITE7dHJ5e2lmKGEuY29uc3RydWN0b3ImJiFqLmNhbGwoYSwiY29uc3RydWN0b3IiKSYmIWouY2FsbChhLmNvbnN0cnVjdG9yLnByb3RvdHlwZSwiaXNQcm90b3R5cGVPZiIpKXJldHVybiExfWNhdGNoKGMpe3JldHVybiExfWlmKGsub3duTGFzdClmb3IoYiBpbiBhKXJldHVybiBqLmNhbGwoYSxiKTtmb3IoYiBpbiBhKTtyZXR1cm4gdm9pZCAwPT09Ynx8ai5jYWxsKGEsYil9LHR5cGU6ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGw9PWE/YSsiIjoib2JqZWN0Ij09dHlwZW9mIGF8fCJmdW5jdGlvbiI9PXR5cGVvZiBhP2hbaS5jYWxsKGEpXXx8Im9iamVjdCI6dHlwZW9mIGF9LGdsb2JhbEV2YWw6ZnVuY3Rpb24oYil7YiYmbS50cmltKGIpJiYoYS5leGVjU2NyaXB0fHxmdW5jdGlvbihiKXthLmV2YWwuY2FsbChhLGIpfSkoYil9LGNhbWVsQ2FzZTpmdW5jdGlvbihhKXtyZXR1cm4gYS5yZXBsYWNlKG8sIm1zLSIpLnJlcGxhY2UocCxxKX0sbm9kZU5hbWU6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYS5ub2RlTmFtZSYmYS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpPT09Yi50b0xvd2VyQ2FzZSgpfSxlYWNoOmZ1bmN0aW9uKGEsYixjKXt2YXIgZCxlPTAsZj1hLmxlbmd0aCxnPXIoYSk7aWYoYyl7aWYoZyl7Zm9yKDtmPmU7ZSsrKWlmKGQ9Yi5hcHBseShhW2VdLGMpLGQ9PT0hMSlicmVha31lbHNlIGZvcihlIGluIGEpaWYoZD1iLmFwcGx5KGFbZV0sYyksZD09PSExKWJyZWFrfWVsc2UgaWYoZyl7Zm9yKDtmPmU7ZSsrKWlmKGQ9Yi5jYWxsKGFbZV0sZSxhW2VdKSxkPT09ITEpYnJlYWt9ZWxzZSBmb3IoZSBpbiBhKWlmKGQ9Yi5jYWxsKGFbZV0sZSxhW2VdKSxkPT09ITEpYnJlYWs7cmV0dXJuIGF9LHRyaW06ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGw9PWE/IiI6KGErIiIpLnJlcGxhY2UobiwiIil9LG1ha2VBcnJheTpmdW5jdGlvbihhLGIpe3ZhciBjPWJ8fFtdO3JldHVybiBudWxsIT1hJiYocihPYmplY3QoYSkpP20ubWVyZ2UoYywic3RyaW5nIj09dHlwZW9mIGE/W2FdOmEpOmYuY2FsbChjLGEpKSxjfSxpbkFycmF5OmZ1bmN0aW9uKGEsYixjKXt2YXIgZDtpZihiKXtpZihnKXJldHVybiBnLmNhbGwoYixhLGMpO2ZvcihkPWIubGVuZ3RoLGM9Yz8wPmM/TWF0aC5tYXgoMCxkK2MpOmM6MDtkPmM7YysrKWlmKGMgaW4gYiYmYltjXT09PWEpcmV0dXJuIGN9cmV0dXJuLTF9LG1lcmdlOmZ1bmN0aW9uKGEsYil7dmFyIGM9K2IubGVuZ3RoLGQ9MCxlPWEubGVuZ3RoO3doaWxlKGM+ZClhW2UrK109YltkKytdO2lmKGMhPT1jKXdoaWxlKHZvaWQgMCE9PWJbZF0pYVtlKytdPWJbZCsrXTtyZXR1cm4gYS5sZW5ndGg9ZSxhfSxncmVwOmZ1bmN0aW9uKGEsYixjKXtmb3IodmFyIGQsZT1bXSxmPTAsZz1hLmxlbmd0aCxoPSFjO2c+ZjtmKyspZD0hYihhW2ZdLGYpLGQhPT1oJiZlLnB1c2goYVtmXSk7cmV0dXJuIGV9LG1hcDpmdW5jdGlvbihhLGIsYyl7dmFyIGQsZj0wLGc9YS5sZW5ndGgsaD1yKGEpLGk9W107aWYoaClmb3IoO2c+ZjtmKyspZD1iKGFbZl0sZixjKSxudWxsIT1kJiZpLnB1c2goZCk7ZWxzZSBmb3IoZiBpbiBhKWQ9YihhW2ZdLGYsYyksbnVsbCE9ZCYmaS5wdXNoKGQpO3JldHVybiBlLmFwcGx5KFtdLGkpfSxndWlkOjEscHJveHk6ZnVuY3Rpb24oYSxiKXt2YXIgYyxlLGY7cmV0dXJuInN0cmluZyI9PXR5cGVvZiBiJiYoZj1hW2JdLGI9YSxhPWYpLG0uaXNGdW5jdGlvbihhKT8oYz1kLmNhbGwoYXJndW1lbnRzLDIpLGU9ZnVuY3Rpb24oKXtyZXR1cm4gYS5hcHBseShifHx0aGlzLGMuY29uY2F0KGQuY2FsbChhcmd1bWVudHMpKSl9LGUuZ3VpZD1hLmd1aWQ9YS5ndWlkfHxtLmd1aWQrKyxlKTp2b2lkIDB9LG5vdzpmdW5jdGlvbigpe3JldHVybituZXcgRGF0ZX0sc3VwcG9ydDprfSksbS5lYWNoKCJCb29sZWFuIE51bWJlciBTdHJpbmcgRnVuY3Rpb24gQXJyYXkgRGF0ZSBSZWdFeHAgT2JqZWN0IEVycm9yIi5zcGxpdCgiICIpLGZ1bmN0aW9uKGEsYil7aFsiW29iamVjdCAiK2IrIl0iXT1iLnRvTG93ZXJDYXNlKCl9KTtmdW5jdGlvbiByKGEpe3ZhciBiPWEubGVuZ3RoLGM9bS50eXBlKGEpO3JldHVybiJmdW5jdGlvbiI9PT1jfHxtLmlzV2luZG93KGEpPyExOjE9PT1hLm5vZGVUeXBlJiZiPyEwOiJhcnJheSI9PT1jfHwwPT09Ynx8Im51bWJlciI9PXR5cGVvZiBiJiZiPjAmJmItMSBpbiBhfXZhciBzPWZ1bmN0aW9uKGEpe3ZhciBiLGMsZCxlLGYsZyxoLGksaixrLGwsbSxuLG8scCxxLHIscyx0LHU9InNpenpsZSIrLW5ldyBEYXRlLHY9YS5kb2N1bWVudCx3PTAseD0wLHk9Z2IoKSx6PWdiKCksQT1nYigpLEI9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYT09PWImJihsPSEwKSwwfSxDPSJ1bmRlZmluZWQiLEQ9MTw8MzEsRT17fS5oYXNPd25Qcm9wZXJ0eSxGPVtdLEc9Ri5wb3AsSD1GLnB1c2gsST1GLnB1c2gsSj1GLnNsaWNlLEs9Ri5pbmRleE9mfHxmdW5jdGlvbihhKXtmb3IodmFyIGI9MCxjPXRoaXMubGVuZ3RoO2M+YjtiKyspaWYodGhpc1tiXT09PWEpcmV0dXJuIGI7cmV0dXJuLTF9LEw9ImNoZWNrZWR8c2VsZWN0ZWR8YXN5bmN8YXV0b2ZvY3VzfGF1dG9wbGF5fGNvbnRyb2xzfGRlZmVyfGRpc2FibGVkfGhpZGRlbnxpc21hcHxsb29wfG11bHRpcGxlfG9wZW58cmVhZG9ubHl8cmVxdWlyZWR8c2NvcGVkIixNPSJbXFx4MjBcXHRcXHJcXG5cXGZdIixOPSIoPzpcXFxcLnxbXFx3LV18W15cXHgwMC1cXHhhMF0pKyIsTz1OLnJlcGxhY2UoInciLCJ3IyIpLFA9IlxcWyIrTSsiKigiK04rIikoPzoiK00rIiooWypeJHwhfl0/PSkiK00rIiooPzonKCg/OlxcXFwufFteXFxcXCddKSopJ3xcIigoPzpcXFxcLnxbXlxcXFxcIl0pKilcInwoIitPKyIpKXwpIitNKyIqXFxdIixRPSI6KCIrTisiKSg/OlxcKCgoJygoPzpcXFxcLnxbXlxcXFwnXSkqKSd8XCIoKD86XFxcXC58W15cXFxcXCJdKSopXCIpfCgoPzpcXFxcLnxbXlxcXFwoKVtcXF1dfCIrUCsiKSopfC4qKVxcKXwpIixSPW5ldyBSZWdFeHAoIl4iK00rIit8KCg/Ol58W15cXFxcXSkoPzpcXFxcLikqKSIrTSsiKyQiLCJnIiksUz1uZXcgUmVnRXhwKCJeIitNKyIqLCIrTSsiKiIpLFQ9bmV3IFJlZ0V4cCgiXiIrTSsiKihbPit+XXwiK00rIikiK00rIioiKSxVPW5ldyBSZWdFeHAoIj0iK00rIiooW15cXF0nXCJdKj8pIitNKyIqXFxdIiwiZyIpLFY9bmV3IFJlZ0V4cChRKSxXPW5ldyBSZWdFeHAoIl4iK08rIiQiKSxYPXtJRDpuZXcgUmVnRXhwKCJeIygiK04rIikiKSxDTEFTUzpuZXcgUmVnRXhwKCJeXFwuKCIrTisiKSIpLFRBRzpuZXcgUmVnRXhwKCJeKCIrTi5yZXBsYWNlKCJ3IiwidyoiKSsiKSIpLEFUVFI6bmV3IFJlZ0V4cCgiXiIrUCksUFNFVURPOm5ldyBSZWdFeHAoIl4iK1EpLENISUxEOm5ldyBSZWdFeHAoIl46KG9ubHl8Zmlyc3R8bGFzdHxudGh8bnRoLWxhc3QpLShjaGlsZHxvZi10eXBlKSg/OlxcKCIrTSsiKihldmVufG9kZHwoKFsrLV18KShcXGQqKW58KSIrTSsiKig/OihbKy1dfCkiK00rIiooXFxkKyl8KSkiK00rIipcXCl8KSIsImkiKSxib29sOm5ldyBSZWdFeHAoIl4oPzoiK0wrIikkIiwiaSIpLG5lZWRzQ29udGV4dDpuZXcgUmVnRXhwKCJeIitNKyIqWz4rfl18OihldmVufG9kZHxlcXxndHxsdHxudGh8Zmlyc3R8bGFzdCkoPzpcXCgiK00rIiooKD86LVxcZCk/XFxkKikiK00rIipcXCl8KSg/PVteLV18JCkiLCJpIil9LFk9L14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxaPS9eaFxkJC9pLCQ9L15bXntdK1x7XHMqXFtuYXRpdmUgXHcvLF89L14oPzojKFtcdy1dKyl8KFx3Kyl8XC4oW1x3LV0rKSkkLyxhYj0vWyt+XS8sYmI9Lyd8XFwvZyxjYj1uZXcgUmVnRXhwKCJcXFxcKFtcXGRhLWZdezEsNn0iK00rIj98KCIrTSsiKXwuKSIsImlnIiksZGI9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPSIweCIrYi02NTUzNjtyZXR1cm4gZCE9PWR8fGM/YjowPmQ/U3RyaW5nLmZyb21DaGFyQ29kZShkKzY1NTM2KTpTdHJpbmcuZnJvbUNoYXJDb2RlKGQ+PjEwfDU1Mjk2LDEwMjMmZHw1NjMyMCl9O3RyeXtJLmFwcGx5KEY9Si5jYWxsKHYuY2hpbGROb2Rlcyksdi5jaGlsZE5vZGVzKSxGW3YuY2hpbGROb2Rlcy5sZW5ndGhdLm5vZGVUeXBlfWNhdGNoKGViKXtJPXthcHBseTpGLmxlbmd0aD9mdW5jdGlvbihhLGIpe0guYXBwbHkoYSxKLmNhbGwoYikpfTpmdW5jdGlvbihhLGIpe3ZhciBjPWEubGVuZ3RoLGQ9MDt3aGlsZShhW2MrK109YltkKytdKTthLmxlbmd0aD1jLTF9fX1mdW5jdGlvbiBmYihhLGIsZCxlKXt2YXIgZixoLGosayxsLG8scixzLHcseDtpZigoYj9iLm93bmVyRG9jdW1lbnR8fGI6dikhPT1uJiZtKGIpLGI9Ynx8bixkPWR8fFtdLCFhfHwic3RyaW5nIiE9dHlwZW9mIGEpcmV0dXJuIGQ7aWYoMSE9PShrPWIubm9kZVR5cGUpJiY5IT09aylyZXR1cm5bXTtpZihwJiYhZSl7aWYoZj1fLmV4ZWMoYSkpaWYoaj1mWzFdKXtpZig5PT09ayl7aWYoaD1iLmdldEVsZW1lbnRCeUlkKGopLCFofHwhaC5wYXJlbnROb2RlKXJldHVybiBkO2lmKGguaWQ9PT1qKXJldHVybiBkLnB1c2goaCksZH1lbHNlIGlmKGIub3duZXJEb2N1bWVudCYmKGg9Yi5vd25lckRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGopKSYmdChiLGgpJiZoLmlkPT09ailyZXR1cm4gZC5wdXNoKGgpLGR9ZWxzZXtpZihmWzJdKXJldHVybiBJLmFwcGx5KGQsYi5nZXRFbGVtZW50c0J5VGFnTmFtZShhKSksZDtpZigoaj1mWzNdKSYmYy5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lJiZiLmdldEVsZW1lbnRzQnlDbGFzc05hbWUpcmV0dXJuIEkuYXBwbHkoZCxiLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoaikpLGR9aWYoYy5xc2EmJighcXx8IXEudGVzdChhKSkpe2lmKHM9cj11LHc9Yix4PTk9PT1rJiZhLDE9PT1rJiYib2JqZWN0IiE9PWIubm9kZU5hbWUudG9Mb3dlckNhc2UoKSl7bz1nKGEpLChyPWIuZ2V0QXR0cmlidXRlKCJpZCIpKT9zPXIucmVwbGFjZShiYiwiXFwkJiIpOmIuc2V0QXR0cmlidXRlKCJpZCIscykscz0iW2lkPSciK3MrIiddICIsbD1vLmxlbmd0aDt3aGlsZShsLS0pb1tsXT1zK3FiKG9bbF0pO3c9YWIudGVzdChhKSYmb2IoYi5wYXJlbnROb2RlKXx8Yix4PW8uam9pbigiLCIpfWlmKHgpdHJ5e3JldHVybiBJLmFwcGx5KGQsdy5xdWVyeVNlbGVjdG9yQWxsKHgpKSxkfWNhdGNoKHkpe31maW5hbGx5e3J8fGIucmVtb3ZlQXR0cmlidXRlKCJpZCIpfX19cmV0dXJuIGkoYS5yZXBsYWNlKFIsIiQxIiksYixkLGUpfWZ1bmN0aW9uIGdiKCl7dmFyIGE9W107ZnVuY3Rpb24gYihjLGUpe3JldHVybiBhLnB1c2goYysiICIpPmQuY2FjaGVMZW5ndGgmJmRlbGV0ZSBiW2Euc2hpZnQoKV0sYltjKyIgIl09ZX1yZXR1cm4gYn1mdW5jdGlvbiBoYihhKXtyZXR1cm4gYVt1XT0hMCxhfWZ1bmN0aW9uIGliKGEpe3ZhciBiPW4uY3JlYXRlRWxlbWVudCgiZGl2Iik7dHJ5e3JldHVybiEhYShiKX1jYXRjaChjKXtyZXR1cm4hMX1maW5hbGx5e2IucGFyZW50Tm9kZSYmYi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGIpLGI9bnVsbH19ZnVuY3Rpb24gamIoYSxiKXt2YXIgYz1hLnNwbGl0KCJ8IiksZT1hLmxlbmd0aDt3aGlsZShlLS0pZC5hdHRySGFuZGxlW2NbZV1dPWJ9ZnVuY3Rpb24ga2IoYSxiKXt2YXIgYz1iJiZhLGQ9YyYmMT09PWEubm9kZVR5cGUmJjE9PT1iLm5vZGVUeXBlJiYofmIuc291cmNlSW5kZXh8fEQpLSh+YS5zb3VyY2VJbmRleHx8RCk7aWYoZClyZXR1cm4gZDtpZihjKXdoaWxlKGM9Yy5uZXh0U2libGluZylpZihjPT09YilyZXR1cm4tMTtyZXR1cm4gYT8xOi0xfWZ1bmN0aW9uIGxiKGEpe3JldHVybiBmdW5jdGlvbihiKXt2YXIgYz1iLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7cmV0dXJuImlucHV0Ij09PWMmJmIudHlwZT09PWF9fWZ1bmN0aW9uIG1iKGEpe3JldHVybiBmdW5jdGlvbihiKXt2YXIgYz1iLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7cmV0dXJuKCJpbnB1dCI9PT1jfHwiYnV0dG9uIj09PWMpJiZiLnR5cGU9PT1hfX1mdW5jdGlvbiBuYihhKXtyZXR1cm4gaGIoZnVuY3Rpb24oYil7cmV0dXJuIGI9K2IsaGIoZnVuY3Rpb24oYyxkKXt2YXIgZSxmPWEoW10sYy5sZW5ndGgsYiksZz1mLmxlbmd0aDt3aGlsZShnLS0pY1tlPWZbZ11dJiYoY1tlXT0hKGRbZV09Y1tlXSkpfSl9KX1mdW5jdGlvbiBvYihhKXtyZXR1cm4gYSYmdHlwZW9mIGEuZ2V0RWxlbWVudHNCeVRhZ05hbWUhPT1DJiZhfWM9ZmIuc3VwcG9ydD17fSxmPWZiLmlzWE1MPWZ1bmN0aW9uKGEpe3ZhciBiPWEmJihhLm93bmVyRG9jdW1lbnR8fGEpLmRvY3VtZW50RWxlbWVudDtyZXR1cm4gYj8iSFRNTCIhPT1iLm5vZGVOYW1lOiExfSxtPWZiLnNldERvY3VtZW50PWZ1bmN0aW9uKGEpe3ZhciBiLGU9YT9hLm93bmVyRG9jdW1lbnR8fGE6dixnPWUuZGVmYXVsdFZpZXc7cmV0dXJuIGUhPT1uJiY5PT09ZS5ub2RlVHlwZSYmZS5kb2N1bWVudEVsZW1lbnQ/KG49ZSxvPWUuZG9jdW1lbnRFbGVtZW50LHA9IWYoZSksZyYmZyE9PWcudG9wJiYoZy5hZGRFdmVudExpc3RlbmVyP2cuYWRkRXZlbnRMaXN0ZW5lcigidW5sb2FkIixmdW5jdGlvbigpe20oKX0sITEpOmcuYXR0YWNoRXZlbnQmJmcuYXR0YWNoRXZlbnQoIm9udW5sb2FkIixmdW5jdGlvbigpe20oKX0pKSxjLmF0dHJpYnV0ZXM9aWIoZnVuY3Rpb24oYSl7cmV0dXJuIGEuY2xhc3NOYW1lPSJpIiwhYS5nZXRBdHRyaWJ1dGUoImNsYXNzTmFtZSIpfSksYy5nZXRFbGVtZW50c0J5VGFnTmFtZT1pYihmdW5jdGlvbihhKXtyZXR1cm4gYS5hcHBlbmRDaGlsZChlLmNyZWF0ZUNvbW1lbnQoIiIpKSwhYS5nZXRFbGVtZW50c0J5VGFnTmFtZSgiKiIpLmxlbmd0aH0pLGMuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZT0kLnRlc3QoZS5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKSYmaWIoZnVuY3Rpb24oYSl7cmV0dXJuIGEuaW5uZXJIVE1MPSI8ZGl2IGNsYXNzPSdhJz48L2Rpdj48ZGl2IGNsYXNzPSdhIGknPjwvZGl2PiIsYS5maXJzdENoaWxkLmNsYXNzTmFtZT0iaSIsMj09PWEuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgiaSIpLmxlbmd0aH0pLGMuZ2V0QnlJZD1pYihmdW5jdGlvbihhKXtyZXR1cm4gby5hcHBlbmRDaGlsZChhKS5pZD11LCFlLmdldEVsZW1lbnRzQnlOYW1lfHwhZS5nZXRFbGVtZW50c0J5TmFtZSh1KS5sZW5ndGh9KSxjLmdldEJ5SWQ/KGQuZmluZC5JRD1mdW5jdGlvbihhLGIpe2lmKHR5cGVvZiBiLmdldEVsZW1lbnRCeUlkIT09QyYmcCl7dmFyIGM9Yi5nZXRFbGVtZW50QnlJZChhKTtyZXR1cm4gYyYmYy5wYXJlbnROb2RlP1tjXTpbXX19LGQuZmlsdGVyLklEPWZ1bmN0aW9uKGEpe3ZhciBiPWEucmVwbGFjZShjYixkYik7cmV0dXJuIGZ1bmN0aW9uKGEpe3JldHVybiBhLmdldEF0dHJpYnV0ZSgiaWQiKT09PWJ9fSk6KGRlbGV0ZSBkLmZpbmQuSUQsZC5maWx0ZXIuSUQ9ZnVuY3Rpb24oYSl7dmFyIGI9YS5yZXBsYWNlKGNiLGRiKTtyZXR1cm4gZnVuY3Rpb24oYSl7dmFyIGM9dHlwZW9mIGEuZ2V0QXR0cmlidXRlTm9kZSE9PUMmJmEuZ2V0QXR0cmlidXRlTm9kZSgiaWQiKTtyZXR1cm4gYyYmYy52YWx1ZT09PWJ9fSksZC5maW5kLlRBRz1jLmdldEVsZW1lbnRzQnlUYWdOYW1lP2Z1bmN0aW9uKGEsYil7cmV0dXJuIHR5cGVvZiBiLmdldEVsZW1lbnRzQnlUYWdOYW1lIT09Qz9iLmdldEVsZW1lbnRzQnlUYWdOYW1lKGEpOnZvaWQgMH06ZnVuY3Rpb24oYSxiKXt2YXIgYyxkPVtdLGU9MCxmPWIuZ2V0RWxlbWVudHNCeVRhZ05hbWUoYSk7aWYoIioiPT09YSl7d2hpbGUoYz1mW2UrK10pMT09PWMubm9kZVR5cGUmJmQucHVzaChjKTtyZXR1cm4gZH1yZXR1cm4gZn0sZC5maW5kLkNMQVNTPWMuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSYmZnVuY3Rpb24oYSxiKXtyZXR1cm4gdHlwZW9mIGIuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSE9PUMmJnA/Yi5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGEpOnZvaWQgMH0scj1bXSxxPVtdLChjLnFzYT0kLnRlc3QoZS5xdWVyeVNlbGVjdG9yQWxsKSkmJihpYihmdW5jdGlvbihhKXthLmlubmVySFRNTD0iPHNlbGVjdCBtc2FsbG93Y2xpcD0nJz48b3B0aW9uIHNlbGVjdGVkPScnPjwvb3B0aW9uPjwvc2VsZWN0PiIsYS5xdWVyeVNlbGVjdG9yQWxsKCJbbXNhbGxvd2NsaXBePScnXSIpLmxlbmd0aCYmcS5wdXNoKCJbKl4kXT0iK00rIiooPzonJ3xcIlwiKSIpLGEucXVlcnlTZWxlY3RvckFsbCgiW3NlbGVjdGVkXSIpLmxlbmd0aHx8cS5wdXNoKCJcXFsiK00rIiooPzp2YWx1ZXwiK0wrIikiKSxhLnF1ZXJ5U2VsZWN0b3JBbGwoIjpjaGVja2VkIikubGVuZ3RofHxxLnB1c2goIjpjaGVja2VkIil9KSxpYihmdW5jdGlvbihhKXt2YXIgYj1lLmNyZWF0ZUVsZW1lbnQoImlucHV0Iik7Yi5zZXRBdHRyaWJ1dGUoInR5cGUiLCJoaWRkZW4iKSxhLmFwcGVuZENoaWxkKGIpLnNldEF0dHJpYnV0ZSgibmFtZSIsIkQiKSxhLnF1ZXJ5U2VsZWN0b3JBbGwoIltuYW1lPWRdIikubGVuZ3RoJiZxLnB1c2goIm5hbWUiK00rIipbKl4kfCF+XT89IiksYS5xdWVyeVNlbGVjdG9yQWxsKCI6ZW5hYmxlZCIpLmxlbmd0aHx8cS5wdXNoKCI6ZW5hYmxlZCIsIjpkaXNhYmxlZCIpLGEucXVlcnlTZWxlY3RvckFsbCgiKiw6eCIpLHEucHVzaCgiLC4qOiIpfSkpLChjLm1hdGNoZXNTZWxlY3Rvcj0kLnRlc3Qocz1vLm1hdGNoZXN8fG8ud2Via2l0TWF0Y2hlc1NlbGVjdG9yfHxvLm1vek1hdGNoZXNTZWxlY3Rvcnx8by5vTWF0Y2hlc1NlbGVjdG9yfHxvLm1zTWF0Y2hlc1NlbGVjdG9yKSkmJmliKGZ1bmN0aW9uKGEpe2MuZGlzY29ubmVjdGVkTWF0Y2g9cy5jYWxsKGEsImRpdiIpLHMuY2FsbChhLCJbcyE9JyddOngiKSxyLnB1c2goIiE9IixRKX0pLHE9cS5sZW5ndGgmJm5ldyBSZWdFeHAocS5qb2luKCJ8IikpLHI9ci5sZW5ndGgmJm5ldyBSZWdFeHAoci5qb2luKCJ8IikpLGI9JC50ZXN0KG8uY29tcGFyZURvY3VtZW50UG9zaXRpb24pLHQ9Ynx8JC50ZXN0KG8uY29udGFpbnMpP2Z1bmN0aW9uKGEsYil7dmFyIGM9OT09PWEubm9kZVR5cGU/YS5kb2N1bWVudEVsZW1lbnQ6YSxkPWImJmIucGFyZW50Tm9kZTtyZXR1cm4gYT09PWR8fCEoIWR8fDEhPT1kLm5vZGVUeXBlfHwhKGMuY29udGFpbnM/Yy5jb250YWlucyhkKTphLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uJiYxNiZhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGQpKSl9OmZ1bmN0aW9uKGEsYil7aWYoYil3aGlsZShiPWIucGFyZW50Tm9kZSlpZihiPT09YSlyZXR1cm4hMDtyZXR1cm4hMX0sQj1iP2Z1bmN0aW9uKGEsYil7aWYoYT09PWIpcmV0dXJuIGw9ITAsMDt2YXIgZD0hYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbi0hYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbjtyZXR1cm4gZD9kOihkPShhLm93bmVyRG9jdW1lbnR8fGEpPT09KGIub3duZXJEb2N1bWVudHx8Yik/YS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihiKToxLDEmZHx8IWMuc29ydERldGFjaGVkJiZiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGEpPT09ZD9hPT09ZXx8YS5vd25lckRvY3VtZW50PT09diYmdCh2LGEpPy0xOmI9PT1lfHxiLm93bmVyRG9jdW1lbnQ9PT12JiZ0KHYsYik/MTprP0suY2FsbChrLGEpLUsuY2FsbChrLGIpOjA6NCZkPy0xOjEpfTpmdW5jdGlvbihhLGIpe2lmKGE9PT1iKXJldHVybiBsPSEwLDA7dmFyIGMsZD0wLGY9YS5wYXJlbnROb2RlLGc9Yi5wYXJlbnROb2RlLGg9W2FdLGk9W2JdO2lmKCFmfHwhZylyZXR1cm4gYT09PWU/LTE6Yj09PWU/MTpmPy0xOmc/MTprP0suY2FsbChrLGEpLUsuY2FsbChrLGIpOjA7aWYoZj09PWcpcmV0dXJuIGtiKGEsYik7Yz1hO3doaWxlKGM9Yy5wYXJlbnROb2RlKWgudW5zaGlmdChjKTtjPWI7d2hpbGUoYz1jLnBhcmVudE5vZGUpaS51bnNoaWZ0KGMpO3doaWxlKGhbZF09PT1pW2RdKWQrKztyZXR1cm4gZD9rYihoW2RdLGlbZF0pOmhbZF09PT12Py0xOmlbZF09PT12PzE6MH0sZSk6bn0sZmIubWF0Y2hlcz1mdW5jdGlvbihhLGIpe3JldHVybiBmYihhLG51bGwsbnVsbCxiKX0sZmIubWF0Y2hlc1NlbGVjdG9yPWZ1bmN0aW9uKGEsYil7aWYoKGEub3duZXJEb2N1bWVudHx8YSkhPT1uJiZtKGEpLGI9Yi5yZXBsYWNlKFUsIj0nJDEnXSIpLCEoIWMubWF0Y2hlc1NlbGVjdG9yfHwhcHx8ciYmci50ZXN0KGIpfHxxJiZxLnRlc3QoYikpKXRyeXt2YXIgZD1zLmNhbGwoYSxiKTtpZihkfHxjLmRpc2Nvbm5lY3RlZE1hdGNofHxhLmRvY3VtZW50JiYxMSE9PWEuZG9jdW1lbnQubm9kZVR5cGUpcmV0dXJuIGR9Y2F0Y2goZSl7fXJldHVybiBmYihiLG4sbnVsbCxbYV0pLmxlbmd0aD4wfSxmYi5jb250YWlucz1mdW5jdGlvbihhLGIpe3JldHVybihhLm93bmVyRG9jdW1lbnR8fGEpIT09biYmbShhKSx0KGEsYil9LGZiLmF0dHI9ZnVuY3Rpb24oYSxiKXsoYS5vd25lckRvY3VtZW50fHxhKSE9PW4mJm0oYSk7dmFyIGU9ZC5hdHRySGFuZGxlW2IudG9Mb3dlckNhc2UoKV0sZj1lJiZFLmNhbGwoZC5hdHRySGFuZGxlLGIudG9Mb3dlckNhc2UoKSk/ZShhLGIsIXApOnZvaWQgMDtyZXR1cm4gdm9pZCAwIT09Zj9mOmMuYXR0cmlidXRlc3x8IXA/YS5nZXRBdHRyaWJ1dGUoYik6KGY9YS5nZXRBdHRyaWJ1dGVOb2RlKGIpKSYmZi5zcGVjaWZpZWQ/Zi52YWx1ZTpudWxsfSxmYi5lcnJvcj1mdW5jdGlvbihhKXt0aHJvdyBuZXcgRXJyb3IoIlN5bnRheCBlcnJvciwgdW5yZWNvZ25pemVkIGV4cHJlc3Npb246ICIrYSl9LGZiLnVuaXF1ZVNvcnQ9ZnVuY3Rpb24oYSl7dmFyIGIsZD1bXSxlPTAsZj0wO2lmKGw9IWMuZGV0ZWN0RHVwbGljYXRlcyxrPSFjLnNvcnRTdGFibGUmJmEuc2xpY2UoMCksYS5zb3J0KEIpLGwpe3doaWxlKGI9YVtmKytdKWI9PT1hW2ZdJiYoZT1kLnB1c2goZikpO3doaWxlKGUtLSlhLnNwbGljZShkW2VdLDEpfXJldHVybiBrPW51bGwsYX0sZT1mYi5nZXRUZXh0PWZ1bmN0aW9uKGEpe3ZhciBiLGM9IiIsZD0wLGY9YS5ub2RlVHlwZTtpZihmKXtpZigxPT09Znx8OT09PWZ8fDExPT09Zil7aWYoInN0cmluZyI9PXR5cGVvZiBhLnRleHRDb250ZW50KXJldHVybiBhLnRleHRDb250ZW50O2ZvcihhPWEuZmlyc3RDaGlsZDthO2E9YS5uZXh0U2libGluZyljKz1lKGEpfWVsc2UgaWYoMz09PWZ8fDQ9PT1mKXJldHVybiBhLm5vZGVWYWx1ZX1lbHNlIHdoaWxlKGI9YVtkKytdKWMrPWUoYik7cmV0dXJuIGN9LGQ9ZmIuc2VsZWN0b3JzPXtjYWNoZUxlbmd0aDo1MCxjcmVhdGVQc2V1ZG86aGIsbWF0Y2g6WCxhdHRySGFuZGxlOnt9LGZpbmQ6e30scmVsYXRpdmU6eyI+Ijp7ZGlyOiJwYXJlbnROb2RlIixmaXJzdDohMH0sIiAiOntkaXI6InBhcmVudE5vZGUifSwiKyI6e2RpcjoicHJldmlvdXNTaWJsaW5nIixmaXJzdDohMH0sIn4iOntkaXI6InByZXZpb3VzU2libGluZyJ9fSxwcmVGaWx0ZXI6e0FUVFI6ZnVuY3Rpb24oYSl7cmV0dXJuIGFbMV09YVsxXS5yZXBsYWNlKGNiLGRiKSxhWzNdPShhWzNdfHxhWzRdfHxhWzVdfHwiIikucmVwbGFjZShjYixkYiksIn49Ij09PWFbMl0mJihhWzNdPSIgIithWzNdKyIgIiksYS5zbGljZSgwLDQpfSxDSElMRDpmdW5jdGlvbihhKXtyZXR1cm4gYVsxXT1hWzFdLnRvTG93ZXJDYXNlKCksIm50aCI9PT1hWzFdLnNsaWNlKDAsMyk/KGFbM118fGZiLmVycm9yKGFbMF0pLGFbNF09KyhhWzRdP2FbNV0rKGFbNl18fDEpOjIqKCJldmVuIj09PWFbM118fCJvZGQiPT09YVszXSkpLGFbNV09KyhhWzddK2FbOF18fCJvZGQiPT09YVszXSkpOmFbM10mJmZiLmVycm9yKGFbMF0pLGF9LFBTRVVETzpmdW5jdGlvbihhKXt2YXIgYixjPSFhWzZdJiZhWzJdO3JldHVybiBYLkNISUxELnRlc3QoYVswXSk/bnVsbDooYVszXT9hWzJdPWFbNF18fGFbNV18fCIiOmMmJlYudGVzdChjKSYmKGI9ZyhjLCEwKSkmJihiPWMuaW5kZXhPZigiKSIsYy5sZW5ndGgtYiktYy5sZW5ndGgpJiYoYVswXT1hWzBdLnNsaWNlKDAsYiksYVsyXT1jLnNsaWNlKDAsYikpLGEuc2xpY2UoMCwzKSl9fSxmaWx0ZXI6e1RBRzpmdW5jdGlvbihhKXt2YXIgYj1hLnJlcGxhY2UoY2IsZGIpLnRvTG93ZXJDYXNlKCk7cmV0dXJuIioiPT09YT9mdW5jdGlvbigpe3JldHVybiEwfTpmdW5jdGlvbihhKXtyZXR1cm4gYS5ub2RlTmFtZSYmYS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpPT09Yn19LENMQVNTOmZ1bmN0aW9uKGEpe3ZhciBiPXlbYSsiICJdO3JldHVybiBifHwoYj1uZXcgUmVnRXhwKCIoXnwiK00rIikiK2ErIigiK00rInwkKSIpKSYmeShhLGZ1bmN0aW9uKGEpe3JldHVybiBiLnRlc3QoInN0cmluZyI9PXR5cGVvZiBhLmNsYXNzTmFtZSYmYS5jbGFzc05hbWV8fHR5cGVvZiBhLmdldEF0dHJpYnV0ZSE9PUMmJmEuZ2V0QXR0cmlidXRlKCJjbGFzcyIpfHwiIil9KX0sQVRUUjpmdW5jdGlvbihhLGIsYyl7cmV0dXJuIGZ1bmN0aW9uKGQpe3ZhciBlPWZiLmF0dHIoZCxhKTtyZXR1cm4gbnVsbD09ZT8iIT0iPT09YjpiPyhlKz0iIiwiPSI9PT1iP2U9PT1jOiIhPSI9PT1iP2UhPT1jOiJePSI9PT1iP2MmJjA9PT1lLmluZGV4T2YoYyk6Iio9Ij09PWI/YyYmZS5pbmRleE9mKGMpPi0xOiIkPSI9PT1iP2MmJmUuc2xpY2UoLWMubGVuZ3RoKT09PWM6In49Ij09PWI/KCIgIitlKyIgIikuaW5kZXhPZihjKT4tMToifD0iPT09Yj9lPT09Y3x8ZS5zbGljZSgwLGMubGVuZ3RoKzEpPT09YysiLSI6ITEpOiEwfX0sQ0hJTEQ6ZnVuY3Rpb24oYSxiLGMsZCxlKXt2YXIgZj0ibnRoIiE9PWEuc2xpY2UoMCwzKSxnPSJsYXN0IiE9PWEuc2xpY2UoLTQpLGg9Im9mLXR5cGUiPT09YjtyZXR1cm4gMT09PWQmJjA9PT1lP2Z1bmN0aW9uKGEpe3JldHVybiEhYS5wYXJlbnROb2RlfTpmdW5jdGlvbihiLGMsaSl7dmFyIGosayxsLG0sbixvLHA9ZiE9PWc/Im5leHRTaWJsaW5nIjoicHJldmlvdXNTaWJsaW5nIixxPWIucGFyZW50Tm9kZSxyPWgmJmIubm9kZU5hbWUudG9Mb3dlckNhc2UoKSxzPSFpJiYhaDtpZihxKXtpZihmKXt3aGlsZShwKXtsPWI7d2hpbGUobD1sW3BdKWlmKGg/bC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpPT09cjoxPT09bC5ub2RlVHlwZSlyZXR1cm4hMTtvPXA9Im9ubHkiPT09YSYmIW8mJiJuZXh0U2libGluZyJ9cmV0dXJuITB9aWYobz1bZz9xLmZpcnN0Q2hpbGQ6cS5sYXN0Q2hpbGRdLGcmJnMpe2s9cVt1XXx8KHFbdV09e30pLGo9a1thXXx8W10sbj1qWzBdPT09dyYmalsxXSxtPWpbMF09PT13JiZqWzJdLGw9biYmcS5jaGlsZE5vZGVzW25dO3doaWxlKGw9KytuJiZsJiZsW3BdfHwobT1uPTApfHxvLnBvcCgpKWlmKDE9PT1sLm5vZGVUeXBlJiYrK20mJmw9PT1iKXtrW2FdPVt3LG4sbV07YnJlYWt9fWVsc2UgaWYocyYmKGo9KGJbdV18fChiW3VdPXt9KSlbYV0pJiZqWzBdPT09dyltPWpbMV07ZWxzZSB3aGlsZShsPSsrbiYmbCYmbFtwXXx8KG09bj0wKXx8by5wb3AoKSlpZigoaD9sLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk9PT1yOjE9PT1sLm5vZGVUeXBlKSYmKyttJiYocyYmKChsW3VdfHwobFt1XT17fSkpW2FdPVt3LG1dKSxsPT09YikpYnJlYWs7cmV0dXJuIG0tPWUsbT09PWR8fG0lZD09PTAmJm0vZD49MH19fSxQU0VVRE86ZnVuY3Rpb24oYSxiKXt2YXIgYyxlPWQucHNldWRvc1thXXx8ZC5zZXRGaWx0ZXJzW2EudG9Mb3dlckNhc2UoKV18fGZiLmVycm9yKCJ1bnN1cHBvcnRlZCBwc2V1ZG86ICIrYSk7cmV0dXJuIGVbdV0/ZShiKTplLmxlbmd0aD4xPyhjPVthLGEsIiIsYl0sZC5zZXRGaWx0ZXJzLmhhc093blByb3BlcnR5KGEudG9Mb3dlckNhc2UoKSk/aGIoZnVuY3Rpb24oYSxjKXt2YXIgZCxmPWUoYSxiKSxnPWYubGVuZ3RoO3doaWxlKGctLSlkPUsuY2FsbChhLGZbZ10pLGFbZF09IShjW2RdPWZbZ10pfSk6ZnVuY3Rpb24oYSl7cmV0dXJuIGUoYSwwLGMpfSk6ZX19LHBzZXVkb3M6e25vdDpoYihmdW5jdGlvbihhKXt2YXIgYj1bXSxjPVtdLGQ9aChhLnJlcGxhY2UoUiwiJDEiKSk7cmV0dXJuIGRbdV0/aGIoZnVuY3Rpb24oYSxiLGMsZSl7dmFyIGYsZz1kKGEsbnVsbCxlLFtdKSxoPWEubGVuZ3RoO3doaWxlKGgtLSkoZj1nW2hdKSYmKGFbaF09IShiW2hdPWYpKX0pOmZ1bmN0aW9uKGEsZSxmKXtyZXR1cm4gYlswXT1hLGQoYixudWxsLGYsYyksIWMucG9wKCl9fSksaGFzOmhiKGZ1bmN0aW9uKGEpe3JldHVybiBmdW5jdGlvbihiKXtyZXR1cm4gZmIoYSxiKS5sZW5ndGg+MH19KSxjb250YWluczpoYihmdW5jdGlvbihhKXtyZXR1cm4gZnVuY3Rpb24oYil7cmV0dXJuKGIudGV4dENvbnRlbnR8fGIuaW5uZXJUZXh0fHxlKGIpKS5pbmRleE9mKGEpPi0xfX0pLGxhbmc6aGIoZnVuY3Rpb24oYSl7cmV0dXJuIFcudGVzdChhfHwiIil8fGZiLmVycm9yKCJ1bnN1cHBvcnRlZCBsYW5nOiAiK2EpLGE9YS5yZXBsYWNlKGNiLGRiKS50b0xvd2VyQ2FzZSgpLGZ1bmN0aW9uKGIpe3ZhciBjO2RvIGlmKGM9cD9iLmxhbmc6Yi5nZXRBdHRyaWJ1dGUoInhtbDpsYW5nIil8fGIuZ2V0QXR0cmlidXRlKCJsYW5nIikpcmV0dXJuIGM9Yy50b0xvd2VyQ2FzZSgpLGM9PT1hfHwwPT09Yy5pbmRleE9mKGErIi0iKTt3aGlsZSgoYj1iLnBhcmVudE5vZGUpJiYxPT09Yi5ub2RlVHlwZSk7cmV0dXJuITF9fSksdGFyZ2V0OmZ1bmN0aW9uKGIpe3ZhciBjPWEubG9jYXRpb24mJmEubG9jYXRpb24uaGFzaDtyZXR1cm4gYyYmYy5zbGljZSgxKT09PWIuaWR9LHJvb3Q6ZnVuY3Rpb24oYSl7cmV0dXJuIGE9PT1vfSxmb2N1czpmdW5jdGlvbihhKXtyZXR1cm4gYT09PW4uYWN0aXZlRWxlbWVudCYmKCFuLmhhc0ZvY3VzfHxuLmhhc0ZvY3VzKCkpJiYhIShhLnR5cGV8fGEuaHJlZnx8fmEudGFiSW5kZXgpfSxlbmFibGVkOmZ1bmN0aW9uKGEpe3JldHVybiBhLmRpc2FibGVkPT09ITF9LGRpc2FibGVkOmZ1bmN0aW9uKGEpe3JldHVybiBhLmRpc2FibGVkPT09ITB9LGNoZWNrZWQ6ZnVuY3Rpb24oYSl7dmFyIGI9YS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO3JldHVybiJpbnB1dCI9PT1iJiYhIWEuY2hlY2tlZHx8Im9wdGlvbiI9PT1iJiYhIWEuc2VsZWN0ZWR9LHNlbGVjdGVkOmZ1bmN0aW9uKGEpe3JldHVybiBhLnBhcmVudE5vZGUmJmEucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4LGEuc2VsZWN0ZWQ9PT0hMH0sZW1wdHk6ZnVuY3Rpb24oYSl7Zm9yKGE9YS5maXJzdENoaWxkO2E7YT1hLm5leHRTaWJsaW5nKWlmKGEubm9kZVR5cGU8NilyZXR1cm4hMTtyZXR1cm4hMH0scGFyZW50OmZ1bmN0aW9uKGEpe3JldHVybiFkLnBzZXVkb3MuZW1wdHkoYSl9LGhlYWRlcjpmdW5jdGlvbihhKXtyZXR1cm4gWi50ZXN0KGEubm9kZU5hbWUpfSxpbnB1dDpmdW5jdGlvbihhKXtyZXR1cm4gWS50ZXN0KGEubm9kZU5hbWUpfSxidXR0b246ZnVuY3Rpb24oYSl7dmFyIGI9YS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO3JldHVybiJpbnB1dCI9PT1iJiYiYnV0dG9uIj09PWEudHlwZXx8ImJ1dHRvbiI9PT1ifSx0ZXh0OmZ1bmN0aW9uKGEpe3ZhciBiO3JldHVybiJpbnB1dCI9PT1hLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkmJiJ0ZXh0Ij09PWEudHlwZSYmKG51bGw9PShiPWEuZ2V0QXR0cmlidXRlKCJ0eXBlIikpfHwidGV4dCI9PT1iLnRvTG93ZXJDYXNlKCkpfSxmaXJzdDpuYihmdW5jdGlvbigpe3JldHVyblswXX0pLGxhc3Q6bmIoZnVuY3Rpb24oYSxiKXtyZXR1cm5bYi0xXX0pLGVxOm5iKGZ1bmN0aW9uKGEsYixjKXtyZXR1cm5bMD5jP2MrYjpjXX0pLGV2ZW46bmIoZnVuY3Rpb24oYSxiKXtmb3IodmFyIGM9MDtiPmM7Yys9MilhLnB1c2goYyk7cmV0dXJuIGF9KSxvZGQ6bmIoZnVuY3Rpb24oYSxiKXtmb3IodmFyIGM9MTtiPmM7Yys9MilhLnB1c2goYyk7cmV0dXJuIGF9KSxsdDpuYihmdW5jdGlvbihhLGIsYyl7Zm9yKHZhciBkPTA+Yz9jK2I6YzstLWQ+PTA7KWEucHVzaChkKTtyZXR1cm4gYX0pLGd0Om5iKGZ1bmN0aW9uKGEsYixjKXtmb3IodmFyIGQ9MD5jP2MrYjpjOysrZDxiOylhLnB1c2goZCk7cmV0dXJuIGF9KX19LGQucHNldWRvcy5udGg9ZC5wc2V1ZG9zLmVxO2ZvcihiIGlue3JhZGlvOiEwLGNoZWNrYm94OiEwLGZpbGU6ITAscGFzc3dvcmQ6ITAsaW1hZ2U6ITB9KWQucHNldWRvc1tiXT1sYihiKTtmb3IoYiBpbntzdWJtaXQ6ITAscmVzZXQ6ITB9KWQucHNldWRvc1tiXT1tYihiKTtmdW5jdGlvbiBwYigpe31wYi5wcm90b3R5cGU9ZC5maWx0ZXJzPWQucHNldWRvcyxkLnNldEZpbHRlcnM9bmV3IHBiLGc9ZmIudG9rZW5pemU9ZnVuY3Rpb24oYSxiKXt2YXIgYyxlLGYsZyxoLGksaixrPXpbYSsiICJdO2lmKGspcmV0dXJuIGI/MDprLnNsaWNlKDApO2g9YSxpPVtdLGo9ZC5wcmVGaWx0ZXI7d2hpbGUoaCl7KCFjfHwoZT1TLmV4ZWMoaCkpKSYmKGUmJihoPWguc2xpY2UoZVswXS5sZW5ndGgpfHxoKSxpLnB1c2goZj1bXSkpLGM9ITEsKGU9VC5leGVjKGgpKSYmKGM9ZS5zaGlmdCgpLGYucHVzaCh7dmFsdWU6Yyx0eXBlOmVbMF0ucmVwbGFjZShSLCIgIil9KSxoPWguc2xpY2UoYy5sZW5ndGgpKTtmb3IoZyBpbiBkLmZpbHRlcikhKGU9WFtnXS5leGVjKGgpKXx8altnXSYmIShlPWpbZ10oZSkpfHwoYz1lLnNoaWZ0KCksZi5wdXNoKHt2YWx1ZTpjLHR5cGU6ZyxtYXRjaGVzOmV9KSxoPWguc2xpY2UoYy5sZW5ndGgpKTtpZighYylicmVha31yZXR1cm4gYj9oLmxlbmd0aDpoP2ZiLmVycm9yKGEpOnooYSxpKS5zbGljZSgwKX07ZnVuY3Rpb24gcWIoYSl7Zm9yKHZhciBiPTAsYz1hLmxlbmd0aCxkPSIiO2M+YjtiKyspZCs9YVtiXS52YWx1ZTtyZXR1cm4gZH1mdW5jdGlvbiByYihhLGIsYyl7dmFyIGQ9Yi5kaXIsZT1jJiYicGFyZW50Tm9kZSI9PT1kLGY9eCsrO3JldHVybiBiLmZpcnN0P2Z1bmN0aW9uKGIsYyxmKXt3aGlsZShiPWJbZF0paWYoMT09PWIubm9kZVR5cGV8fGUpcmV0dXJuIGEoYixjLGYpfTpmdW5jdGlvbihiLGMsZyl7dmFyIGgsaSxqPVt3LGZdO2lmKGcpe3doaWxlKGI9YltkXSlpZigoMT09PWIubm9kZVR5cGV8fGUpJiZhKGIsYyxnKSlyZXR1cm4hMH1lbHNlIHdoaWxlKGI9YltkXSlpZigxPT09Yi5ub2RlVHlwZXx8ZSl7aWYoaT1iW3VdfHwoYlt1XT17fSksKGg9aVtkXSkmJmhbMF09PT13JiZoWzFdPT09ZilyZXR1cm4galsyXT1oWzJdO2lmKGlbZF09aixqWzJdPWEoYixjLGcpKXJldHVybiEwfX19ZnVuY3Rpb24gc2IoYSl7cmV0dXJuIGEubGVuZ3RoPjE/ZnVuY3Rpb24oYixjLGQpe3ZhciBlPWEubGVuZ3RoO3doaWxlKGUtLSlpZighYVtlXShiLGMsZCkpcmV0dXJuITE7cmV0dXJuITB9OmFbMF19ZnVuY3Rpb24gdGIoYSxiLGMpe2Zvcih2YXIgZD0wLGU9Yi5sZW5ndGg7ZT5kO2QrKylmYihhLGJbZF0sYyk7cmV0dXJuIGN9ZnVuY3Rpb24gdWIoYSxiLGMsZCxlKXtmb3IodmFyIGYsZz1bXSxoPTAsaT1hLmxlbmd0aCxqPW51bGwhPWI7aT5oO2grKykoZj1hW2hdKSYmKCFjfHxjKGYsZCxlKSkmJihnLnB1c2goZiksaiYmYi5wdXNoKGgpKTtyZXR1cm4gZ31mdW5jdGlvbiB2YihhLGIsYyxkLGUsZil7cmV0dXJuIGQmJiFkW3VdJiYoZD12YihkKSksZSYmIWVbdV0mJihlPXZiKGUsZikpLGhiKGZ1bmN0aW9uKGYsZyxoLGkpe3ZhciBqLGssbCxtPVtdLG49W10sbz1nLmxlbmd0aCxwPWZ8fHRiKGJ8fCIqIixoLm5vZGVUeXBlP1toXTpoLFtdKSxxPSFhfHwhZiYmYj9wOnViKHAsbSxhLGgsaSkscj1jP2V8fChmP2E6b3x8ZCk/W106ZzpxO2lmKGMmJmMocSxyLGgsaSksZCl7aj11YihyLG4pLGQoaixbXSxoLGkpLGs9ai5sZW5ndGg7d2hpbGUoay0tKShsPWpba10pJiYocltuW2tdXT0hKHFbbltrXV09bCkpfWlmKGYpe2lmKGV8fGEpe2lmKGUpe2o9W10saz1yLmxlbmd0aDt3aGlsZShrLS0pKGw9cltrXSkmJmoucHVzaChxW2tdPWwpO2UobnVsbCxyPVtdLGosaSl9az1yLmxlbmd0aDt3aGlsZShrLS0pKGw9cltrXSkmJihqPWU/Sy5jYWxsKGYsbCk6bVtrXSk+LTEmJihmW2pdPSEoZ1tqXT1sKSl9fWVsc2Ugcj11YihyPT09Zz9yLnNwbGljZShvLHIubGVuZ3RoKTpyKSxlP2UobnVsbCxnLHIsaSk6SS5hcHBseShnLHIpfSl9ZnVuY3Rpb24gd2IoYSl7Zm9yKHZhciBiLGMsZSxmPWEubGVuZ3RoLGc9ZC5yZWxhdGl2ZVthWzBdLnR5cGVdLGg9Z3x8ZC5yZWxhdGl2ZVsiICJdLGk9Zz8xOjAsaz1yYihmdW5jdGlvbihhKXtyZXR1cm4gYT09PWJ9LGgsITApLGw9cmIoZnVuY3Rpb24oYSl7cmV0dXJuIEsuY2FsbChiLGEpPi0xfSxoLCEwKSxtPVtmdW5jdGlvbihhLGMsZCl7cmV0dXJuIWcmJihkfHxjIT09ail8fCgoYj1jKS5ub2RlVHlwZT9rKGEsYyxkKTpsKGEsYyxkKSl9XTtmPmk7aSsrKWlmKGM9ZC5yZWxhdGl2ZVthW2ldLnR5cGVdKW09W3JiKHNiKG0pLGMpXTtlbHNle2lmKGM9ZC5maWx0ZXJbYVtpXS50eXBlXS5hcHBseShudWxsLGFbaV0ubWF0Y2hlcyksY1t1XSl7Zm9yKGU9KytpO2Y+ZTtlKyspaWYoZC5yZWxhdGl2ZVthW2VdLnR5cGVdKWJyZWFrO3JldHVybiB2YihpPjEmJnNiKG0pLGk+MSYmcWIoYS5zbGljZSgwLGktMSkuY29uY2F0KHt2YWx1ZToiICI9PT1hW2ktMl0udHlwZT8iKiI6IiJ9KSkucmVwbGFjZShSLCIkMSIpLGMsZT5pJiZ3YihhLnNsaWNlKGksZSkpLGY+ZSYmd2IoYT1hLnNsaWNlKGUpKSxmPmUmJnFiKGEpKX1tLnB1c2goYyl9cmV0dXJuIHNiKG0pfWZ1bmN0aW9uIHhiKGEsYil7dmFyIGM9Yi5sZW5ndGg+MCxlPWEubGVuZ3RoPjAsZj1mdW5jdGlvbihmLGcsaCxpLGspe3ZhciBsLG0sbyxwPTAscT0iMCIscj1mJiZbXSxzPVtdLHQ9aix1PWZ8fGUmJmQuZmluZC5UQUcoIioiLGspLHY9dys9bnVsbD09dD8xOk1hdGgucmFuZG9tKCl8fC4xLHg9dS5sZW5ndGg7Zm9yKGsmJihqPWchPT1uJiZnKTtxIT09eCYmbnVsbCE9KGw9dVtxXSk7cSsrKXtpZihlJiZsKXttPTA7d2hpbGUobz1hW20rK10paWYobyhsLGcsaCkpe2kucHVzaChsKTticmVha31rJiYodz12KX1jJiYoKGw9IW8mJmwpJiZwLS0sZiYmci5wdXNoKGwpKX1pZihwKz1xLGMmJnEhPT1wKXttPTA7d2hpbGUobz1iW20rK10pbyhyLHMsZyxoKTtpZihmKXtpZihwPjApd2hpbGUocS0tKXJbcV18fHNbcV18fChzW3FdPUcuY2FsbChpKSk7cz11YihzKX1JLmFwcGx5KGkscyksayYmIWYmJnMubGVuZ3RoPjAmJnArYi5sZW5ndGg+MSYmZmIudW5pcXVlU29ydChpKX1yZXR1cm4gayYmKHc9dixqPXQpLHJ9O3JldHVybiBjP2hiKGYpOmZ9cmV0dXJuIGg9ZmIuY29tcGlsZT1mdW5jdGlvbihhLGIpe3ZhciBjLGQ9W10sZT1bXSxmPUFbYSsiICJdO2lmKCFmKXtifHwoYj1nKGEpKSxjPWIubGVuZ3RoO3doaWxlKGMtLSlmPXdiKGJbY10pLGZbdV0/ZC5wdXNoKGYpOmUucHVzaChmKTtmPUEoYSx4YihlLGQpKSxmLnNlbGVjdG9yPWF9cmV0dXJuIGZ9LGk9ZmIuc2VsZWN0PWZ1bmN0aW9uKGEsYixlLGYpe3ZhciBpLGosayxsLG0sbj0iZnVuY3Rpb24iPT10eXBlb2YgYSYmYSxvPSFmJiZnKGE9bi5zZWxlY3Rvcnx8YSk7aWYoZT1lfHxbXSwxPT09by5sZW5ndGgpe2lmKGo9b1swXT1vWzBdLnNsaWNlKDApLGoubGVuZ3RoPjImJiJJRCI9PT0oaz1qWzBdKS50eXBlJiZjLmdldEJ5SWQmJjk9PT1iLm5vZGVUeXBlJiZwJiZkLnJlbGF0aXZlW2pbMV0udHlwZV0pe2lmKGI9KGQuZmluZC5JRChrLm1hdGNoZXNbMF0ucmVwbGFjZShjYixkYiksYil8fFtdKVswXSwhYilyZXR1cm4gZTtuJiYoYj1iLnBhcmVudE5vZGUpLGE9YS5zbGljZShqLnNoaWZ0KCkudmFsdWUubGVuZ3RoKX1pPVgubmVlZHNDb250ZXh0LnRlc3QoYSk/MDpqLmxlbmd0aDt3aGlsZShpLS0pe2lmKGs9altpXSxkLnJlbGF0aXZlW2w9ay50eXBlXSlicmVhaztpZigobT1kLmZpbmRbbF0pJiYoZj1tKGsubWF0Y2hlc1swXS5yZXBsYWNlKGNiLGRiKSxhYi50ZXN0KGpbMF0udHlwZSkmJm9iKGIucGFyZW50Tm9kZSl8fGIpKSl7aWYoai5zcGxpY2UoaSwxKSxhPWYubGVuZ3RoJiZxYihqKSwhYSlyZXR1cm4gSS5hcHBseShlLGYpLGU7YnJlYWt9fX1yZXR1cm4obnx8aChhLG8pKShmLGIsIXAsZSxhYi50ZXN0KGEpJiZvYihiLnBhcmVudE5vZGUpfHxiKSxlfSxjLnNvcnRTdGFibGU9dS5zcGxpdCgiIikuc29ydChCKS5qb2luKCIiKT09PXUsYy5kZXRlY3REdXBsaWNhdGVzPSEhbCxtKCksYy5zb3J0RGV0YWNoZWQ9aWIoZnVuY3Rpb24oYSl7cmV0dXJuIDEmYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihuLmNyZWF0ZUVsZW1lbnQoImRpdiIpKX0pLGliKGZ1bmN0aW9uKGEpe3JldHVybiBhLmlubmVySFRNTD0iPGEgaHJlZj0nIyc+PC9hPiIsIiMiPT09YS5maXJzdENoaWxkLmdldEF0dHJpYnV0ZSgiaHJlZiIpfSl8fGpiKCJ0eXBlfGhyZWZ8aGVpZ2h0fHdpZHRoIixmdW5jdGlvbihhLGIsYyl7cmV0dXJuIGM/dm9pZCAwOmEuZ2V0QXR0cmlidXRlKGIsInR5cGUiPT09Yi50b0xvd2VyQ2FzZSgpPzE6Mil9KSxjLmF0dHJpYnV0ZXMmJmliKGZ1bmN0aW9uKGEpe3JldHVybiBhLmlubmVySFRNTD0iPGlucHV0Lz4iLGEuZmlyc3RDaGlsZC5zZXRBdHRyaWJ1dGUoInZhbHVlIiwiIiksIiI9PT1hLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKCJ2YWx1ZSIpfSl8fGpiKCJ2YWx1ZSIsZnVuY3Rpb24oYSxiLGMpe3JldHVybiBjfHwiaW5wdXQiIT09YS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpP3ZvaWQgMDphLmRlZmF1bHRWYWx1ZX0pLGliKGZ1bmN0aW9uKGEpe3JldHVybiBudWxsPT1hLmdldEF0dHJpYnV0ZSgiZGlzYWJsZWQiKX0pfHxqYihMLGZ1bmN0aW9uKGEsYixjKXt2YXIgZDtyZXR1cm4gYz92b2lkIDA6YVtiXT09PSEwP2IudG9Mb3dlckNhc2UoKTooZD1hLmdldEF0dHJpYnV0ZU5vZGUoYikpJiZkLnNwZWNpZmllZD9kLnZhbHVlOm51bGx9KSxmYn0oYSk7bS5maW5kPXMsbS5leHByPXMuc2VsZWN0b3JzLG0uZXhwclsiOiJdPW0uZXhwci5wc2V1ZG9zLG0udW5pcXVlPXMudW5pcXVlU29ydCxtLnRleHQ9cy5nZXRUZXh0LG0uaXNYTUxEb2M9cy5pc1hNTCxtLmNvbnRhaW5zPXMuY29udGFpbnM7dmFyIHQ9bS5leHByLm1hdGNoLm5lZWRzQ29udGV4dCx1PS9ePChcdyspXHMqXC8/Pig/OjxcL1wxPnwpJC8sdj0vXi5bXjojXFtcLixdKiQvO2Z1bmN0aW9uIHcoYSxiLGMpe2lmKG0uaXNGdW5jdGlvbihiKSlyZXR1cm4gbS5ncmVwKGEsZnVuY3Rpb24oYSxkKXtyZXR1cm4hIWIuY2FsbChhLGQsYSkhPT1jfSk7aWYoYi5ub2RlVHlwZSlyZXR1cm4gbS5ncmVwKGEsZnVuY3Rpb24oYSl7cmV0dXJuIGE9PT1iIT09Y30pO2lmKCJzdHJpbmciPT10eXBlb2YgYil7aWYodi50ZXN0KGIpKXJldHVybiBtLmZpbHRlcihiLGEsYyk7Yj1tLmZpbHRlcihiLGEpfXJldHVybiBtLmdyZXAoYSxmdW5jdGlvbihhKXtyZXR1cm4gbS5pbkFycmF5KGEsYik+PTAhPT1jfSl9bS5maWx0ZXI9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPWJbMF07cmV0dXJuIGMmJihhPSI6bm90KCIrYSsiKSIpLDE9PT1iLmxlbmd0aCYmMT09PWQubm9kZVR5cGU/bS5maW5kLm1hdGNoZXNTZWxlY3RvcihkLGEpP1tkXTpbXTptLmZpbmQubWF0Y2hlcyhhLG0uZ3JlcChiLGZ1bmN0aW9uKGEpe3JldHVybiAxPT09YS5ub2RlVHlwZX0pKX0sbS5mbi5leHRlbmQoe2ZpbmQ6ZnVuY3Rpb24oYSl7dmFyIGIsYz1bXSxkPXRoaXMsZT1kLmxlbmd0aDtpZigic3RyaW5nIiE9dHlwZW9mIGEpcmV0dXJuIHRoaXMucHVzaFN0YWNrKG0oYSkuZmlsdGVyKGZ1bmN0aW9uKCl7Zm9yKGI9MDtlPmI7YisrKWlmKG0uY29udGFpbnMoZFtiXSx0aGlzKSlyZXR1cm4hMH0pKTtmb3IoYj0wO2U+YjtiKyspbS5maW5kKGEsZFtiXSxjKTtyZXR1cm4gYz10aGlzLnB1c2hTdGFjayhlPjE/bS51bmlxdWUoYyk6YyksYy5zZWxlY3Rvcj10aGlzLnNlbGVjdG9yP3RoaXMuc2VsZWN0b3IrIiAiK2E6YSxjfSxmaWx0ZXI6ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMucHVzaFN0YWNrKHcodGhpcyxhfHxbXSwhMSkpfSxub3Q6ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMucHVzaFN0YWNrKHcodGhpcyxhfHxbXSwhMCkpfSxpczpmdW5jdGlvbihhKXtyZXR1cm4hIXcodGhpcywic3RyaW5nIj09dHlwZW9mIGEmJnQudGVzdChhKT9tKGEpOmF8fFtdLCExKS5sZW5ndGh9fSk7dmFyIHgseT1hLmRvY3VtZW50LHo9L14oPzpccyooPFtcd1xXXSs+KVtePl0qfCMoW1x3LV0qKSkkLyxBPW0uZm4uaW5pdD1mdW5jdGlvbihhLGIpe3ZhciBjLGQ7aWYoIWEpcmV0dXJuIHRoaXM7aWYoInN0cmluZyI9PXR5cGVvZiBhKXtpZihjPSI8Ij09PWEuY2hhckF0KDApJiYiPiI9PT1hLmNoYXJBdChhLmxlbmd0aC0xKSYmYS5sZW5ndGg+PTM/W251bGwsYSxudWxsXTp6LmV4ZWMoYSksIWN8fCFjWzFdJiZiKXJldHVybiFifHxiLmpxdWVyeT8oYnx8eCkuZmluZChhKTp0aGlzLmNvbnN0cnVjdG9yKGIpLmZpbmQoYSk7aWYoY1sxXSl7aWYoYj1iIGluc3RhbmNlb2YgbT9iWzBdOmIsbS5tZXJnZSh0aGlzLG0ucGFyc2VIVE1MKGNbMV0sYiYmYi5ub2RlVHlwZT9iLm93bmVyRG9jdW1lbnR8fGI6eSwhMCkpLHUudGVzdChjWzFdKSYmbS5pc1BsYWluT2JqZWN0KGIpKWZvcihjIGluIGIpbS5pc0Z1bmN0aW9uKHRoaXNbY10pP3RoaXNbY10oYltjXSk6dGhpcy5hdHRyKGMsYltjXSk7cmV0dXJuIHRoaXN9aWYoZD15LmdldEVsZW1lbnRCeUlkKGNbMl0pLGQmJmQucGFyZW50Tm9kZSl7aWYoZC5pZCE9PWNbMl0pcmV0dXJuIHguZmluZChhKTt0aGlzLmxlbmd0aD0xLHRoaXNbMF09ZH1yZXR1cm4gdGhpcy5jb250ZXh0PXksdGhpcy5zZWxlY3Rvcj1hLHRoaXN9cmV0dXJuIGEubm9kZVR5cGU/KHRoaXMuY29udGV4dD10aGlzWzBdPWEsdGhpcy5sZW5ndGg9MSx0aGlzKTptLmlzRnVuY3Rpb24oYSk/InVuZGVmaW5lZCIhPXR5cGVvZiB4LnJlYWR5P3gucmVhZHkoYSk6YShtKToodm9pZCAwIT09YS5zZWxlY3RvciYmKHRoaXMuc2VsZWN0b3I9YS5zZWxlY3Rvcix0aGlzLmNvbnRleHQ9YS5jb250ZXh0KSxtLm1ha2VBcnJheShhLHRoaXMpKX07QS5wcm90b3R5cGU9bS5mbix4PW0oeSk7dmFyIEI9L14oPzpwYXJlbnRzfHByZXYoPzpVbnRpbHxBbGwpKS8sQz17Y2hpbGRyZW46ITAsY29udGVudHM6ITAsbmV4dDohMCxwcmV2OiEwfTttLmV4dGVuZCh7ZGlyOmZ1bmN0aW9uKGEsYixjKXt2YXIgZD1bXSxlPWFbYl07d2hpbGUoZSYmOSE9PWUubm9kZVR5cGUmJih2b2lkIDA9PT1jfHwxIT09ZS5ub2RlVHlwZXx8IW0oZSkuaXMoYykpKTE9PT1lLm5vZGVUeXBlJiZkLnB1c2goZSksZT1lW2JdO3JldHVybiBkfSxzaWJsaW5nOmZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPVtdO2E7YT1hLm5leHRTaWJsaW5nKTE9PT1hLm5vZGVUeXBlJiZhIT09YiYmYy5wdXNoKGEpO3JldHVybiBjfX0pLG0uZm4uZXh0ZW5kKHtoYXM6ZnVuY3Rpb24oYSl7dmFyIGIsYz1tKGEsdGhpcyksZD1jLmxlbmd0aDtyZXR1cm4gdGhpcy5maWx0ZXIoZnVuY3Rpb24oKXtmb3IoYj0wO2Q+YjtiKyspaWYobS5jb250YWlucyh0aGlzLGNbYl0pKXJldHVybiEwfSl9LGNsb3Nlc3Q6ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGMsZD0wLGU9dGhpcy5sZW5ndGgsZj1bXSxnPXQudGVzdChhKXx8InN0cmluZyIhPXR5cGVvZiBhP20oYSxifHx0aGlzLmNvbnRleHQpOjA7ZT5kO2QrKylmb3IoYz10aGlzW2RdO2MmJmMhPT1iO2M9Yy5wYXJlbnROb2RlKWlmKGMubm9kZVR5cGU8MTEmJihnP2cuaW5kZXgoYyk+LTE6MT09PWMubm9kZVR5cGUmJm0uZmluZC5tYXRjaGVzU2VsZWN0b3IoYyxhKSkpe2YucHVzaChjKTticmVha31yZXR1cm4gdGhpcy5wdXNoU3RhY2soZi5sZW5ndGg+MT9tLnVuaXF1ZShmKTpmKX0saW5kZXg6ZnVuY3Rpb24oYSl7cmV0dXJuIGE/InN0cmluZyI9PXR5cGVvZiBhP20uaW5BcnJheSh0aGlzWzBdLG0oYSkpOm0uaW5BcnJheShhLmpxdWVyeT9hWzBdOmEsdGhpcyk6dGhpc1swXSYmdGhpc1swXS5wYXJlbnROb2RlP3RoaXMuZmlyc3QoKS5wcmV2QWxsKCkubGVuZ3RoOi0xfSxhZGQ6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5wdXNoU3RhY2sobS51bmlxdWUobS5tZXJnZSh0aGlzLmdldCgpLG0oYSxiKSkpKX0sYWRkQmFjazpmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5hZGQobnVsbD09YT90aGlzLnByZXZPYmplY3Q6dGhpcy5wcmV2T2JqZWN0LmZpbHRlcihhKSl9fSk7ZnVuY3Rpb24gRChhLGIpe2RvIGE9YVtiXTt3aGlsZShhJiYxIT09YS5ub2RlVHlwZSk7cmV0dXJuIGF9bS5lYWNoKHtwYXJlbnQ6ZnVuY3Rpb24oYSl7dmFyIGI9YS5wYXJlbnROb2RlO3JldHVybiBiJiYxMSE9PWIubm9kZVR5cGU/YjpudWxsfSxwYXJlbnRzOmZ1bmN0aW9uKGEpe3JldHVybiBtLmRpcihhLCJwYXJlbnROb2RlIil9LHBhcmVudHNVbnRpbDpmdW5jdGlvbihhLGIsYyl7cmV0dXJuIG0uZGlyKGEsInBhcmVudE5vZGUiLGMpfSxuZXh0OmZ1bmN0aW9uKGEpe3JldHVybiBEKGEsIm5leHRTaWJsaW5nIil9LHByZXY6ZnVuY3Rpb24oYSl7cmV0dXJuIEQoYSwicHJldmlvdXNTaWJsaW5nIil9LG5leHRBbGw6ZnVuY3Rpb24oYSl7cmV0dXJuIG0uZGlyKGEsIm5leHRTaWJsaW5nIil9LHByZXZBbGw6ZnVuY3Rpb24oYSl7cmV0dXJuIG0uZGlyKGEsInByZXZpb3VzU2libGluZyIpfSxuZXh0VW50aWw6ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBtLmRpcihhLCJuZXh0U2libGluZyIsYyl9LHByZXZVbnRpbDpmdW5jdGlvbihhLGIsYyl7cmV0dXJuIG0uZGlyKGEsInByZXZpb3VzU2libGluZyIsYyl9LHNpYmxpbmdzOmZ1bmN0aW9uKGEpe3JldHVybiBtLnNpYmxpbmcoKGEucGFyZW50Tm9kZXx8e30pLmZpcnN0Q2hpbGQsYSl9LGNoaWxkcmVuOmZ1bmN0aW9uKGEpe3JldHVybiBtLnNpYmxpbmcoYS5maXJzdENoaWxkKX0sY29udGVudHM6ZnVuY3Rpb24oYSl7cmV0dXJuIG0ubm9kZU5hbWUoYSwiaWZyYW1lIik/YS5jb250ZW50RG9jdW1lbnR8fGEuY29udGVudFdpbmRvdy5kb2N1bWVudDptLm1lcmdlKFtdLGEuY2hpbGROb2Rlcyl9fSxmdW5jdGlvbihhLGIpe20uZm5bYV09ZnVuY3Rpb24oYyxkKXt2YXIgZT1tLm1hcCh0aGlzLGIsYyk7cmV0dXJuIlVudGlsIiE9PWEuc2xpY2UoLTUpJiYoZD1jKSxkJiYic3RyaW5nIj09dHlwZW9mIGQmJihlPW0uZmlsdGVyKGQsZSkpLHRoaXMubGVuZ3RoPjEmJihDW2FdfHwoZT1tLnVuaXF1ZShlKSksQi50ZXN0KGEpJiYoZT1lLnJldmVyc2UoKSkpLHRoaXMucHVzaFN0YWNrKGUpfX0pO3ZhciBFPS9cUysvZyxGPXt9O2Z1bmN0aW9uIEcoYSl7dmFyIGI9RlthXT17fTtyZXR1cm4gbS5lYWNoKGEubWF0Y2goRSl8fFtdLGZ1bmN0aW9uKGEsYyl7YltjXT0hMH0pLGJ9bS5DYWxsYmFja3M9ZnVuY3Rpb24oYSl7YT0ic3RyaW5nIj09dHlwZW9mIGE/RlthXXx8RyhhKTptLmV4dGVuZCh7fSxhKTt2YXIgYixjLGQsZSxmLGcsaD1bXSxpPSFhLm9uY2UmJltdLGo9ZnVuY3Rpb24obCl7Zm9yKGM9YS5tZW1vcnkmJmwsZD0hMCxmPWd8fDAsZz0wLGU9aC5sZW5ndGgsYj0hMDtoJiZlPmY7ZisrKWlmKGhbZl0uYXBwbHkobFswXSxsWzFdKT09PSExJiZhLnN0b3BPbkZhbHNlKXtjPSExO2JyZWFrfWI9ITEsaCYmKGk/aS5sZW5ndGgmJmooaS5zaGlmdCgpKTpjP2g9W106ay5kaXNhYmxlKCkpfSxrPXthZGQ6ZnVuY3Rpb24oKXtpZihoKXt2YXIgZD1oLmxlbmd0aDshZnVuY3Rpb24gZihiKXttLmVhY2goYixmdW5jdGlvbihiLGMpe3ZhciBkPW0udHlwZShjKTsiZnVuY3Rpb24iPT09ZD9hLnVuaXF1ZSYmay5oYXMoYyl8fGgucHVzaChjKTpjJiZjLmxlbmd0aCYmInN0cmluZyIhPT1kJiZmKGMpfSl9KGFyZ3VtZW50cyksYj9lPWgubGVuZ3RoOmMmJihnPWQsaihjKSl9cmV0dXJuIHRoaXN9LHJlbW92ZTpmdW5jdGlvbigpe3JldHVybiBoJiZtLmVhY2goYXJndW1lbnRzLGZ1bmN0aW9uKGEsYyl7dmFyIGQ7d2hpbGUoKGQ9bS5pbkFycmF5KGMsaCxkKSk+LTEpaC5zcGxpY2UoZCwxKSxiJiYoZT49ZCYmZS0tLGY+PWQmJmYtLSl9KSx0aGlzfSxoYXM6ZnVuY3Rpb24oYSl7cmV0dXJuIGE/bS5pbkFycmF5KGEsaCk+LTE6ISghaHx8IWgubGVuZ3RoKX0sZW1wdHk6ZnVuY3Rpb24oKXtyZXR1cm4gaD1bXSxlPTAsdGhpc30sZGlzYWJsZTpmdW5jdGlvbigpe3JldHVybiBoPWk9Yz12b2lkIDAsdGhpc30sZGlzYWJsZWQ6ZnVuY3Rpb24oKXtyZXR1cm4haH0sbG9jazpmdW5jdGlvbigpe3JldHVybiBpPXZvaWQgMCxjfHxrLmRpc2FibGUoKSx0aGlzfSxsb2NrZWQ6ZnVuY3Rpb24oKXtyZXR1cm4haX0sZmlyZVdpdGg6ZnVuY3Rpb24oYSxjKXtyZXR1cm4haHx8ZCYmIWl8fChjPWN8fFtdLGM9W2EsYy5zbGljZT9jLnNsaWNlKCk6Y10sYj9pLnB1c2goYyk6aihjKSksdGhpc30sZmlyZTpmdW5jdGlvbigpe3JldHVybiBrLmZpcmVXaXRoKHRoaXMsYXJndW1lbnRzKSx0aGlzfSxmaXJlZDpmdW5jdGlvbigpe3JldHVybiEhZH19O3JldHVybiBrfSxtLmV4dGVuZCh7RGVmZXJyZWQ6ZnVuY3Rpb24oYSl7dmFyIGI9W1sicmVzb2x2ZSIsImRvbmUiLG0uQ2FsbGJhY2tzKCJvbmNlIG1lbW9yeSIpLCJyZXNvbHZlZCJdLFsicmVqZWN0IiwiZmFpbCIsbS5DYWxsYmFja3MoIm9uY2UgbWVtb3J5IiksInJlamVjdGVkIl0sWyJub3RpZnkiLCJwcm9ncmVzcyIsbS5DYWxsYmFja3MoIm1lbW9yeSIpXV0sYz0icGVuZGluZyIsZD17c3RhdGU6ZnVuY3Rpb24oKXtyZXR1cm4gY30sYWx3YXlzOmZ1bmN0aW9uKCl7cmV0dXJuIGUuZG9uZShhcmd1bWVudHMpLmZhaWwoYXJndW1lbnRzKSx0aGlzfSx0aGVuOmZ1bmN0aW9uKCl7dmFyIGE9YXJndW1lbnRzO3JldHVybiBtLkRlZmVycmVkKGZ1bmN0aW9uKGMpe20uZWFjaChiLGZ1bmN0aW9uKGIsZil7dmFyIGc9bS5pc0Z1bmN0aW9uKGFbYl0pJiZhW2JdO2VbZlsxXV0oZnVuY3Rpb24oKXt2YXIgYT1nJiZnLmFwcGx5KHRoaXMsYXJndW1lbnRzKTthJiZtLmlzRnVuY3Rpb24oYS5wcm9taXNlKT9hLnByb21pc2UoKS5kb25lKGMucmVzb2x2ZSkuZmFpbChjLnJlamVjdCkucHJvZ3Jlc3MoYy5ub3RpZnkpOmNbZlswXSsiV2l0aCJdKHRoaXM9PT1kP2MucHJvbWlzZSgpOnRoaXMsZz9bYV06YXJndW1lbnRzKX0pfSksYT1udWxsfSkucHJvbWlzZSgpfSxwcm9taXNlOmZ1bmN0aW9uKGEpe3JldHVybiBudWxsIT1hP20uZXh0ZW5kKGEsZCk6ZH19LGU9e307cmV0dXJuIGQucGlwZT1kLnRoZW4sbS5lYWNoKGIsZnVuY3Rpb24oYSxmKXt2YXIgZz1mWzJdLGg9ZlszXTtkW2ZbMV1dPWcuYWRkLGgmJmcuYWRkKGZ1bmN0aW9uKCl7Yz1ofSxiWzFeYV1bMl0uZGlzYWJsZSxiWzJdWzJdLmxvY2spLGVbZlswXV09ZnVuY3Rpb24oKXtyZXR1cm4gZVtmWzBdKyJXaXRoIl0odGhpcz09PWU/ZDp0aGlzLGFyZ3VtZW50cyksdGhpc30sZVtmWzBdKyJXaXRoIl09Zy5maXJlV2l0aH0pLGQucHJvbWlzZShlKSxhJiZhLmNhbGwoZSxlKSxlfSx3aGVuOmZ1bmN0aW9uKGEpe3ZhciBiPTAsYz1kLmNhbGwoYXJndW1lbnRzKSxlPWMubGVuZ3RoLGY9MSE9PWV8fGEmJm0uaXNGdW5jdGlvbihhLnByb21pc2UpP2U6MCxnPTE9PT1mP2E6bS5EZWZlcnJlZCgpLGg9ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBmdW5jdGlvbihlKXtiW2FdPXRoaXMsY1thXT1hcmd1bWVudHMubGVuZ3RoPjE/ZC5jYWxsKGFyZ3VtZW50cyk6ZSxjPT09aT9nLm5vdGlmeVdpdGgoYixjKTotLWZ8fGcucmVzb2x2ZVdpdGgoYixjKX19LGksaixrO2lmKGU+MSlmb3IoaT1uZXcgQXJyYXkoZSksaj1uZXcgQXJyYXkoZSksaz1uZXcgQXJyYXkoZSk7ZT5iO2IrKyljW2JdJiZtLmlzRnVuY3Rpb24oY1tiXS5wcm9taXNlKT9jW2JdLnByb21pc2UoKS5kb25lKGgoYixrLGMpKS5mYWlsKGcucmVqZWN0KS5wcm9ncmVzcyhoKGIsaixpKSk6LS1mO3JldHVybiBmfHxnLnJlc29sdmVXaXRoKGssYyksZy5wcm9taXNlKCl9fSk7dmFyIEg7bS5mbi5yZWFkeT1mdW5jdGlvbihhKXtyZXR1cm4gbS5yZWFkeS5wcm9taXNlKCkuZG9uZShhKSx0aGlzfSxtLmV4dGVuZCh7aXNSZWFkeTohMSxyZWFkeVdhaXQ6MSxob2xkUmVhZHk6ZnVuY3Rpb24oYSl7YT9tLnJlYWR5V2FpdCsrOm0ucmVhZHkoITApfSxyZWFkeTpmdW5jdGlvbihhKXtpZihhPT09ITA/IS0tbS5yZWFkeVdhaXQ6IW0uaXNSZWFkeSl7aWYoIXkuYm9keSlyZXR1cm4gc2V0VGltZW91dChtLnJlYWR5KTttLmlzUmVhZHk9ITAsYSE9PSEwJiYtLW0ucmVhZHlXYWl0PjB8fChILnJlc29sdmVXaXRoKHksW21dKSxtLmZuLnRyaWdnZXJIYW5kbGVyJiYobSh5KS50cmlnZ2VySGFuZGxlcigicmVhZHkiKSxtKHkpLm9mZigicmVhZHkiKSkpfX19KTtmdW5jdGlvbiBJKCl7eS5hZGRFdmVudExpc3RlbmVyPyh5LnJlbW92ZUV2ZW50TGlzdGVuZXIoIkRPTUNvbnRlbnRMb2FkZWQiLEosITEpLGEucmVtb3ZlRXZlbnRMaXN0ZW5lcigibG9hZCIsSiwhMSkpOih5LmRldGFjaEV2ZW50KCJvbnJlYWR5c3RhdGVjaGFuZ2UiLEopLGEuZGV0YWNoRXZlbnQoIm9ubG9hZCIsSikpfWZ1bmN0aW9uIEooKXsoeS5hZGRFdmVudExpc3RlbmVyfHwibG9hZCI9PT1ldmVudC50eXBlfHwiY29tcGxldGUiPT09eS5yZWFkeVN0YXRlKSYmKEkoKSxtLnJlYWR5KCkpfW0ucmVhZHkucHJvbWlzZT1mdW5jdGlvbihiKXtpZighSClpZihIPW0uRGVmZXJyZWQoKSwiY29tcGxldGUiPT09eS5yZWFkeVN0YXRlKXNldFRpbWVvdXQobS5yZWFkeSk7ZWxzZSBpZih5LmFkZEV2ZW50TGlzdGVuZXIpeS5hZGRFdmVudExpc3RlbmVyKCJET01Db250ZW50TG9hZGVkIixKLCExKSxhLmFkZEV2ZW50TGlzdGVuZXIoImxvYWQiLEosITEpO2Vsc2V7eS5hdHRhY2hFdmVudCgib25yZWFkeXN0YXRlY2hhbmdlIixKKSxhLmF0dGFjaEV2ZW50KCJvbmxvYWQiLEopO3ZhciBjPSExO3RyeXtjPW51bGw9PWEuZnJhbWVFbGVtZW50JiZ5LmRvY3VtZW50RWxlbWVudH1jYXRjaChkKXt9YyYmYy5kb1Njcm9sbCYmIWZ1bmN0aW9uIGUoKXtpZighbS5pc1JlYWR5KXt0cnl7Yy5kb1Njcm9sbCgibGVmdCIpfWNhdGNoKGEpe3JldHVybiBzZXRUaW1lb3V0KGUsNTApfUkoKSxtLnJlYWR5KCl9fSgpfXJldHVybiBILnByb21pc2UoYil9O3ZhciBLPSJ1bmRlZmluZWQiLEw7Zm9yKEwgaW4gbShrKSlicmVhaztrLm93bkxhc3Q9IjAiIT09TCxrLmlubGluZUJsb2NrTmVlZHNMYXlvdXQ9ITEsbShmdW5jdGlvbigpe3ZhciBhLGIsYyxkO2M9eS5nZXRFbGVtZW50c0J5VGFnTmFtZSgiYm9keSIpWzBdLGMmJmMuc3R5bGUmJihiPXkuY3JlYXRlRWxlbWVudCgiZGl2IiksZD15LmNyZWF0ZUVsZW1lbnQoImRpdiIpLGQuc3R5bGUuY3NzVGV4dD0icG9zaXRpb246YWJzb2x1dGU7Ym9yZGVyOjA7d2lkdGg6MDtoZWlnaHQ6MDt0b3A6MDtsZWZ0Oi05OTk5cHgiLGMuYXBwZW5kQ2hpbGQoZCkuYXBwZW5kQ2hpbGQoYiksdHlwZW9mIGIuc3R5bGUuem9vbSE9PUsmJihiLnN0eWxlLmNzc1RleHQ9ImRpc3BsYXk6aW5saW5lO21hcmdpbjowO2JvcmRlcjowO3BhZGRpbmc6MXB4O3dpZHRoOjFweDt6b29tOjEiLGsuaW5saW5lQmxvY2tOZWVkc0xheW91dD1hPTM9PT1iLm9mZnNldFdpZHRoLGEmJihjLnN0eWxlLnpvb209MSkpLGMucmVtb3ZlQ2hpbGQoZCkpfSksZnVuY3Rpb24oKXt2YXIgYT15LmNyZWF0ZUVsZW1lbnQoImRpdiIpO2lmKG51bGw9PWsuZGVsZXRlRXhwYW5kbyl7ay5kZWxldGVFeHBhbmRvPSEwO3RyeXtkZWxldGUgYS50ZXN0fWNhdGNoKGIpe2suZGVsZXRlRXhwYW5kbz0hMX19YT1udWxsfSgpLG0uYWNjZXB0RGF0YT1mdW5jdGlvbihhKXt2YXIgYj1tLm5vRGF0YVsoYS5ub2RlTmFtZSsiICIpLnRvTG93ZXJDYXNlKCldLGM9K2Eubm9kZVR5cGV8fDE7cmV0dXJuIDEhPT1jJiY5IT09Yz8hMTohYnx8YiE9PSEwJiZhLmdldEF0dHJpYnV0ZSgiY2xhc3NpZCIpPT09Yn07dmFyIE09L14oPzpce1tcd1xXXSpcfXxcW1tcd1xXXSpcXSkkLyxOPS8oW0EtWl0pL2c7ZnVuY3Rpb24gTyhhLGIsYyl7aWYodm9pZCAwPT09YyYmMT09PWEubm9kZVR5cGUpe3ZhciBkPSJkYXRhLSIrYi5yZXBsYWNlKE4sIi0kMSIpLnRvTG93ZXJDYXNlKCk7aWYoYz1hLmdldEF0dHJpYnV0ZShkKSwic3RyaW5nIj09dHlwZW9mIGMpe3RyeXtjPSJ0cnVlIj09PWM/ITA6ImZhbHNlIj09PWM/ITE6Im51bGwiPT09Yz9udWxsOitjKyIiPT09Yz8rYzpNLnRlc3QoYyk/bS5wYXJzZUpTT04oYyk6Y31jYXRjaChlKXt9bS5kYXRhKGEsYixjKX1lbHNlIGM9dm9pZCAwfXJldHVybiBjfWZ1bmN0aW9uIFAoYSl7dmFyIGI7Zm9yKGIgaW4gYSlpZigoImRhdGEiIT09Ynx8IW0uaXNFbXB0eU9iamVjdChhW2JdKSkmJiJ0b0pTT04iIT09YilyZXR1cm4hMTtyZXR1cm4hMH1mdW5jdGlvbiBRKGEsYixkLGUpe2lmKG0uYWNjZXB0RGF0YShhKSl7dmFyIGYsZyxoPW0uZXhwYW5kbyxpPWEubm9kZVR5cGUsaj1pP20uY2FjaGU6YSxrPWk/YVtoXTphW2hdJiZoOwppZihrJiZqW2tdJiYoZXx8altrXS5kYXRhKXx8dm9pZCAwIT09ZHx8InN0cmluZyIhPXR5cGVvZiBiKXJldHVybiBrfHwoaz1pP2FbaF09Yy5wb3AoKXx8bS5ndWlkKys6aCksaltrXXx8KGpba109aT97fTp7dG9KU09OOm0ubm9vcH0pLCgib2JqZWN0Ij09dHlwZW9mIGJ8fCJmdW5jdGlvbiI9PXR5cGVvZiBiKSYmKGU/altrXT1tLmV4dGVuZChqW2tdLGIpOmpba10uZGF0YT1tLmV4dGVuZChqW2tdLmRhdGEsYikpLGc9altrXSxlfHwoZy5kYXRhfHwoZy5kYXRhPXt9KSxnPWcuZGF0YSksdm9pZCAwIT09ZCYmKGdbbS5jYW1lbENhc2UoYildPWQpLCJzdHJpbmciPT10eXBlb2YgYj8oZj1nW2JdLG51bGw9PWYmJihmPWdbbS5jYW1lbENhc2UoYildKSk6Zj1nLGZ9fWZ1bmN0aW9uIFIoYSxiLGMpe2lmKG0uYWNjZXB0RGF0YShhKSl7dmFyIGQsZSxmPWEubm9kZVR5cGUsZz1mP20uY2FjaGU6YSxoPWY/YVttLmV4cGFuZG9dOm0uZXhwYW5kbztpZihnW2hdKXtpZihiJiYoZD1jP2dbaF06Z1toXS5kYXRhKSl7bS5pc0FycmF5KGIpP2I9Yi5jb25jYXQobS5tYXAoYixtLmNhbWVsQ2FzZSkpOmIgaW4gZD9iPVtiXTooYj1tLmNhbWVsQ2FzZShiKSxiPWIgaW4gZD9bYl06Yi5zcGxpdCgiICIpKSxlPWIubGVuZ3RoO3doaWxlKGUtLSlkZWxldGUgZFtiW2VdXTtpZihjPyFQKGQpOiFtLmlzRW1wdHlPYmplY3QoZCkpcmV0dXJufShjfHwoZGVsZXRlIGdbaF0uZGF0YSxQKGdbaF0pKSkmJihmP20uY2xlYW5EYXRhKFthXSwhMCk6ay5kZWxldGVFeHBhbmRvfHxnIT1nLndpbmRvdz9kZWxldGUgZ1toXTpnW2hdPW51bGwpfX19bS5leHRlbmQoe2NhY2hlOnt9LG5vRGF0YTp7ImFwcGxldCAiOiEwLCJlbWJlZCAiOiEwLCJvYmplY3QgIjoiY2xzaWQ6RDI3Q0RCNkUtQUU2RC0xMWNmLTk2QjgtNDQ0NTUzNTQwMDAwIn0saGFzRGF0YTpmdW5jdGlvbihhKXtyZXR1cm4gYT1hLm5vZGVUeXBlP20uY2FjaGVbYVttLmV4cGFuZG9dXTphW20uZXhwYW5kb10sISFhJiYhUChhKX0sZGF0YTpmdW5jdGlvbihhLGIsYyl7cmV0dXJuIFEoYSxiLGMpfSxyZW1vdmVEYXRhOmZ1bmN0aW9uKGEsYil7cmV0dXJuIFIoYSxiKX0sX2RhdGE6ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBRKGEsYixjLCEwKX0sX3JlbW92ZURhdGE6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gUihhLGIsITApfX0pLG0uZm4uZXh0ZW5kKHtkYXRhOmZ1bmN0aW9uKGEsYil7dmFyIGMsZCxlLGY9dGhpc1swXSxnPWYmJmYuYXR0cmlidXRlcztpZih2b2lkIDA9PT1hKXtpZih0aGlzLmxlbmd0aCYmKGU9bS5kYXRhKGYpLDE9PT1mLm5vZGVUeXBlJiYhbS5fZGF0YShmLCJwYXJzZWRBdHRycyIpKSl7Yz1nLmxlbmd0aDt3aGlsZShjLS0pZ1tjXSYmKGQ9Z1tjXS5uYW1lLDA9PT1kLmluZGV4T2YoImRhdGEtIikmJihkPW0uY2FtZWxDYXNlKGQuc2xpY2UoNSkpLE8oZixkLGVbZF0pKSk7bS5fZGF0YShmLCJwYXJzZWRBdHRycyIsITApfXJldHVybiBlfXJldHVybiJvYmplY3QiPT10eXBlb2YgYT90aGlzLmVhY2goZnVuY3Rpb24oKXttLmRhdGEodGhpcyxhKX0pOmFyZ3VtZW50cy5sZW5ndGg+MT90aGlzLmVhY2goZnVuY3Rpb24oKXttLmRhdGEodGhpcyxhLGIpfSk6Zj9PKGYsYSxtLmRhdGEoZixhKSk6dm9pZCAwfSxyZW1vdmVEYXRhOmZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXttLnJlbW92ZURhdGEodGhpcyxhKX0pfX0pLG0uZXh0ZW5kKHtxdWV1ZTpmdW5jdGlvbihhLGIsYyl7dmFyIGQ7cmV0dXJuIGE/KGI9KGJ8fCJmeCIpKyJxdWV1ZSIsZD1tLl9kYXRhKGEsYiksYyYmKCFkfHxtLmlzQXJyYXkoYyk/ZD1tLl9kYXRhKGEsYixtLm1ha2VBcnJheShjKSk6ZC5wdXNoKGMpKSxkfHxbXSk6dm9pZCAwfSxkZXF1ZXVlOmZ1bmN0aW9uKGEsYil7Yj1ifHwiZngiO3ZhciBjPW0ucXVldWUoYSxiKSxkPWMubGVuZ3RoLGU9Yy5zaGlmdCgpLGY9bS5fcXVldWVIb29rcyhhLGIpLGc9ZnVuY3Rpb24oKXttLmRlcXVldWUoYSxiKX07ImlucHJvZ3Jlc3MiPT09ZSYmKGU9Yy5zaGlmdCgpLGQtLSksZSYmKCJmeCI9PT1iJiZjLnVuc2hpZnQoImlucHJvZ3Jlc3MiKSxkZWxldGUgZi5zdG9wLGUuY2FsbChhLGcsZikpLCFkJiZmJiZmLmVtcHR5LmZpcmUoKX0sX3F1ZXVlSG9va3M6ZnVuY3Rpb24oYSxiKXt2YXIgYz1iKyJxdWV1ZUhvb2tzIjtyZXR1cm4gbS5fZGF0YShhLGMpfHxtLl9kYXRhKGEsYyx7ZW1wdHk6bS5DYWxsYmFja3MoIm9uY2UgbWVtb3J5IikuYWRkKGZ1bmN0aW9uKCl7bS5fcmVtb3ZlRGF0YShhLGIrInF1ZXVlIiksbS5fcmVtb3ZlRGF0YShhLGMpfSl9KX19KSxtLmZuLmV4dGVuZCh7cXVldWU6ZnVuY3Rpb24oYSxiKXt2YXIgYz0yO3JldHVybiJzdHJpbmciIT10eXBlb2YgYSYmKGI9YSxhPSJmeCIsYy0tKSxhcmd1bWVudHMubGVuZ3RoPGM/bS5xdWV1ZSh0aGlzWzBdLGEpOnZvaWQgMD09PWI/dGhpczp0aGlzLmVhY2goZnVuY3Rpb24oKXt2YXIgYz1tLnF1ZXVlKHRoaXMsYSxiKTttLl9xdWV1ZUhvb2tzKHRoaXMsYSksImZ4Ij09PWEmJiJpbnByb2dyZXNzIiE9PWNbMF0mJm0uZGVxdWV1ZSh0aGlzLGEpfSl9LGRlcXVldWU6ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe20uZGVxdWV1ZSh0aGlzLGEpfSl9LGNsZWFyUXVldWU6ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMucXVldWUoYXx8ImZ4IixbXSl9LHByb21pc2U6ZnVuY3Rpb24oYSxiKXt2YXIgYyxkPTEsZT1tLkRlZmVycmVkKCksZj10aGlzLGc9dGhpcy5sZW5ndGgsaD1mdW5jdGlvbigpey0tZHx8ZS5yZXNvbHZlV2l0aChmLFtmXSl9OyJzdHJpbmciIT10eXBlb2YgYSYmKGI9YSxhPXZvaWQgMCksYT1hfHwiZngiO3doaWxlKGctLSljPW0uX2RhdGEoZltnXSxhKyJxdWV1ZUhvb2tzIiksYyYmYy5lbXB0eSYmKGQrKyxjLmVtcHR5LmFkZChoKSk7cmV0dXJuIGgoKSxlLnByb21pc2UoYil9fSk7dmFyIFM9L1srLV0/KD86XGQqXC58KVxkKyg/OltlRV1bKy1dP1xkK3wpLy5zb3VyY2UsVD1bIlRvcCIsIlJpZ2h0IiwiQm90dG9tIiwiTGVmdCJdLFU9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYT1ifHxhLCJub25lIj09PW0uY3NzKGEsImRpc3BsYXkiKXx8IW0uY29udGFpbnMoYS5vd25lckRvY3VtZW50LGEpfSxWPW0uYWNjZXNzPWZ1bmN0aW9uKGEsYixjLGQsZSxmLGcpe3ZhciBoPTAsaT1hLmxlbmd0aCxqPW51bGw9PWM7aWYoIm9iamVjdCI9PT1tLnR5cGUoYykpe2U9ITA7Zm9yKGggaW4gYyltLmFjY2VzcyhhLGIsaCxjW2hdLCEwLGYsZyl9ZWxzZSBpZih2b2lkIDAhPT1kJiYoZT0hMCxtLmlzRnVuY3Rpb24oZCl8fChnPSEwKSxqJiYoZz8oYi5jYWxsKGEsZCksYj1udWxsKTooaj1iLGI9ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBqLmNhbGwobShhKSxjKX0pKSxiKSlmb3IoO2k+aDtoKyspYihhW2hdLGMsZz9kOmQuY2FsbChhW2hdLGgsYihhW2hdLGMpKSk7cmV0dXJuIGU/YTpqP2IuY2FsbChhKTppP2IoYVswXSxjKTpmfSxXPS9eKD86Y2hlY2tib3h8cmFkaW8pJC9pOyFmdW5jdGlvbigpe3ZhciBhPXkuY3JlYXRlRWxlbWVudCgiaW5wdXQiKSxiPXkuY3JlYXRlRWxlbWVudCgiZGl2IiksYz15LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtpZihiLmlubmVySFRNTD0iICA8bGluay8+PHRhYmxlPjwvdGFibGU+PGEgaHJlZj0nL2EnPmE8L2E+PGlucHV0IHR5cGU9J2NoZWNrYm94Jy8+IixrLmxlYWRpbmdXaGl0ZXNwYWNlPTM9PT1iLmZpcnN0Q2hpbGQubm9kZVR5cGUsay50Ym9keT0hYi5nZXRFbGVtZW50c0J5VGFnTmFtZSgidGJvZHkiKS5sZW5ndGgsay5odG1sU2VyaWFsaXplPSEhYi5nZXRFbGVtZW50c0J5VGFnTmFtZSgibGluayIpLmxlbmd0aCxrLmh0bWw1Q2xvbmU9Ijw6bmF2PjwvOm5hdj4iIT09eS5jcmVhdGVFbGVtZW50KCJuYXYiKS5jbG9uZU5vZGUoITApLm91dGVySFRNTCxhLnR5cGU9ImNoZWNrYm94IixhLmNoZWNrZWQ9ITAsYy5hcHBlbmRDaGlsZChhKSxrLmFwcGVuZENoZWNrZWQ9YS5jaGVja2VkLGIuaW5uZXJIVE1MPSI8dGV4dGFyZWE+eDwvdGV4dGFyZWE+IixrLm5vQ2xvbmVDaGVja2VkPSEhYi5jbG9uZU5vZGUoITApLmxhc3RDaGlsZC5kZWZhdWx0VmFsdWUsYy5hcHBlbmRDaGlsZChiKSxiLmlubmVySFRNTD0iPGlucHV0IHR5cGU9J3JhZGlvJyBjaGVja2VkPSdjaGVja2VkJyBuYW1lPSd0Jy8+IixrLmNoZWNrQ2xvbmU9Yi5jbG9uZU5vZGUoITApLmNsb25lTm9kZSghMCkubGFzdENoaWxkLmNoZWNrZWQsay5ub0Nsb25lRXZlbnQ9ITAsYi5hdHRhY2hFdmVudCYmKGIuYXR0YWNoRXZlbnQoIm9uY2xpY2siLGZ1bmN0aW9uKCl7ay5ub0Nsb25lRXZlbnQ9ITF9KSxiLmNsb25lTm9kZSghMCkuY2xpY2soKSksbnVsbD09ay5kZWxldGVFeHBhbmRvKXtrLmRlbGV0ZUV4cGFuZG89ITA7dHJ5e2RlbGV0ZSBiLnRlc3R9Y2F0Y2goZCl7ay5kZWxldGVFeHBhbmRvPSExfX19KCksZnVuY3Rpb24oKXt2YXIgYixjLGQ9eS5jcmVhdGVFbGVtZW50KCJkaXYiKTtmb3IoYiBpbntzdWJtaXQ6ITAsY2hhbmdlOiEwLGZvY3VzaW46ITB9KWM9Im9uIitiLChrW2IrIkJ1YmJsZXMiXT1jIGluIGEpfHwoZC5zZXRBdHRyaWJ1dGUoYywidCIpLGtbYisiQnViYmxlcyJdPWQuYXR0cmlidXRlc1tjXS5leHBhbmRvPT09ITEpO2Q9bnVsbH0oKTt2YXIgWD0vXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYSkkL2ksWT0vXmtleS8sWj0vXig/Om1vdXNlfHBvaW50ZXJ8Y29udGV4dG1lbnUpfGNsaWNrLywkPS9eKD86Zm9jdXNpbmZvY3VzfGZvY3Vzb3V0Ymx1cikkLyxfPS9eKFteLl0qKSg/OlwuKC4rKXwpJC87ZnVuY3Rpb24gYWIoKXtyZXR1cm4hMH1mdW5jdGlvbiBiYigpe3JldHVybiExfWZ1bmN0aW9uIGNiKCl7dHJ5e3JldHVybiB5LmFjdGl2ZUVsZW1lbnR9Y2F0Y2goYSl7fX1tLmV2ZW50PXtnbG9iYWw6e30sYWRkOmZ1bmN0aW9uKGEsYixjLGQsZSl7dmFyIGYsZyxoLGksaixrLGwsbixvLHAscSxyPW0uX2RhdGEoYSk7aWYocil7Yy5oYW5kbGVyJiYoaT1jLGM9aS5oYW5kbGVyLGU9aS5zZWxlY3RvciksYy5ndWlkfHwoYy5ndWlkPW0uZ3VpZCsrKSwoZz1yLmV2ZW50cyl8fChnPXIuZXZlbnRzPXt9KSwoaz1yLmhhbmRsZSl8fChrPXIuaGFuZGxlPWZ1bmN0aW9uKGEpe3JldHVybiB0eXBlb2YgbT09PUt8fGEmJm0uZXZlbnQudHJpZ2dlcmVkPT09YS50eXBlP3ZvaWQgMDptLmV2ZW50LmRpc3BhdGNoLmFwcGx5KGsuZWxlbSxhcmd1bWVudHMpfSxrLmVsZW09YSksYj0oYnx8IiIpLm1hdGNoKEUpfHxbIiJdLGg9Yi5sZW5ndGg7d2hpbGUoaC0tKWY9Xy5leGVjKGJbaF0pfHxbXSxvPXE9ZlsxXSxwPShmWzJdfHwiIikuc3BsaXQoIi4iKS5zb3J0KCksbyYmKGo9bS5ldmVudC5zcGVjaWFsW29dfHx7fSxvPShlP2ouZGVsZWdhdGVUeXBlOmouYmluZFR5cGUpfHxvLGo9bS5ldmVudC5zcGVjaWFsW29dfHx7fSxsPW0uZXh0ZW5kKHt0eXBlOm8sb3JpZ1R5cGU6cSxkYXRhOmQsaGFuZGxlcjpjLGd1aWQ6Yy5ndWlkLHNlbGVjdG9yOmUsbmVlZHNDb250ZXh0OmUmJm0uZXhwci5tYXRjaC5uZWVkc0NvbnRleHQudGVzdChlKSxuYW1lc3BhY2U6cC5qb2luKCIuIil9LGkpLChuPWdbb10pfHwobj1nW29dPVtdLG4uZGVsZWdhdGVDb3VudD0wLGouc2V0dXAmJmouc2V0dXAuY2FsbChhLGQscCxrKSE9PSExfHwoYS5hZGRFdmVudExpc3RlbmVyP2EuYWRkRXZlbnRMaXN0ZW5lcihvLGssITEpOmEuYXR0YWNoRXZlbnQmJmEuYXR0YWNoRXZlbnQoIm9uIitvLGspKSksai5hZGQmJihqLmFkZC5jYWxsKGEsbCksbC5oYW5kbGVyLmd1aWR8fChsLmhhbmRsZXIuZ3VpZD1jLmd1aWQpKSxlP24uc3BsaWNlKG4uZGVsZWdhdGVDb3VudCsrLDAsbCk6bi5wdXNoKGwpLG0uZXZlbnQuZ2xvYmFsW29dPSEwKTthPW51bGx9fSxyZW1vdmU6ZnVuY3Rpb24oYSxiLGMsZCxlKXt2YXIgZixnLGgsaSxqLGssbCxuLG8scCxxLHI9bS5oYXNEYXRhKGEpJiZtLl9kYXRhKGEpO2lmKHImJihrPXIuZXZlbnRzKSl7Yj0oYnx8IiIpLm1hdGNoKEUpfHxbIiJdLGo9Yi5sZW5ndGg7d2hpbGUoai0tKWlmKGg9Xy5leGVjKGJbal0pfHxbXSxvPXE9aFsxXSxwPShoWzJdfHwiIikuc3BsaXQoIi4iKS5zb3J0KCksbyl7bD1tLmV2ZW50LnNwZWNpYWxbb118fHt9LG89KGQ/bC5kZWxlZ2F0ZVR5cGU6bC5iaW5kVHlwZSl8fG8sbj1rW29dfHxbXSxoPWhbMl0mJm5ldyBSZWdFeHAoIihefFxcLikiK3Auam9pbigiXFwuKD86LipcXC58KSIpKyIoXFwufCQpIiksaT1mPW4ubGVuZ3RoO3doaWxlKGYtLSlnPW5bZl0sIWUmJnEhPT1nLm9yaWdUeXBlfHxjJiZjLmd1aWQhPT1nLmd1aWR8fGgmJiFoLnRlc3QoZy5uYW1lc3BhY2UpfHxkJiZkIT09Zy5zZWxlY3RvciYmKCIqKiIhPT1kfHwhZy5zZWxlY3Rvcil8fChuLnNwbGljZShmLDEpLGcuc2VsZWN0b3ImJm4uZGVsZWdhdGVDb3VudC0tLGwucmVtb3ZlJiZsLnJlbW92ZS5jYWxsKGEsZykpO2kmJiFuLmxlbmd0aCYmKGwudGVhcmRvd24mJmwudGVhcmRvd24uY2FsbChhLHAsci5oYW5kbGUpIT09ITF8fG0ucmVtb3ZlRXZlbnQoYSxvLHIuaGFuZGxlKSxkZWxldGUga1tvXSl9ZWxzZSBmb3IobyBpbiBrKW0uZXZlbnQucmVtb3ZlKGEsbytiW2pdLGMsZCwhMCk7bS5pc0VtcHR5T2JqZWN0KGspJiYoZGVsZXRlIHIuaGFuZGxlLG0uX3JlbW92ZURhdGEoYSwiZXZlbnRzIikpfX0sdHJpZ2dlcjpmdW5jdGlvbihiLGMsZCxlKXt2YXIgZixnLGgsaSxrLGwsbixvPVtkfHx5XSxwPWouY2FsbChiLCJ0eXBlIik/Yi50eXBlOmIscT1qLmNhbGwoYiwibmFtZXNwYWNlIik/Yi5uYW1lc3BhY2Uuc3BsaXQoIi4iKTpbXTtpZihoPWw9ZD1kfHx5LDMhPT1kLm5vZGVUeXBlJiY4IT09ZC5ub2RlVHlwZSYmISQudGVzdChwK20uZXZlbnQudHJpZ2dlcmVkKSYmKHAuaW5kZXhPZigiLiIpPj0wJiYocT1wLnNwbGl0KCIuIikscD1xLnNoaWZ0KCkscS5zb3J0KCkpLGc9cC5pbmRleE9mKCI6Iik8MCYmIm9uIitwLGI9YlttLmV4cGFuZG9dP2I6bmV3IG0uRXZlbnQocCwib2JqZWN0Ij09dHlwZW9mIGImJmIpLGIuaXNUcmlnZ2VyPWU/MjozLGIubmFtZXNwYWNlPXEuam9pbigiLiIpLGIubmFtZXNwYWNlX3JlPWIubmFtZXNwYWNlP25ldyBSZWdFeHAoIihefFxcLikiK3Euam9pbigiXFwuKD86LipcXC58KSIpKyIoXFwufCQpIik6bnVsbCxiLnJlc3VsdD12b2lkIDAsYi50YXJnZXR8fChiLnRhcmdldD1kKSxjPW51bGw9PWM/W2JdOm0ubWFrZUFycmF5KGMsW2JdKSxrPW0uZXZlbnQuc3BlY2lhbFtwXXx8e30sZXx8IWsudHJpZ2dlcnx8ay50cmlnZ2VyLmFwcGx5KGQsYykhPT0hMSkpe2lmKCFlJiYhay5ub0J1YmJsZSYmIW0uaXNXaW5kb3coZCkpe2ZvcihpPWsuZGVsZWdhdGVUeXBlfHxwLCQudGVzdChpK3ApfHwoaD1oLnBhcmVudE5vZGUpO2g7aD1oLnBhcmVudE5vZGUpby5wdXNoKGgpLGw9aDtsPT09KGQub3duZXJEb2N1bWVudHx8eSkmJm8ucHVzaChsLmRlZmF1bHRWaWV3fHxsLnBhcmVudFdpbmRvd3x8YSl9bj0wO3doaWxlKChoPW9bbisrXSkmJiFiLmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpYi50eXBlPW4+MT9pOmsuYmluZFR5cGV8fHAsZj0obS5fZGF0YShoLCJldmVudHMiKXx8e30pW2IudHlwZV0mJm0uX2RhdGEoaCwiaGFuZGxlIiksZiYmZi5hcHBseShoLGMpLGY9ZyYmaFtnXSxmJiZmLmFwcGx5JiZtLmFjY2VwdERhdGEoaCkmJihiLnJlc3VsdD1mLmFwcGx5KGgsYyksYi5yZXN1bHQ9PT0hMSYmYi5wcmV2ZW50RGVmYXVsdCgpKTtpZihiLnR5cGU9cCwhZSYmIWIuaXNEZWZhdWx0UHJldmVudGVkKCkmJighay5fZGVmYXVsdHx8ay5fZGVmYXVsdC5hcHBseShvLnBvcCgpLGMpPT09ITEpJiZtLmFjY2VwdERhdGEoZCkmJmcmJmRbcF0mJiFtLmlzV2luZG93KGQpKXtsPWRbZ10sbCYmKGRbZ109bnVsbCksbS5ldmVudC50cmlnZ2VyZWQ9cDt0cnl7ZFtwXSgpfWNhdGNoKHIpe31tLmV2ZW50LnRyaWdnZXJlZD12b2lkIDAsbCYmKGRbZ109bCl9cmV0dXJuIGIucmVzdWx0fX0sZGlzcGF0Y2g6ZnVuY3Rpb24oYSl7YT1tLmV2ZW50LmZpeChhKTt2YXIgYixjLGUsZixnLGg9W10saT1kLmNhbGwoYXJndW1lbnRzKSxqPShtLl9kYXRhKHRoaXMsImV2ZW50cyIpfHx7fSlbYS50eXBlXXx8W10saz1tLmV2ZW50LnNwZWNpYWxbYS50eXBlXXx8e307aWYoaVswXT1hLGEuZGVsZWdhdGVUYXJnZXQ9dGhpcywhay5wcmVEaXNwYXRjaHx8ay5wcmVEaXNwYXRjaC5jYWxsKHRoaXMsYSkhPT0hMSl7aD1tLmV2ZW50LmhhbmRsZXJzLmNhbGwodGhpcyxhLGopLGI9MDt3aGlsZSgoZj1oW2IrK10pJiYhYS5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKXthLmN1cnJlbnRUYXJnZXQ9Zi5lbGVtLGc9MDt3aGlsZSgoZT1mLmhhbmRsZXJzW2crK10pJiYhYS5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpKSghYS5uYW1lc3BhY2VfcmV8fGEubmFtZXNwYWNlX3JlLnRlc3QoZS5uYW1lc3BhY2UpKSYmKGEuaGFuZGxlT2JqPWUsYS5kYXRhPWUuZGF0YSxjPSgobS5ldmVudC5zcGVjaWFsW2Uub3JpZ1R5cGVdfHx7fSkuaGFuZGxlfHxlLmhhbmRsZXIpLmFwcGx5KGYuZWxlbSxpKSx2b2lkIDAhPT1jJiYoYS5yZXN1bHQ9Yyk9PT0hMSYmKGEucHJldmVudERlZmF1bHQoKSxhLnN0b3BQcm9wYWdhdGlvbigpKSl9cmV0dXJuIGsucG9zdERpc3BhdGNoJiZrLnBvc3REaXNwYXRjaC5jYWxsKHRoaXMsYSksYS5yZXN1bHR9fSxoYW5kbGVyczpmdW5jdGlvbihhLGIpe3ZhciBjLGQsZSxmLGc9W10saD1iLmRlbGVnYXRlQ291bnQsaT1hLnRhcmdldDtpZihoJiZpLm5vZGVUeXBlJiYoIWEuYnV0dG9ufHwiY2xpY2siIT09YS50eXBlKSlmb3IoO2khPXRoaXM7aT1pLnBhcmVudE5vZGV8fHRoaXMpaWYoMT09PWkubm9kZVR5cGUmJihpLmRpc2FibGVkIT09ITB8fCJjbGljayIhPT1hLnR5cGUpKXtmb3IoZT1bXSxmPTA7aD5mO2YrKylkPWJbZl0sYz1kLnNlbGVjdG9yKyIgIix2b2lkIDA9PT1lW2NdJiYoZVtjXT1kLm5lZWRzQ29udGV4dD9tKGMsdGhpcykuaW5kZXgoaSk+PTA6bS5maW5kKGMsdGhpcyxudWxsLFtpXSkubGVuZ3RoKSxlW2NdJiZlLnB1c2goZCk7ZS5sZW5ndGgmJmcucHVzaCh7ZWxlbTppLGhhbmRsZXJzOmV9KX1yZXR1cm4gaDxiLmxlbmd0aCYmZy5wdXNoKHtlbGVtOnRoaXMsaGFuZGxlcnM6Yi5zbGljZShoKX0pLGd9LGZpeDpmdW5jdGlvbihhKXtpZihhW20uZXhwYW5kb10pcmV0dXJuIGE7dmFyIGIsYyxkLGU9YS50eXBlLGY9YSxnPXRoaXMuZml4SG9va3NbZV07Z3x8KHRoaXMuZml4SG9va3NbZV09Zz1aLnRlc3QoZSk/dGhpcy5tb3VzZUhvb2tzOlkudGVzdChlKT90aGlzLmtleUhvb2tzOnt9KSxkPWcucHJvcHM/dGhpcy5wcm9wcy5jb25jYXQoZy5wcm9wcyk6dGhpcy5wcm9wcyxhPW5ldyBtLkV2ZW50KGYpLGI9ZC5sZW5ndGg7d2hpbGUoYi0tKWM9ZFtiXSxhW2NdPWZbY107cmV0dXJuIGEudGFyZ2V0fHwoYS50YXJnZXQ9Zi5zcmNFbGVtZW50fHx5KSwzPT09YS50YXJnZXQubm9kZVR5cGUmJihhLnRhcmdldD1hLnRhcmdldC5wYXJlbnROb2RlKSxhLm1ldGFLZXk9ISFhLm1ldGFLZXksZy5maWx0ZXI/Zy5maWx0ZXIoYSxmKTphfSxwcm9wczoiYWx0S2V5IGJ1YmJsZXMgY2FuY2VsYWJsZSBjdHJsS2V5IGN1cnJlbnRUYXJnZXQgZXZlbnRQaGFzZSBtZXRhS2V5IHJlbGF0ZWRUYXJnZXQgc2hpZnRLZXkgdGFyZ2V0IHRpbWVTdGFtcCB2aWV3IHdoaWNoIi5zcGxpdCgiICIpLGZpeEhvb2tzOnt9LGtleUhvb2tzOntwcm9wczoiY2hhciBjaGFyQ29kZSBrZXkga2V5Q29kZSIuc3BsaXQoIiAiKSxmaWx0ZXI6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gbnVsbD09YS53aGljaCYmKGEud2hpY2g9bnVsbCE9Yi5jaGFyQ29kZT9iLmNoYXJDb2RlOmIua2V5Q29kZSksYX19LG1vdXNlSG9va3M6e3Byb3BzOiJidXR0b24gYnV0dG9ucyBjbGllbnRYIGNsaWVudFkgZnJvbUVsZW1lbnQgb2Zmc2V0WCBvZmZzZXRZIHBhZ2VYIHBhZ2VZIHNjcmVlblggc2NyZWVuWSB0b0VsZW1lbnQiLnNwbGl0KCIgIiksZmlsdGVyOmZ1bmN0aW9uKGEsYil7dmFyIGMsZCxlLGY9Yi5idXR0b24sZz1iLmZyb21FbGVtZW50O3JldHVybiBudWxsPT1hLnBhZ2VYJiZudWxsIT1iLmNsaWVudFgmJihkPWEudGFyZ2V0Lm93bmVyRG9jdW1lbnR8fHksZT1kLmRvY3VtZW50RWxlbWVudCxjPWQuYm9keSxhLnBhZ2VYPWIuY2xpZW50WCsoZSYmZS5zY3JvbGxMZWZ0fHxjJiZjLnNjcm9sbExlZnR8fDApLShlJiZlLmNsaWVudExlZnR8fGMmJmMuY2xpZW50TGVmdHx8MCksYS5wYWdlWT1iLmNsaWVudFkrKGUmJmUuc2Nyb2xsVG9wfHxjJiZjLnNjcm9sbFRvcHx8MCktKGUmJmUuY2xpZW50VG9wfHxjJiZjLmNsaWVudFRvcHx8MCkpLCFhLnJlbGF0ZWRUYXJnZXQmJmcmJihhLnJlbGF0ZWRUYXJnZXQ9Zz09PWEudGFyZ2V0P2IudG9FbGVtZW50OmcpLGEud2hpY2h8fHZvaWQgMD09PWZ8fChhLndoaWNoPTEmZj8xOjImZj8zOjQmZj8yOjApLGF9fSxzcGVjaWFsOntsb2FkOntub0J1YmJsZTohMH0sZm9jdXM6e3RyaWdnZXI6ZnVuY3Rpb24oKXtpZih0aGlzIT09Y2IoKSYmdGhpcy5mb2N1cyl0cnl7cmV0dXJuIHRoaXMuZm9jdXMoKSwhMX1jYXRjaChhKXt9fSxkZWxlZ2F0ZVR5cGU6ImZvY3VzaW4ifSxibHVyOnt0cmlnZ2VyOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXM9PT1jYigpJiZ0aGlzLmJsdXI/KHRoaXMuYmx1cigpLCExKTp2b2lkIDB9LGRlbGVnYXRlVHlwZToiZm9jdXNvdXQifSxjbGljazp7dHJpZ2dlcjpmdW5jdGlvbigpe3JldHVybiBtLm5vZGVOYW1lKHRoaXMsImlucHV0IikmJiJjaGVja2JveCI9PT10aGlzLnR5cGUmJnRoaXMuY2xpY2s/KHRoaXMuY2xpY2soKSwhMSk6dm9pZCAwfSxfZGVmYXVsdDpmdW5jdGlvbihhKXtyZXR1cm4gbS5ub2RlTmFtZShhLnRhcmdldCwiYSIpfX0sYmVmb3JldW5sb2FkOntwb3N0RGlzcGF0Y2g6ZnVuY3Rpb24oYSl7dm9pZCAwIT09YS5yZXN1bHQmJmEub3JpZ2luYWxFdmVudCYmKGEub3JpZ2luYWxFdmVudC5yZXR1cm5WYWx1ZT1hLnJlc3VsdCl9fX0sc2ltdWxhdGU6ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9bS5leHRlbmQobmV3IG0uRXZlbnQsYyx7dHlwZTphLGlzU2ltdWxhdGVkOiEwLG9yaWdpbmFsRXZlbnQ6e319KTtkP20uZXZlbnQudHJpZ2dlcihlLG51bGwsYik6bS5ldmVudC5kaXNwYXRjaC5jYWxsKGIsZSksZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSYmYy5wcmV2ZW50RGVmYXVsdCgpfX0sbS5yZW1vdmVFdmVudD15LnJlbW92ZUV2ZW50TGlzdGVuZXI/ZnVuY3Rpb24oYSxiLGMpe2EucmVtb3ZlRXZlbnRMaXN0ZW5lciYmYS5yZW1vdmVFdmVudExpc3RlbmVyKGIsYywhMSl9OmZ1bmN0aW9uKGEsYixjKXt2YXIgZD0ib24iK2I7YS5kZXRhY2hFdmVudCYmKHR5cGVvZiBhW2RdPT09SyYmKGFbZF09bnVsbCksYS5kZXRhY2hFdmVudChkLGMpKX0sbS5FdmVudD1mdW5jdGlvbihhLGIpe3JldHVybiB0aGlzIGluc3RhbmNlb2YgbS5FdmVudD8oYSYmYS50eXBlPyh0aGlzLm9yaWdpbmFsRXZlbnQ9YSx0aGlzLnR5cGU9YS50eXBlLHRoaXMuaXNEZWZhdWx0UHJldmVudGVkPWEuZGVmYXVsdFByZXZlbnRlZHx8dm9pZCAwPT09YS5kZWZhdWx0UHJldmVudGVkJiZhLnJldHVyblZhbHVlPT09ITE/YWI6YmIpOnRoaXMudHlwZT1hLGImJm0uZXh0ZW5kKHRoaXMsYiksdGhpcy50aW1lU3RhbXA9YSYmYS50aW1lU3RhbXB8fG0ubm93KCksdm9pZCh0aGlzW20uZXhwYW5kb109ITApKTpuZXcgbS5FdmVudChhLGIpfSxtLkV2ZW50LnByb3RvdHlwZT17aXNEZWZhdWx0UHJldmVudGVkOmJiLGlzUHJvcGFnYXRpb25TdG9wcGVkOmJiLGlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOmJiLHByZXZlbnREZWZhdWx0OmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5vcmlnaW5hbEV2ZW50O3RoaXMuaXNEZWZhdWx0UHJldmVudGVkPWFiLGEmJihhLnByZXZlbnREZWZhdWx0P2EucHJldmVudERlZmF1bHQoKTphLnJldHVyblZhbHVlPSExKX0sc3RvcFByb3BhZ2F0aW9uOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5vcmlnaW5hbEV2ZW50O3RoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQ9YWIsYSYmKGEuc3RvcFByb3BhZ2F0aW9uJiZhLnN0b3BQcm9wYWdhdGlvbigpLGEuY2FuY2VsQnViYmxlPSEwKX0sc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5vcmlnaW5hbEV2ZW50O3RoaXMuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ9YWIsYSYmYS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24mJmEuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCksdGhpcy5zdG9wUHJvcGFnYXRpb24oKX19LG0uZWFjaCh7bW91c2VlbnRlcjoibW91c2VvdmVyIixtb3VzZWxlYXZlOiJtb3VzZW91dCIscG9pbnRlcmVudGVyOiJwb2ludGVyb3ZlciIscG9pbnRlcmxlYXZlOiJwb2ludGVyb3V0In0sZnVuY3Rpb24oYSxiKXttLmV2ZW50LnNwZWNpYWxbYV09e2RlbGVnYXRlVHlwZTpiLGJpbmRUeXBlOmIsaGFuZGxlOmZ1bmN0aW9uKGEpe3ZhciBjLGQ9dGhpcyxlPWEucmVsYXRlZFRhcmdldCxmPWEuaGFuZGxlT2JqO3JldHVybighZXx8ZSE9PWQmJiFtLmNvbnRhaW5zKGQsZSkpJiYoYS50eXBlPWYub3JpZ1R5cGUsYz1mLmhhbmRsZXIuYXBwbHkodGhpcyxhcmd1bWVudHMpLGEudHlwZT1iKSxjfX19KSxrLnN1Ym1pdEJ1YmJsZXN8fChtLmV2ZW50LnNwZWNpYWwuc3VibWl0PXtzZXR1cDpmdW5jdGlvbigpe3JldHVybiBtLm5vZGVOYW1lKHRoaXMsImZvcm0iKT8hMTp2b2lkIG0uZXZlbnQuYWRkKHRoaXMsImNsaWNrLl9zdWJtaXQga2V5cHJlc3MuX3N1Ym1pdCIsZnVuY3Rpb24oYSl7dmFyIGI9YS50YXJnZXQsYz1tLm5vZGVOYW1lKGIsImlucHV0Iil8fG0ubm9kZU5hbWUoYiwiYnV0dG9uIik/Yi5mb3JtOnZvaWQgMDtjJiYhbS5fZGF0YShjLCJzdWJtaXRCdWJibGVzIikmJihtLmV2ZW50LmFkZChjLCJzdWJtaXQuX3N1Ym1pdCIsZnVuY3Rpb24oYSl7YS5fc3VibWl0X2J1YmJsZT0hMH0pLG0uX2RhdGEoYywic3VibWl0QnViYmxlcyIsITApKX0pfSxwb3N0RGlzcGF0Y2g6ZnVuY3Rpb24oYSl7YS5fc3VibWl0X2J1YmJsZSYmKGRlbGV0ZSBhLl9zdWJtaXRfYnViYmxlLHRoaXMucGFyZW50Tm9kZSYmIWEuaXNUcmlnZ2VyJiZtLmV2ZW50LnNpbXVsYXRlKCJzdWJtaXQiLHRoaXMucGFyZW50Tm9kZSxhLCEwKSl9LHRlYXJkb3duOmZ1bmN0aW9uKCl7cmV0dXJuIG0ubm9kZU5hbWUodGhpcywiZm9ybSIpPyExOnZvaWQgbS5ldmVudC5yZW1vdmUodGhpcywiLl9zdWJtaXQiKX19KSxrLmNoYW5nZUJ1YmJsZXN8fChtLmV2ZW50LnNwZWNpYWwuY2hhbmdlPXtzZXR1cDpmdW5jdGlvbigpe3JldHVybiBYLnRlc3QodGhpcy5ub2RlTmFtZSk/KCgiY2hlY2tib3giPT09dGhpcy50eXBlfHwicmFkaW8iPT09dGhpcy50eXBlKSYmKG0uZXZlbnQuYWRkKHRoaXMsInByb3BlcnR5Y2hhbmdlLl9jaGFuZ2UiLGZ1bmN0aW9uKGEpeyJjaGVja2VkIj09PWEub3JpZ2luYWxFdmVudC5wcm9wZXJ0eU5hbWUmJih0aGlzLl9qdXN0X2NoYW5nZWQ9ITApfSksbS5ldmVudC5hZGQodGhpcywiY2xpY2suX2NoYW5nZSIsZnVuY3Rpb24oYSl7dGhpcy5fanVzdF9jaGFuZ2VkJiYhYS5pc1RyaWdnZXImJih0aGlzLl9qdXN0X2NoYW5nZWQ9ITEpLG0uZXZlbnQuc2ltdWxhdGUoImNoYW5nZSIsdGhpcyxhLCEwKX0pKSwhMSk6dm9pZCBtLmV2ZW50LmFkZCh0aGlzLCJiZWZvcmVhY3RpdmF0ZS5fY2hhbmdlIixmdW5jdGlvbihhKXt2YXIgYj1hLnRhcmdldDtYLnRlc3QoYi5ub2RlTmFtZSkmJiFtLl9kYXRhKGIsImNoYW5nZUJ1YmJsZXMiKSYmKG0uZXZlbnQuYWRkKGIsImNoYW5nZS5fY2hhbmdlIixmdW5jdGlvbihhKXshdGhpcy5wYXJlbnROb2RlfHxhLmlzU2ltdWxhdGVkfHxhLmlzVHJpZ2dlcnx8bS5ldmVudC5zaW11bGF0ZSgiY2hhbmdlIix0aGlzLnBhcmVudE5vZGUsYSwhMCl9KSxtLl9kYXRhKGIsImNoYW5nZUJ1YmJsZXMiLCEwKSl9KX0saGFuZGxlOmZ1bmN0aW9uKGEpe3ZhciBiPWEudGFyZ2V0O3JldHVybiB0aGlzIT09Ynx8YS5pc1NpbXVsYXRlZHx8YS5pc1RyaWdnZXJ8fCJyYWRpbyIhPT1iLnR5cGUmJiJjaGVja2JveCIhPT1iLnR5cGU/YS5oYW5kbGVPYmouaGFuZGxlci5hcHBseSh0aGlzLGFyZ3VtZW50cyk6dm9pZCAwfSx0ZWFyZG93bjpmdW5jdGlvbigpe3JldHVybiBtLmV2ZW50LnJlbW92ZSh0aGlzLCIuX2NoYW5nZSIpLCFYLnRlc3QodGhpcy5ub2RlTmFtZSl9fSksay5mb2N1c2luQnViYmxlc3x8bS5lYWNoKHtmb2N1czoiZm9jdXNpbiIsYmx1cjoiZm9jdXNvdXQifSxmdW5jdGlvbihhLGIpe3ZhciBjPWZ1bmN0aW9uKGEpe20uZXZlbnQuc2ltdWxhdGUoYixhLnRhcmdldCxtLmV2ZW50LmZpeChhKSwhMCl9O20uZXZlbnQuc3BlY2lhbFtiXT17c2V0dXA6ZnVuY3Rpb24oKXt2YXIgZD10aGlzLm93bmVyRG9jdW1lbnR8fHRoaXMsZT1tLl9kYXRhKGQsYik7ZXx8ZC5hZGRFdmVudExpc3RlbmVyKGEsYywhMCksbS5fZGF0YShkLGIsKGV8fDApKzEpfSx0ZWFyZG93bjpmdW5jdGlvbigpe3ZhciBkPXRoaXMub3duZXJEb2N1bWVudHx8dGhpcyxlPW0uX2RhdGEoZCxiKS0xO2U/bS5fZGF0YShkLGIsZSk6KGQucmVtb3ZlRXZlbnRMaXN0ZW5lcihhLGMsITApLG0uX3JlbW92ZURhdGEoZCxiKSl9fX0pLG0uZm4uZXh0ZW5kKHtvbjpmdW5jdGlvbihhLGIsYyxkLGUpe3ZhciBmLGc7aWYoIm9iamVjdCI9PXR5cGVvZiBhKXsic3RyaW5nIiE9dHlwZW9mIGImJihjPWN8fGIsYj12b2lkIDApO2ZvcihmIGluIGEpdGhpcy5vbihmLGIsYyxhW2ZdLGUpO3JldHVybiB0aGlzfWlmKG51bGw9PWMmJm51bGw9PWQ/KGQ9YixjPWI9dm9pZCAwKTpudWxsPT1kJiYoInN0cmluZyI9PXR5cGVvZiBiPyhkPWMsYz12b2lkIDApOihkPWMsYz1iLGI9dm9pZCAwKSksZD09PSExKWQ9YmI7ZWxzZSBpZighZClyZXR1cm4gdGhpcztyZXR1cm4gMT09PWUmJihnPWQsZD1mdW5jdGlvbihhKXtyZXR1cm4gbSgpLm9mZihhKSxnLmFwcGx5KHRoaXMsYXJndW1lbnRzKX0sZC5ndWlkPWcuZ3VpZHx8KGcuZ3VpZD1tLmd1aWQrKykpLHRoaXMuZWFjaChmdW5jdGlvbigpe20uZXZlbnQuYWRkKHRoaXMsYSxkLGMsYil9KX0sb25lOmZ1bmN0aW9uKGEsYixjLGQpe3JldHVybiB0aGlzLm9uKGEsYixjLGQsMSl9LG9mZjpmdW5jdGlvbihhLGIsYyl7dmFyIGQsZTtpZihhJiZhLnByZXZlbnREZWZhdWx0JiZhLmhhbmRsZU9iailyZXR1cm4gZD1hLmhhbmRsZU9iaixtKGEuZGVsZWdhdGVUYXJnZXQpLm9mZihkLm5hbWVzcGFjZT9kLm9yaWdUeXBlKyIuIitkLm5hbWVzcGFjZTpkLm9yaWdUeXBlLGQuc2VsZWN0b3IsZC5oYW5kbGVyKSx0aGlzO2lmKCJvYmplY3QiPT10eXBlb2YgYSl7Zm9yKGUgaW4gYSl0aGlzLm9mZihlLGIsYVtlXSk7cmV0dXJuIHRoaXN9cmV0dXJuKGI9PT0hMXx8ImZ1bmN0aW9uIj09dHlwZW9mIGIpJiYoYz1iLGI9dm9pZCAwKSxjPT09ITEmJihjPWJiKSx0aGlzLmVhY2goZnVuY3Rpb24oKXttLmV2ZW50LnJlbW92ZSh0aGlzLGEsYyxiKX0pfSx0cmlnZ2VyOmZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe20uZXZlbnQudHJpZ2dlcihhLGIsdGhpcyl9KX0sdHJpZ2dlckhhbmRsZXI6ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzWzBdO3JldHVybiBjP20uZXZlbnQudHJpZ2dlcihhLGIsYywhMCk6dm9pZCAwfX0pO2Z1bmN0aW9uIGRiKGEpe3ZhciBiPWViLnNwbGl0KCJ8IiksYz1hLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtpZihjLmNyZWF0ZUVsZW1lbnQpd2hpbGUoYi5sZW5ndGgpYy5jcmVhdGVFbGVtZW50KGIucG9wKCkpO3JldHVybiBjfXZhciBlYj0iYWJicnxhcnRpY2xlfGFzaWRlfGF1ZGlvfGJkaXxjYW52YXN8ZGF0YXxkYXRhbGlzdHxkZXRhaWxzfGZpZ2NhcHRpb258ZmlndXJlfGZvb3RlcnxoZWFkZXJ8aGdyb3VwfG1hcmt8bWV0ZXJ8bmF2fG91dHB1dHxwcm9ncmVzc3xzZWN0aW9ufHN1bW1hcnl8dGltZXx2aWRlbyIsZmI9LyBqUXVlcnlcZCs9Iig/Om51bGx8XGQrKSIvZyxnYj1uZXcgUmVnRXhwKCI8KD86IitlYisiKVtcXHMvPl0iLCJpIiksaGI9L15ccysvLGliPS88KD8hYXJlYXxicnxjb2x8ZW1iZWR8aHJ8aW1nfGlucHV0fGxpbmt8bWV0YXxwYXJhbSkoKFtcdzpdKylbXj5dKilcLz4vZ2ksamI9LzwoW1x3Ol0rKS8sa2I9Lzx0Ym9keS9pLGxiPS88fCYjP1x3KzsvLG1iPS88KD86c2NyaXB0fHN0eWxlfGxpbmspL2ksbmI9L2NoZWNrZWRccyooPzpbXj1dfD1ccyouY2hlY2tlZC4pL2ksb2I9L14kfFwvKD86amF2YXxlY21hKXNjcmlwdC9pLHBiPS9edHJ1ZVwvKC4qKS8scWI9L15ccyo8ISg/OlxbQ0RBVEFcW3wtLSl8KD86XF1cXXwtLSk+XHMqJC9nLHJiPXtvcHRpb246WzEsIjxzZWxlY3QgbXVsdGlwbGU9J211bHRpcGxlJz4iLCI8L3NlbGVjdD4iXSxsZWdlbmQ6WzEsIjxmaWVsZHNldD4iLCI8L2ZpZWxkc2V0PiJdLGFyZWE6WzEsIjxtYXA+IiwiPC9tYXA+Il0scGFyYW06WzEsIjxvYmplY3Q+IiwiPC9vYmplY3Q+Il0sdGhlYWQ6WzEsIjx0YWJsZT4iLCI8L3RhYmxlPiJdLHRyOlsyLCI8dGFibGU+PHRib2R5PiIsIjwvdGJvZHk+PC90YWJsZT4iXSxjb2w6WzIsIjx0YWJsZT48dGJvZHk+PC90Ym9keT48Y29sZ3JvdXA+IiwiPC9jb2xncm91cD48L3RhYmxlPiJdLHRkOlszLCI8dGFibGU+PHRib2R5Pjx0cj4iLCI8L3RyPjwvdGJvZHk+PC90YWJsZT4iXSxfZGVmYXVsdDprLmh0bWxTZXJpYWxpemU/WzAsIiIsIiJdOlsxLCJYPGRpdj4iLCI8L2Rpdj4iXX0sc2I9ZGIoeSksdGI9c2IuYXBwZW5kQ2hpbGQoeS5jcmVhdGVFbGVtZW50KCJkaXYiKSk7cmIub3B0Z3JvdXA9cmIub3B0aW9uLHJiLnRib2R5PXJiLnRmb290PXJiLmNvbGdyb3VwPXJiLmNhcHRpb249cmIudGhlYWQscmIudGg9cmIudGQ7ZnVuY3Rpb24gdWIoYSxiKXt2YXIgYyxkLGU9MCxmPXR5cGVvZiBhLmdldEVsZW1lbnRzQnlUYWdOYW1lIT09Sz9hLmdldEVsZW1lbnRzQnlUYWdOYW1lKGJ8fCIqIik6dHlwZW9mIGEucXVlcnlTZWxlY3RvckFsbCE9PUs/YS5xdWVyeVNlbGVjdG9yQWxsKGJ8fCIqIik6dm9pZCAwO2lmKCFmKWZvcihmPVtdLGM9YS5jaGlsZE5vZGVzfHxhO251bGwhPShkPWNbZV0pO2UrKykhYnx8bS5ub2RlTmFtZShkLGIpP2YucHVzaChkKTptLm1lcmdlKGYsdWIoZCxiKSk7cmV0dXJuIHZvaWQgMD09PWJ8fGImJm0ubm9kZU5hbWUoYSxiKT9tLm1lcmdlKFthXSxmKTpmfWZ1bmN0aW9uIHZiKGEpe1cudGVzdChhLnR5cGUpJiYoYS5kZWZhdWx0Q2hlY2tlZD1hLmNoZWNrZWQpfWZ1bmN0aW9uIHdiKGEsYil7cmV0dXJuIG0ubm9kZU5hbWUoYSwidGFibGUiKSYmbS5ub2RlTmFtZSgxMSE9PWIubm9kZVR5cGU/YjpiLmZpcnN0Q2hpbGQsInRyIik/YS5nZXRFbGVtZW50c0J5VGFnTmFtZSgidGJvZHkiKVswXXx8YS5hcHBlbmRDaGlsZChhLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgidGJvZHkiKSk6YX1mdW5jdGlvbiB4YihhKXtyZXR1cm4gYS50eXBlPShudWxsIT09bS5maW5kLmF0dHIoYSwidHlwZSIpKSsiLyIrYS50eXBlLGF9ZnVuY3Rpb24geWIoYSl7dmFyIGI9cGIuZXhlYyhhLnR5cGUpO3JldHVybiBiP2EudHlwZT1iWzFdOmEucmVtb3ZlQXR0cmlidXRlKCJ0eXBlIiksYX1mdW5jdGlvbiB6YihhLGIpe2Zvcih2YXIgYyxkPTA7bnVsbCE9KGM9YVtkXSk7ZCsrKW0uX2RhdGEoYywiZ2xvYmFsRXZhbCIsIWJ8fG0uX2RhdGEoYltkXSwiZ2xvYmFsRXZhbCIpKX1mdW5jdGlvbiBBYihhLGIpe2lmKDE9PT1iLm5vZGVUeXBlJiZtLmhhc0RhdGEoYSkpe3ZhciBjLGQsZSxmPW0uX2RhdGEoYSksZz1tLl9kYXRhKGIsZiksaD1mLmV2ZW50cztpZihoKXtkZWxldGUgZy5oYW5kbGUsZy5ldmVudHM9e307Zm9yKGMgaW4gaClmb3IoZD0wLGU9aFtjXS5sZW5ndGg7ZT5kO2QrKyltLmV2ZW50LmFkZChiLGMsaFtjXVtkXSl9Zy5kYXRhJiYoZy5kYXRhPW0uZXh0ZW5kKHt9LGcuZGF0YSkpfX1mdW5jdGlvbiBCYihhLGIpe3ZhciBjLGQsZTtpZigxPT09Yi5ub2RlVHlwZSl7aWYoYz1iLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksIWsubm9DbG9uZUV2ZW50JiZiW20uZXhwYW5kb10pe2U9bS5fZGF0YShiKTtmb3IoZCBpbiBlLmV2ZW50cyltLnJlbW92ZUV2ZW50KGIsZCxlLmhhbmRsZSk7Yi5yZW1vdmVBdHRyaWJ1dGUobS5leHBhbmRvKX0ic2NyaXB0Ij09PWMmJmIudGV4dCE9PWEudGV4dD8oeGIoYikudGV4dD1hLnRleHQseWIoYikpOiJvYmplY3QiPT09Yz8oYi5wYXJlbnROb2RlJiYoYi5vdXRlckhUTUw9YS5vdXRlckhUTUwpLGsuaHRtbDVDbG9uZSYmYS5pbm5lckhUTUwmJiFtLnRyaW0oYi5pbm5lckhUTUwpJiYoYi5pbm5lckhUTUw9YS5pbm5lckhUTUwpKToiaW5wdXQiPT09YyYmVy50ZXN0KGEudHlwZSk/KGIuZGVmYXVsdENoZWNrZWQ9Yi5jaGVja2VkPWEuY2hlY2tlZCxiLnZhbHVlIT09YS52YWx1ZSYmKGIudmFsdWU9YS52YWx1ZSkpOiJvcHRpb24iPT09Yz9iLmRlZmF1bHRTZWxlY3RlZD1iLnNlbGVjdGVkPWEuZGVmYXVsdFNlbGVjdGVkOigiaW5wdXQiPT09Y3x8InRleHRhcmVhIj09PWMpJiYoYi5kZWZhdWx0VmFsdWU9YS5kZWZhdWx0VmFsdWUpfX1tLmV4dGVuZCh7Y2xvbmU6ZnVuY3Rpb24oYSxiLGMpe3ZhciBkLGUsZixnLGgsaT1tLmNvbnRhaW5zKGEub3duZXJEb2N1bWVudCxhKTtpZihrLmh0bWw1Q2xvbmV8fG0uaXNYTUxEb2MoYSl8fCFnYi50ZXN0KCI8IithLm5vZGVOYW1lKyI+Iik/Zj1hLmNsb25lTm9kZSghMCk6KHRiLmlubmVySFRNTD1hLm91dGVySFRNTCx0Yi5yZW1vdmVDaGlsZChmPXRiLmZpcnN0Q2hpbGQpKSwhKGsubm9DbG9uZUV2ZW50JiZrLm5vQ2xvbmVDaGVja2VkfHwxIT09YS5ub2RlVHlwZSYmMTEhPT1hLm5vZGVUeXBlfHxtLmlzWE1MRG9jKGEpKSlmb3IoZD11YihmKSxoPXViKGEpLGc9MDtudWxsIT0oZT1oW2ddKTsrK2cpZFtnXSYmQmIoZSxkW2ddKTtpZihiKWlmKGMpZm9yKGg9aHx8dWIoYSksZD1kfHx1YihmKSxnPTA7bnVsbCE9KGU9aFtnXSk7ZysrKUFiKGUsZFtnXSk7ZWxzZSBBYihhLGYpO3JldHVybiBkPXViKGYsInNjcmlwdCIpLGQubGVuZ3RoPjAmJnpiKGQsIWkmJnViKGEsInNjcmlwdCIpKSxkPWg9ZT1udWxsLGZ9LGJ1aWxkRnJhZ21lbnQ6ZnVuY3Rpb24oYSxiLGMsZCl7Zm9yKHZhciBlLGYsZyxoLGksaixsLG49YS5sZW5ndGgsbz1kYihiKSxwPVtdLHE9MDtuPnE7cSsrKWlmKGY9YVtxXSxmfHwwPT09ZilpZigib2JqZWN0Ij09PW0udHlwZShmKSltLm1lcmdlKHAsZi5ub2RlVHlwZT9bZl06Zik7ZWxzZSBpZihsYi50ZXN0KGYpKXtoPWh8fG8uYXBwZW5kQ2hpbGQoYi5jcmVhdGVFbGVtZW50KCJkaXYiKSksaT0oamIuZXhlYyhmKXx8WyIiLCIiXSlbMV0udG9Mb3dlckNhc2UoKSxsPXJiW2ldfHxyYi5fZGVmYXVsdCxoLmlubmVySFRNTD1sWzFdK2YucmVwbGFjZShpYiwiPCQxPjwvJDI+IikrbFsyXSxlPWxbMF07d2hpbGUoZS0tKWg9aC5sYXN0Q2hpbGQ7aWYoIWsubGVhZGluZ1doaXRlc3BhY2UmJmhiLnRlc3QoZikmJnAucHVzaChiLmNyZWF0ZVRleHROb2RlKGhiLmV4ZWMoZilbMF0pKSwhay50Ym9keSl7Zj0idGFibGUiIT09aXx8a2IudGVzdChmKT8iPHRhYmxlPiIhPT1sWzFdfHxrYi50ZXN0KGYpPzA6aDpoLmZpcnN0Q2hpbGQsZT1mJiZmLmNoaWxkTm9kZXMubGVuZ3RoO3doaWxlKGUtLSltLm5vZGVOYW1lKGo9Zi5jaGlsZE5vZGVzW2VdLCJ0Ym9keSIpJiYhai5jaGlsZE5vZGVzLmxlbmd0aCYmZi5yZW1vdmVDaGlsZChqKX1tLm1lcmdlKHAsaC5jaGlsZE5vZGVzKSxoLnRleHRDb250ZW50PSIiO3doaWxlKGguZmlyc3RDaGlsZCloLnJlbW92ZUNoaWxkKGguZmlyc3RDaGlsZCk7aD1vLmxhc3RDaGlsZH1lbHNlIHAucHVzaChiLmNyZWF0ZVRleHROb2RlKGYpKTtoJiZvLnJlbW92ZUNoaWxkKGgpLGsuYXBwZW5kQ2hlY2tlZHx8bS5ncmVwKHViKHAsImlucHV0IiksdmIpLHE9MDt3aGlsZShmPXBbcSsrXSlpZigoIWR8fC0xPT09bS5pbkFycmF5KGYsZCkpJiYoZz1tLmNvbnRhaW5zKGYub3duZXJEb2N1bWVudCxmKSxoPXViKG8uYXBwZW5kQ2hpbGQoZiksInNjcmlwdCIpLGcmJnpiKGgpLGMpKXtlPTA7d2hpbGUoZj1oW2UrK10pb2IudGVzdChmLnR5cGV8fCIiKSYmYy5wdXNoKGYpfXJldHVybiBoPW51bGwsb30sY2xlYW5EYXRhOmZ1bmN0aW9uKGEsYil7Zm9yKHZhciBkLGUsZixnLGg9MCxpPW0uZXhwYW5kbyxqPW0uY2FjaGUsbD1rLmRlbGV0ZUV4cGFuZG8sbj1tLmV2ZW50LnNwZWNpYWw7bnVsbCE9KGQ9YVtoXSk7aCsrKWlmKChifHxtLmFjY2VwdERhdGEoZCkpJiYoZj1kW2ldLGc9ZiYmaltmXSkpe2lmKGcuZXZlbnRzKWZvcihlIGluIGcuZXZlbnRzKW5bZV0/bS5ldmVudC5yZW1vdmUoZCxlKTptLnJlbW92ZUV2ZW50KGQsZSxnLmhhbmRsZSk7altmXSYmKGRlbGV0ZSBqW2ZdLGw/ZGVsZXRlIGRbaV06dHlwZW9mIGQucmVtb3ZlQXR0cmlidXRlIT09Sz9kLnJlbW92ZUF0dHJpYnV0ZShpKTpkW2ldPW51bGwsYy5wdXNoKGYpKX19fSksbS5mbi5leHRlbmQoe3RleHQ6ZnVuY3Rpb24oYSl7cmV0dXJuIFYodGhpcyxmdW5jdGlvbihhKXtyZXR1cm4gdm9pZCAwPT09YT9tLnRleHQodGhpcyk6dGhpcy5lbXB0eSgpLmFwcGVuZCgodGhpc1swXSYmdGhpc1swXS5vd25lckRvY3VtZW50fHx5KS5jcmVhdGVUZXh0Tm9kZShhKSl9LG51bGwsYSxhcmd1bWVudHMubGVuZ3RoKX0sYXBwZW5kOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZG9tTWFuaXAoYXJndW1lbnRzLGZ1bmN0aW9uKGEpe2lmKDE9PT10aGlzLm5vZGVUeXBlfHwxMT09PXRoaXMubm9kZVR5cGV8fDk9PT10aGlzLm5vZGVUeXBlKXt2YXIgYj13Yih0aGlzLGEpO2IuYXBwZW5kQ2hpbGQoYSl9fSl9LHByZXBlbmQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kb21NYW5pcChhcmd1bWVudHMsZnVuY3Rpb24oYSl7aWYoMT09PXRoaXMubm9kZVR5cGV8fDExPT09dGhpcy5ub2RlVHlwZXx8OT09PXRoaXMubm9kZVR5cGUpe3ZhciBiPXdiKHRoaXMsYSk7Yi5pbnNlcnRCZWZvcmUoYSxiLmZpcnN0Q2hpbGQpfX0pfSxiZWZvcmU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kb21NYW5pcChhcmd1bWVudHMsZnVuY3Rpb24oYSl7dGhpcy5wYXJlbnROb2RlJiZ0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGEsdGhpcyl9KX0sYWZ0ZXI6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kb21NYW5pcChhcmd1bWVudHMsZnVuY3Rpb24oYSl7dGhpcy5wYXJlbnROb2RlJiZ0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGEsdGhpcy5uZXh0U2libGluZyl9KX0scmVtb3ZlOmZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjLGQ9YT9tLmZpbHRlcihhLHRoaXMpOnRoaXMsZT0wO251bGwhPShjPWRbZV0pO2UrKylifHwxIT09Yy5ub2RlVHlwZXx8bS5jbGVhbkRhdGEodWIoYykpLGMucGFyZW50Tm9kZSYmKGImJm0uY29udGFpbnMoYy5vd25lckRvY3VtZW50LGMpJiZ6Yih1YihjLCJzY3JpcHQiKSksYy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGMpKTtyZXR1cm4gdGhpc30sZW1wdHk6ZnVuY3Rpb24oKXtmb3IodmFyIGEsYj0wO251bGwhPShhPXRoaXNbYl0pO2IrKyl7MT09PWEubm9kZVR5cGUmJm0uY2xlYW5EYXRhKHViKGEsITEpKTt3aGlsZShhLmZpcnN0Q2hpbGQpYS5yZW1vdmVDaGlsZChhLmZpcnN0Q2hpbGQpO2Eub3B0aW9ucyYmbS5ub2RlTmFtZShhLCJzZWxlY3QiKSYmKGEub3B0aW9ucy5sZW5ndGg9MCl9cmV0dXJuIHRoaXN9LGNsb25lOmZ1bmN0aW9uKGEsYil7cmV0dXJuIGE9bnVsbD09YT8hMTphLGI9bnVsbD09Yj9hOmIsdGhpcy5tYXAoZnVuY3Rpb24oKXtyZXR1cm4gbS5jbG9uZSh0aGlzLGEsYil9KX0saHRtbDpmdW5jdGlvbihhKXtyZXR1cm4gVih0aGlzLGZ1bmN0aW9uKGEpe3ZhciBiPXRoaXNbMF18fHt9LGM9MCxkPXRoaXMubGVuZ3RoO2lmKHZvaWQgMD09PWEpcmV0dXJuIDE9PT1iLm5vZGVUeXBlP2IuaW5uZXJIVE1MLnJlcGxhY2UoZmIsIiIpOnZvaWQgMDtpZighKCJzdHJpbmciIT10eXBlb2YgYXx8bWIudGVzdChhKXx8IWsuaHRtbFNlcmlhbGl6ZSYmZ2IudGVzdChhKXx8IWsubGVhZGluZ1doaXRlc3BhY2UmJmhiLnRlc3QoYSl8fHJiWyhqYi5leGVjKGEpfHxbIiIsIiJdKVsxXS50b0xvd2VyQ2FzZSgpXSkpe2E9YS5yZXBsYWNlKGliLCI8JDE+PC8kMj4iKTt0cnl7Zm9yKDtkPmM7YysrKWI9dGhpc1tjXXx8e30sMT09PWIubm9kZVR5cGUmJihtLmNsZWFuRGF0YSh1YihiLCExKSksYi5pbm5lckhUTUw9YSk7Yj0wfWNhdGNoKGUpe319YiYmdGhpcy5lbXB0eSgpLmFwcGVuZChhKX0sbnVsbCxhLGFyZ3VtZW50cy5sZW5ndGgpfSxyZXBsYWNlV2l0aDpmdW5jdGlvbigpe3ZhciBhPWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5kb21NYW5pcChhcmd1bWVudHMsZnVuY3Rpb24oYil7YT10aGlzLnBhcmVudE5vZGUsbS5jbGVhbkRhdGEodWIodGhpcykpLGEmJmEucmVwbGFjZUNoaWxkKGIsdGhpcyl9KSxhJiYoYS5sZW5ndGh8fGEubm9kZVR5cGUpP3RoaXM6dGhpcy5yZW1vdmUoKX0sZGV0YWNoOmZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLnJlbW92ZShhLCEwKX0sZG9tTWFuaXA6ZnVuY3Rpb24oYSxiKXthPWUuYXBwbHkoW10sYSk7dmFyIGMsZCxmLGcsaCxpLGo9MCxsPXRoaXMubGVuZ3RoLG49dGhpcyxvPWwtMSxwPWFbMF0scT1tLmlzRnVuY3Rpb24ocCk7aWYocXx8bD4xJiYic3RyaW5nIj09dHlwZW9mIHAmJiFrLmNoZWNrQ2xvbmUmJm5iLnRlc3QocCkpcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihjKXt2YXIgZD1uLmVxKGMpO3EmJihhWzBdPXAuY2FsbCh0aGlzLGMsZC5odG1sKCkpKSxkLmRvbU1hbmlwKGEsYil9KTtpZihsJiYoaT1tLmJ1aWxkRnJhZ21lbnQoYSx0aGlzWzBdLm93bmVyRG9jdW1lbnQsITEsdGhpcyksYz1pLmZpcnN0Q2hpbGQsMT09PWkuY2hpbGROb2Rlcy5sZW5ndGgmJihpPWMpLGMpKXtmb3IoZz1tLm1hcCh1YihpLCJzY3JpcHQiKSx4YiksZj1nLmxlbmd0aDtsPmo7aisrKWQ9aSxqIT09byYmKGQ9bS5jbG9uZShkLCEwLCEwKSxmJiZtLm1lcmdlKGcsdWIoZCwic2NyaXB0IikpKSxiLmNhbGwodGhpc1tqXSxkLGopO2lmKGYpZm9yKGg9Z1tnLmxlbmd0aC0xXS5vd25lckRvY3VtZW50LG0ubWFwKGcseWIpLGo9MDtmPmo7aisrKWQ9Z1tqXSxvYi50ZXN0KGQudHlwZXx8IiIpJiYhbS5fZGF0YShkLCJnbG9iYWxFdmFsIikmJm0uY29udGFpbnMoaCxkKSYmKGQuc3JjP20uX2V2YWxVcmwmJm0uX2V2YWxVcmwoZC5zcmMpOm0uZ2xvYmFsRXZhbCgoZC50ZXh0fHxkLnRleHRDb250ZW50fHxkLmlubmVySFRNTHx8IiIpLnJlcGxhY2UocWIsIiIpKSk7aT1jPW51bGx9cmV0dXJuIHRoaXN9fSksbS5lYWNoKHthcHBlbmRUbzoiYXBwZW5kIixwcmVwZW5kVG86InByZXBlbmQiLGluc2VydEJlZm9yZToiYmVmb3JlIixpbnNlcnRBZnRlcjoiYWZ0ZXIiLHJlcGxhY2VBbGw6InJlcGxhY2VXaXRoIn0sZnVuY3Rpb24oYSxiKXttLmZuW2FdPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYyxkPTAsZT1bXSxnPW0oYSksaD1nLmxlbmd0aC0xO2g+PWQ7ZCsrKWM9ZD09PWg/dGhpczp0aGlzLmNsb25lKCEwKSxtKGdbZF0pW2JdKGMpLGYuYXBwbHkoZSxjLmdldCgpKTtyZXR1cm4gdGhpcy5wdXNoU3RhY2soZSl9fSk7dmFyIENiLERiPXt9O2Z1bmN0aW9uIEViKGIsYyl7dmFyIGQsZT1tKGMuY3JlYXRlRWxlbWVudChiKSkuYXBwZW5kVG8oYy5ib2R5KSxmPWEuZ2V0RGVmYXVsdENvbXB1dGVkU3R5bGUmJihkPWEuZ2V0RGVmYXVsdENvbXB1dGVkU3R5bGUoZVswXSkpP2QuZGlzcGxheTptLmNzcyhlWzBdLCJkaXNwbGF5Iik7cmV0dXJuIGUuZGV0YWNoKCksZn1mdW5jdGlvbiBGYihhKXt2YXIgYj15LGM9RGJbYV07cmV0dXJuIGN8fChjPUViKGEsYiksIm5vbmUiIT09YyYmY3x8KENiPShDYnx8bSgiPGlmcmFtZSBmcmFtZWJvcmRlcj0nMCcgd2lkdGg9JzAnIGhlaWdodD0nMCcvPiIpKS5hcHBlbmRUbyhiLmRvY3VtZW50RWxlbWVudCksYj0oQ2JbMF0uY29udGVudFdpbmRvd3x8Q2JbMF0uY29udGVudERvY3VtZW50KS5kb2N1bWVudCxiLndyaXRlKCksYi5jbG9zZSgpLGM9RWIoYSxiKSxDYi5kZXRhY2goKSksRGJbYV09YyksY30hZnVuY3Rpb24oKXt2YXIgYTtrLnNocmlua1dyYXBCbG9ja3M9ZnVuY3Rpb24oKXtpZihudWxsIT1hKXJldHVybiBhO2E9ITE7dmFyIGIsYyxkO3JldHVybiBjPXkuZ2V0RWxlbWVudHNCeVRhZ05hbWUoImJvZHkiKVswXSxjJiZjLnN0eWxlPyhiPXkuY3JlYXRlRWxlbWVudCgiZGl2IiksZD15LmNyZWF0ZUVsZW1lbnQoImRpdiIpLGQuc3R5bGUuY3NzVGV4dD0icG9zaXRpb246YWJzb2x1dGU7Ym9yZGVyOjA7d2lkdGg6MDtoZWlnaHQ6MDt0b3A6MDtsZWZ0Oi05OTk5cHgiLGMuYXBwZW5kQ2hpbGQoZCkuYXBwZW5kQ2hpbGQoYiksdHlwZW9mIGIuc3R5bGUuem9vbSE9PUsmJihiLnN0eWxlLmNzc1RleHQ9Ii13ZWJraXQtYm94LXNpemluZzpjb250ZW50LWJveDstbW96LWJveC1zaXppbmc6Y29udGVudC1ib3g7Ym94LXNpemluZzpjb250ZW50LWJveDtkaXNwbGF5OmJsb2NrO21hcmdpbjowO2JvcmRlcjowO3BhZGRpbmc6MXB4O3dpZHRoOjFweDt6b29tOjEiLGIuYXBwZW5kQ2hpbGQoeS5jcmVhdGVFbGVtZW50KCJkaXYiKSkuc3R5bGUud2lkdGg9IjVweCIsYT0zIT09Yi5vZmZzZXRXaWR0aCksYy5yZW1vdmVDaGlsZChkKSxhKTp2b2lkIDB9fSgpO3ZhciBHYj0vXm1hcmdpbi8sSGI9bmV3IFJlZ0V4cCgiXigiK1MrIikoPyFweClbYS16JV0rJCIsImkiKSxJYixKYixLYj0vXih0b3B8cmlnaHR8Ym90dG9tfGxlZnQpJC87YS5nZXRDb21wdXRlZFN0eWxlPyhJYj1mdW5jdGlvbihhKXtyZXR1cm4gYS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUoYSxudWxsKX0sSmI9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkLGUsZixnLGg9YS5zdHlsZTtyZXR1cm4gYz1jfHxJYihhKSxnPWM/Yy5nZXRQcm9wZXJ0eVZhbHVlKGIpfHxjW2JdOnZvaWQgMCxjJiYoIiIhPT1nfHxtLmNvbnRhaW5zKGEub3duZXJEb2N1bWVudCxhKXx8KGc9bS5zdHlsZShhLGIpKSxIYi50ZXN0KGcpJiZHYi50ZXN0KGIpJiYoZD1oLndpZHRoLGU9aC5taW5XaWR0aCxmPWgubWF4V2lkdGgsaC5taW5XaWR0aD1oLm1heFdpZHRoPWgud2lkdGg9ZyxnPWMud2lkdGgsaC53aWR0aD1kLGgubWluV2lkdGg9ZSxoLm1heFdpZHRoPWYpKSx2b2lkIDA9PT1nP2c6ZysiIn0pOnkuZG9jdW1lbnRFbGVtZW50LmN1cnJlbnRTdHlsZSYmKEliPWZ1bmN0aW9uKGEpe3JldHVybiBhLmN1cnJlbnRTdHlsZX0sSmI9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkLGUsZixnLGg9YS5zdHlsZTtyZXR1cm4gYz1jfHxJYihhKSxnPWM/Y1tiXTp2b2lkIDAsbnVsbD09ZyYmaCYmaFtiXSYmKGc9aFtiXSksSGIudGVzdChnKSYmIUtiLnRlc3QoYikmJihkPWgubGVmdCxlPWEucnVudGltZVN0eWxlLGY9ZSYmZS5sZWZ0LGYmJihlLmxlZnQ9YS5jdXJyZW50U3R5bGUubGVmdCksaC5sZWZ0PSJmb250U2l6ZSI9PT1iPyIxZW0iOmcsZz1oLnBpeGVsTGVmdCsicHgiLGgubGVmdD1kLGYmJihlLmxlZnQ9ZikpLHZvaWQgMD09PWc/ZzpnKyIifHwiYXV0byJ9KTtmdW5jdGlvbiBMYihhLGIpe3JldHVybntnZXQ6ZnVuY3Rpb24oKXt2YXIgYz1hKCk7aWYobnVsbCE9YylyZXR1cm4gYz92b2lkIGRlbGV0ZSB0aGlzLmdldDoodGhpcy5nZXQ9YikuYXBwbHkodGhpcyxhcmd1bWVudHMpfX19IWZ1bmN0aW9uKCl7dmFyIGIsYyxkLGUsZixnLGg7aWYoYj15LmNyZWF0ZUVsZW1lbnQoImRpdiIpLGIuaW5uZXJIVE1MPSIgIDxsaW5rLz48dGFibGU+PC90YWJsZT48YSBocmVmPScvYSc+YTwvYT48aW5wdXQgdHlwZT0nY2hlY2tib3gnLz4iLGQ9Yi5nZXRFbGVtZW50c0J5VGFnTmFtZSgiYSIpWzBdLGM9ZCYmZC5zdHlsZSl7Yy5jc3NUZXh0PSJmbG9hdDpsZWZ0O29wYWNpdHk6LjUiLGsub3BhY2l0eT0iMC41Ij09PWMub3BhY2l0eSxrLmNzc0Zsb2F0PSEhYy5jc3NGbG9hdCxiLnN0eWxlLmJhY2tncm91bmRDbGlwPSJjb250ZW50LWJveCIsYi5jbG9uZU5vZGUoITApLnN0eWxlLmJhY2tncm91bmRDbGlwPSIiLGsuY2xlYXJDbG9uZVN0eWxlPSJjb250ZW50LWJveCI9PT1iLnN0eWxlLmJhY2tncm91bmRDbGlwLGsuYm94U2l6aW5nPSIiPT09Yy5ib3hTaXppbmd8fCIiPT09Yy5Nb3pCb3hTaXppbmd8fCIiPT09Yy5XZWJraXRCb3hTaXppbmcsbS5leHRlbmQoayx7cmVsaWFibGVIaWRkZW5PZmZzZXRzOmZ1bmN0aW9uKCl7cmV0dXJuIG51bGw9PWcmJmkoKSxnfSxib3hTaXppbmdSZWxpYWJsZTpmdW5jdGlvbigpe3JldHVybiBudWxsPT1mJiZpKCksZn0scGl4ZWxQb3NpdGlvbjpmdW5jdGlvbigpe3JldHVybiBudWxsPT1lJiZpKCksZX0scmVsaWFibGVNYXJnaW5SaWdodDpmdW5jdGlvbigpe3JldHVybiBudWxsPT1oJiZpKCksaH19KTtmdW5jdGlvbiBpKCl7dmFyIGIsYyxkLGk7Yz15LmdldEVsZW1lbnRzQnlUYWdOYW1lKCJib2R5IilbMF0sYyYmYy5zdHlsZSYmKGI9eS5jcmVhdGVFbGVtZW50KCJkaXYiKSxkPXkuY3JlYXRlRWxlbWVudCgiZGl2IiksZC5zdHlsZS5jc3NUZXh0PSJwb3NpdGlvbjphYnNvbHV0ZTtib3JkZXI6MDt3aWR0aDowO2hlaWdodDowO3RvcDowO2xlZnQ6LTk5OTlweCIsYy5hcHBlbmRDaGlsZChkKS5hcHBlbmRDaGlsZChiKSxiLnN0eWxlLmNzc1RleHQ9Ii13ZWJraXQtYm94LXNpemluZzpib3JkZXItYm94Oy1tb3otYm94LXNpemluZzpib3JkZXItYm94O2JveC1zaXppbmc6Ym9yZGVyLWJveDtkaXNwbGF5OmJsb2NrO21hcmdpbi10b3A6MSU7dG9wOjElO2JvcmRlcjoxcHg7cGFkZGluZzoxcHg7d2lkdGg6NHB4O3Bvc2l0aW9uOmFic29sdXRlIixlPWY9ITEsaD0hMCxhLmdldENvbXB1dGVkU3R5bGUmJihlPSIxJSIhPT0oYS5nZXRDb21wdXRlZFN0eWxlKGIsbnVsbCl8fHt9KS50b3AsZj0iNHB4Ij09PShhLmdldENvbXB1dGVkU3R5bGUoYixudWxsKXx8e3dpZHRoOiI0cHgifSkud2lkdGgsaT1iLmFwcGVuZENoaWxkKHkuY3JlYXRlRWxlbWVudCgiZGl2IikpLGkuc3R5bGUuY3NzVGV4dD1iLnN0eWxlLmNzc1RleHQ9Ii13ZWJraXQtYm94LXNpemluZzpjb250ZW50LWJveDstbW96LWJveC1zaXppbmc6Y29udGVudC1ib3g7Ym94LXNpemluZzpjb250ZW50LWJveDtkaXNwbGF5OmJsb2NrO21hcmdpbjowO2JvcmRlcjowO3BhZGRpbmc6MCIsaS5zdHlsZS5tYXJnaW5SaWdodD1pLnN0eWxlLndpZHRoPSIwIixiLnN0eWxlLndpZHRoPSIxcHgiLGg9IXBhcnNlRmxvYXQoKGEuZ2V0Q29tcHV0ZWRTdHlsZShpLG51bGwpfHx7fSkubWFyZ2luUmlnaHQpKSxiLmlubmVySFRNTD0iPHRhYmxlPjx0cj48dGQ+PC90ZD48dGQ+dDwvdGQ+PC90cj48L3RhYmxlPiIsaT1iLmdldEVsZW1lbnRzQnlUYWdOYW1lKCJ0ZCIpLGlbMF0uc3R5bGUuY3NzVGV4dD0ibWFyZ2luOjA7Ym9yZGVyOjA7cGFkZGluZzowO2Rpc3BsYXk6bm9uZSIsZz0wPT09aVswXS5vZmZzZXRIZWlnaHQsZyYmKGlbMF0uc3R5bGUuZGlzcGxheT0iIixpWzFdLnN0eWxlLmRpc3BsYXk9Im5vbmUiLGc9MD09PWlbMF0ub2Zmc2V0SGVpZ2h0KSxjLnJlbW92ZUNoaWxkKGQpKX19fSgpLG0uc3dhcD1mdW5jdGlvbihhLGIsYyxkKXt2YXIgZSxmLGc9e307Zm9yKGYgaW4gYilnW2ZdPWEuc3R5bGVbZl0sYS5zdHlsZVtmXT1iW2ZdO2U9Yy5hcHBseShhLGR8fFtdKTtmb3IoZiBpbiBiKWEuc3R5bGVbZl09Z1tmXTtyZXR1cm4gZX07dmFyIE1iPS9hbHBoYVwoW14pXSpcKS9pLE5iPS9vcGFjaXR5XHMqPVxzKihbXildKikvLE9iPS9eKG5vbmV8dGFibGUoPyEtY1tlYV0pLispLyxQYj1uZXcgUmVnRXhwKCJeKCIrUysiKSguKikkIiwiaSIpLFFiPW5ldyBSZWdFeHAoIl4oWystXSk9KCIrUysiKSIsImkiKSxSYj17cG9zaXRpb246ImFic29sdXRlIix2aXNpYmlsaXR5OiJoaWRkZW4iLGRpc3BsYXk6ImJsb2NrIn0sU2I9e2xldHRlclNwYWNpbmc6IjAiLGZvbnRXZWlnaHQ6IjQwMCJ9LFRiPVsiV2Via2l0IiwiTyIsIk1veiIsIm1zIl07ZnVuY3Rpb24gVWIoYSxiKXtpZihiIGluIGEpcmV0dXJuIGI7dmFyIGM9Yi5jaGFyQXQoMCkudG9VcHBlckNhc2UoKStiLnNsaWNlKDEpLGQ9YixlPVRiLmxlbmd0aDt3aGlsZShlLS0paWYoYj1UYltlXStjLGIgaW4gYSlyZXR1cm4gYjtyZXR1cm4gZH1mdW5jdGlvbiBWYihhLGIpe2Zvcih2YXIgYyxkLGUsZj1bXSxnPTAsaD1hLmxlbmd0aDtoPmc7ZysrKWQ9YVtnXSxkLnN0eWxlJiYoZltnXT1tLl9kYXRhKGQsIm9sZGRpc3BsYXkiKSxjPWQuc3R5bGUuZGlzcGxheSxiPyhmW2ddfHwibm9uZSIhPT1jfHwoZC5zdHlsZS5kaXNwbGF5PSIiKSwiIj09PWQuc3R5bGUuZGlzcGxheSYmVShkKSYmKGZbZ109bS5fZGF0YShkLCJvbGRkaXNwbGF5IixGYihkLm5vZGVOYW1lKSkpKTooZT1VKGQpLChjJiYibm9uZSIhPT1jfHwhZSkmJm0uX2RhdGEoZCwib2xkZGlzcGxheSIsZT9jOm0uY3NzKGQsImRpc3BsYXkiKSkpKTtmb3IoZz0wO2g+ZztnKyspZD1hW2ddLGQuc3R5bGUmJihiJiYibm9uZSIhPT1kLnN0eWxlLmRpc3BsYXkmJiIiIT09ZC5zdHlsZS5kaXNwbGF5fHwoZC5zdHlsZS5kaXNwbGF5PWI/ZltnXXx8IiI6Im5vbmUiKSk7cmV0dXJuIGF9ZnVuY3Rpb24gV2IoYSxiLGMpe3ZhciBkPVBiLmV4ZWMoYik7cmV0dXJuIGQ/TWF0aC5tYXgoMCxkWzFdLShjfHwwKSkrKGRbMl18fCJweCIpOmJ9ZnVuY3Rpb24gWGIoYSxiLGMsZCxlKXtmb3IodmFyIGY9Yz09PShkPyJib3JkZXIiOiJjb250ZW50Iik/NDoid2lkdGgiPT09Yj8xOjAsZz0wOzQ+ZjtmKz0yKSJtYXJnaW4iPT09YyYmKGcrPW0uY3NzKGEsYytUW2ZdLCEwLGUpKSxkPygiY29udGVudCI9PT1jJiYoZy09bS5jc3MoYSwicGFkZGluZyIrVFtmXSwhMCxlKSksIm1hcmdpbiIhPT1jJiYoZy09bS5jc3MoYSwiYm9yZGVyIitUW2ZdKyJXaWR0aCIsITAsZSkpKTooZys9bS5jc3MoYSwicGFkZGluZyIrVFtmXSwhMCxlKSwicGFkZGluZyIhPT1jJiYoZys9bS5jc3MoYSwiYm9yZGVyIitUW2ZdKyJXaWR0aCIsITAsZSkpKTtyZXR1cm4gZ31mdW5jdGlvbiBZYihhLGIsYyl7dmFyIGQ9ITAsZT0id2lkdGgiPT09Yj9hLm9mZnNldFdpZHRoOmEub2Zmc2V0SGVpZ2h0LGY9SWIoYSksZz1rLmJveFNpemluZyYmImJvcmRlci1ib3giPT09bS5jc3MoYSwiYm94U2l6aW5nIiwhMSxmKTtpZigwPj1lfHxudWxsPT1lKXtpZihlPUpiKGEsYixmKSwoMD5lfHxudWxsPT1lKSYmKGU9YS5zdHlsZVtiXSksSGIudGVzdChlKSlyZXR1cm4gZTtkPWcmJihrLmJveFNpemluZ1JlbGlhYmxlKCl8fGU9PT1hLnN0eWxlW2JdKSxlPXBhcnNlRmxvYXQoZSl8fDB9cmV0dXJuIGUrWGIoYSxiLGN8fChnPyJib3JkZXIiOiJjb250ZW50IiksZCxmKSsicHgifW0uZXh0ZW5kKHtjc3NIb29rczp7b3BhY2l0eTp7Z2V0OmZ1bmN0aW9uKGEsYil7aWYoYil7dmFyIGM9SmIoYSwib3BhY2l0eSIpO3JldHVybiIiPT09Yz8iMSI6Y319fX0sY3NzTnVtYmVyOntjb2x1bW5Db3VudDohMCxmaWxsT3BhY2l0eTohMCxmbGV4R3JvdzohMCxmbGV4U2hyaW5rOiEwLGZvbnRXZWlnaHQ6ITAsbGluZUhlaWdodDohMCxvcGFjaXR5OiEwLG9yZGVyOiEwLG9ycGhhbnM6ITAsd2lkb3dzOiEwLHpJbmRleDohMCx6b29tOiEwfSxjc3NQcm9wczp7ImZsb2F0IjprLmNzc0Zsb2F0PyJjc3NGbG9hdCI6InN0eWxlRmxvYXQifSxzdHlsZTpmdW5jdGlvbihhLGIsYyxkKXtpZihhJiYzIT09YS5ub2RlVHlwZSYmOCE9PWEubm9kZVR5cGUmJmEuc3R5bGUpe3ZhciBlLGYsZyxoPW0uY2FtZWxDYXNlKGIpLGk9YS5zdHlsZTtpZihiPW0uY3NzUHJvcHNbaF18fChtLmNzc1Byb3BzW2hdPVViKGksaCkpLGc9bS5jc3NIb29rc1tiXXx8bS5jc3NIb29rc1toXSx2b2lkIDA9PT1jKXJldHVybiBnJiYiZ2V0ImluIGcmJnZvaWQgMCE9PShlPWcuZ2V0KGEsITEsZCkpP2U6aVtiXTtpZihmPXR5cGVvZiBjLCJzdHJpbmciPT09ZiYmKGU9UWIuZXhlYyhjKSkmJihjPShlWzFdKzEpKmVbMl0rcGFyc2VGbG9hdChtLmNzcyhhLGIpKSxmPSJudW1iZXIiKSxudWxsIT1jJiZjPT09YyYmKCJudW1iZXIiIT09Znx8bS5jc3NOdW1iZXJbaF18fChjKz0icHgiKSxrLmNsZWFyQ2xvbmVTdHlsZXx8IiIhPT1jfHwwIT09Yi5pbmRleE9mKCJiYWNrZ3JvdW5kIil8fChpW2JdPSJpbmhlcml0IiksIShnJiYic2V0ImluIGcmJnZvaWQgMD09PShjPWcuc2V0KGEsYyxkKSkpKSl0cnl7aVtiXT1jfWNhdGNoKGope319fSxjc3M6ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGUsZixnLGg9bS5jYW1lbENhc2UoYik7cmV0dXJuIGI9bS5jc3NQcm9wc1toXXx8KG0uY3NzUHJvcHNbaF09VWIoYS5zdHlsZSxoKSksZz1tLmNzc0hvb2tzW2JdfHxtLmNzc0hvb2tzW2hdLGcmJiJnZXQiaW4gZyYmKGY9Zy5nZXQoYSwhMCxjKSksdm9pZCAwPT09ZiYmKGY9SmIoYSxiLGQpKSwibm9ybWFsIj09PWYmJmIgaW4gU2ImJihmPVNiW2JdKSwiIj09PWN8fGM/KGU9cGFyc2VGbG9hdChmKSxjPT09ITB8fG0uaXNOdW1lcmljKGUpP2V8fDA6Zik6Zn19KSxtLmVhY2goWyJoZWlnaHQiLCJ3aWR0aCJdLGZ1bmN0aW9uKGEsYil7bS5jc3NIb29rc1tiXT17Z2V0OmZ1bmN0aW9uKGEsYyxkKXtyZXR1cm4gYz9PYi50ZXN0KG0uY3NzKGEsImRpc3BsYXkiKSkmJjA9PT1hLm9mZnNldFdpZHRoP20uc3dhcChhLFJiLGZ1bmN0aW9uKCl7cmV0dXJuIFliKGEsYixkKX0pOlliKGEsYixkKTp2b2lkIDB9LHNldDpmdW5jdGlvbihhLGMsZCl7dmFyIGU9ZCYmSWIoYSk7cmV0dXJuIFdiKGEsYyxkP1hiKGEsYixkLGsuYm94U2l6aW5nJiYiYm9yZGVyLWJveCI9PT1tLmNzcyhhLCJib3hTaXppbmciLCExLGUpLGUpOjApfX19KSxrLm9wYWNpdHl8fChtLmNzc0hvb2tzLm9wYWNpdHk9e2dldDpmdW5jdGlvbihhLGIpe3JldHVybiBOYi50ZXN0KChiJiZhLmN1cnJlbnRTdHlsZT9hLmN1cnJlbnRTdHlsZS5maWx0ZXI6YS5zdHlsZS5maWx0ZXIpfHwiIik/LjAxKnBhcnNlRmxvYXQoUmVnRXhwLiQxKSsiIjpiPyIxIjoiIn0sc2V0OmZ1bmN0aW9uKGEsYil7dmFyIGM9YS5zdHlsZSxkPWEuY3VycmVudFN0eWxlLGU9bS5pc051bWVyaWMoYik/ImFscGhhKG9wYWNpdHk9IisxMDAqYisiKSI6IiIsZj1kJiZkLmZpbHRlcnx8Yy5maWx0ZXJ8fCIiO2Muem9vbT0xLChiPj0xfHwiIj09PWIpJiYiIj09PW0udHJpbShmLnJlcGxhY2UoTWIsIiIpKSYmYy5yZW1vdmVBdHRyaWJ1dGUmJihjLnJlbW92ZUF0dHJpYnV0ZSgiZmlsdGVyIiksIiI9PT1ifHxkJiYhZC5maWx0ZXIpfHwoYy5maWx0ZXI9TWIudGVzdChmKT9mLnJlcGxhY2UoTWIsZSk6ZisiICIrZSl9fSksbS5jc3NIb29rcy5tYXJnaW5SaWdodD1MYihrLnJlbGlhYmxlTWFyZ2luUmlnaHQsZnVuY3Rpb24oYSxiKXtyZXR1cm4gYj9tLnN3YXAoYSx7ZGlzcGxheToiaW5saW5lLWJsb2NrIn0sSmIsW2EsIm1hcmdpblJpZ2h0Il0pOnZvaWQgMH0pLG0uZWFjaCh7bWFyZ2luOiIiLHBhZGRpbmc6IiIsYm9yZGVyOiJXaWR0aCJ9LGZ1bmN0aW9uKGEsYil7bS5jc3NIb29rc1thK2JdPXtleHBhbmQ6ZnVuY3Rpb24oYyl7Zm9yKHZhciBkPTAsZT17fSxmPSJzdHJpbmciPT10eXBlb2YgYz9jLnNwbGl0KCIgIik6W2NdOzQ+ZDtkKyspZVthK1RbZF0rYl09ZltkXXx8ZltkLTJdfHxmWzBdO3JldHVybiBlfX0sR2IudGVzdChhKXx8KG0uY3NzSG9va3NbYStiXS5zZXQ9V2IpfSksbS5mbi5leHRlbmQoe2NzczpmdW5jdGlvbihhLGIpe3JldHVybiBWKHRoaXMsZnVuY3Rpb24oYSxiLGMpe3ZhciBkLGUsZj17fSxnPTA7aWYobS5pc0FycmF5KGIpKXtmb3IoZD1JYihhKSxlPWIubGVuZ3RoO2U+ZztnKyspZltiW2ddXT1tLmNzcyhhLGJbZ10sITEsZCk7cmV0dXJuIGZ9cmV0dXJuIHZvaWQgMCE9PWM/bS5zdHlsZShhLGIsYyk6bS5jc3MoYSxiKX0sYSxiLGFyZ3VtZW50cy5sZW5ndGg+MSl9LHNob3c6ZnVuY3Rpb24oKXtyZXR1cm4gVmIodGhpcywhMCl9LGhpZGU6ZnVuY3Rpb24oKXtyZXR1cm4gVmIodGhpcyl9LHRvZ2dsZTpmdW5jdGlvbihhKXtyZXR1cm4iYm9vbGVhbiI9PXR5cGVvZiBhP2E/dGhpcy5zaG93KCk6dGhpcy5oaWRlKCk6dGhpcy5lYWNoKGZ1bmN0aW9uKCl7VSh0aGlzKT9tKHRoaXMpLnNob3coKTptKHRoaXMpLmhpZGUoKX0pfX0pO2Z1bmN0aW9uIFpiKGEsYixjLGQsZSl7cmV0dXJuIG5ldyBaYi5wcm90b3R5cGUuaW5pdChhLGIsYyxkLGUpfW0uVHdlZW49WmIsWmIucHJvdG90eXBlPXtjb25zdHJ1Y3RvcjpaYixpbml0OmZ1bmN0aW9uKGEsYixjLGQsZSxmKXt0aGlzLmVsZW09YSx0aGlzLnByb3A9Yyx0aGlzLmVhc2luZz1lfHwic3dpbmciLHRoaXMub3B0aW9ucz1iLHRoaXMuc3RhcnQ9dGhpcy5ub3c9dGhpcy5jdXIoKSx0aGlzLmVuZD1kLHRoaXMudW5pdD1mfHwobS5jc3NOdW1iZXJbY10/IiI6InB4IikKfSxjdXI6ZnVuY3Rpb24oKXt2YXIgYT1aYi5wcm9wSG9va3NbdGhpcy5wcm9wXTtyZXR1cm4gYSYmYS5nZXQ/YS5nZXQodGhpcyk6WmIucHJvcEhvb2tzLl9kZWZhdWx0LmdldCh0aGlzKX0scnVuOmZ1bmN0aW9uKGEpe3ZhciBiLGM9WmIucHJvcEhvb2tzW3RoaXMucHJvcF07cmV0dXJuIHRoaXMucG9zPWI9dGhpcy5vcHRpb25zLmR1cmF0aW9uP20uZWFzaW5nW3RoaXMuZWFzaW5nXShhLHRoaXMub3B0aW9ucy5kdXJhdGlvbiphLDAsMSx0aGlzLm9wdGlvbnMuZHVyYXRpb24pOmEsdGhpcy5ub3c9KHRoaXMuZW5kLXRoaXMuc3RhcnQpKmIrdGhpcy5zdGFydCx0aGlzLm9wdGlvbnMuc3RlcCYmdGhpcy5vcHRpb25zLnN0ZXAuY2FsbCh0aGlzLmVsZW0sdGhpcy5ub3csdGhpcyksYyYmYy5zZXQ/Yy5zZXQodGhpcyk6WmIucHJvcEhvb2tzLl9kZWZhdWx0LnNldCh0aGlzKSx0aGlzfX0sWmIucHJvdG90eXBlLmluaXQucHJvdG90eXBlPVpiLnByb3RvdHlwZSxaYi5wcm9wSG9va3M9e19kZWZhdWx0OntnZXQ6ZnVuY3Rpb24oYSl7dmFyIGI7cmV0dXJuIG51bGw9PWEuZWxlbVthLnByb3BdfHxhLmVsZW0uc3R5bGUmJm51bGwhPWEuZWxlbS5zdHlsZVthLnByb3BdPyhiPW0uY3NzKGEuZWxlbSxhLnByb3AsIiIpLGImJiJhdXRvIiE9PWI/YjowKTphLmVsZW1bYS5wcm9wXX0sc2V0OmZ1bmN0aW9uKGEpe20uZnguc3RlcFthLnByb3BdP20uZnguc3RlcFthLnByb3BdKGEpOmEuZWxlbS5zdHlsZSYmKG51bGwhPWEuZWxlbS5zdHlsZVttLmNzc1Byb3BzW2EucHJvcF1dfHxtLmNzc0hvb2tzW2EucHJvcF0pP20uc3R5bGUoYS5lbGVtLGEucHJvcCxhLm5vdythLnVuaXQpOmEuZWxlbVthLnByb3BdPWEubm93fX19LFpiLnByb3BIb29rcy5zY3JvbGxUb3A9WmIucHJvcEhvb2tzLnNjcm9sbExlZnQ9e3NldDpmdW5jdGlvbihhKXthLmVsZW0ubm9kZVR5cGUmJmEuZWxlbS5wYXJlbnROb2RlJiYoYS5lbGVtW2EucHJvcF09YS5ub3cpfX0sbS5lYXNpbmc9e2xpbmVhcjpmdW5jdGlvbihhKXtyZXR1cm4gYX0sc3dpbmc6ZnVuY3Rpb24oYSl7cmV0dXJuLjUtTWF0aC5jb3MoYSpNYXRoLlBJKS8yfX0sbS5meD1aYi5wcm90b3R5cGUuaW5pdCxtLmZ4LnN0ZXA9e307dmFyICRiLF9iLGFjPS9eKD86dG9nZ2xlfHNob3d8aGlkZSkkLyxiYz1uZXcgUmVnRXhwKCJeKD86KFsrLV0pPXwpKCIrUysiKShbYS16JV0qKSQiLCJpIiksY2M9L3F1ZXVlSG9va3MkLyxkYz1baWNdLGVjPXsiKiI6W2Z1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5jcmVhdGVUd2VlbihhLGIpLGQ9Yy5jdXIoKSxlPWJjLmV4ZWMoYiksZj1lJiZlWzNdfHwobS5jc3NOdW1iZXJbYV0/IiI6InB4IiksZz0obS5jc3NOdW1iZXJbYV18fCJweCIhPT1mJiYrZCkmJmJjLmV4ZWMobS5jc3MoYy5lbGVtLGEpKSxoPTEsaT0yMDtpZihnJiZnWzNdIT09Zil7Zj1mfHxnWzNdLGU9ZXx8W10sZz0rZHx8MTtkbyBoPWh8fCIuNSIsZy89aCxtLnN0eWxlKGMuZWxlbSxhLGcrZik7d2hpbGUoaCE9PShoPWMuY3VyKCkvZCkmJjEhPT1oJiYtLWkpfXJldHVybiBlJiYoZz1jLnN0YXJ0PStnfHwrZHx8MCxjLnVuaXQ9ZixjLmVuZD1lWzFdP2crKGVbMV0rMSkqZVsyXTorZVsyXSksY31dfTtmdW5jdGlvbiBmYygpe3JldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7JGI9dm9pZCAwfSksJGI9bS5ub3coKX1mdW5jdGlvbiBnYyhhLGIpe3ZhciBjLGQ9e2hlaWdodDphfSxlPTA7Zm9yKGI9Yj8xOjA7ND5lO2UrPTItYiljPVRbZV0sZFsibWFyZ2luIitjXT1kWyJwYWRkaW5nIitjXT1hO3JldHVybiBiJiYoZC5vcGFjaXR5PWQud2lkdGg9YSksZH1mdW5jdGlvbiBoYyhhLGIsYyl7Zm9yKHZhciBkLGU9KGVjW2JdfHxbXSkuY29uY2F0KGVjWyIqIl0pLGY9MCxnPWUubGVuZ3RoO2c+ZjtmKyspaWYoZD1lW2ZdLmNhbGwoYyxiLGEpKXJldHVybiBkfWZ1bmN0aW9uIGljKGEsYixjKXt2YXIgZCxlLGYsZyxoLGksaixsLG49dGhpcyxvPXt9LHA9YS5zdHlsZSxxPWEubm9kZVR5cGUmJlUoYSkscj1tLl9kYXRhKGEsImZ4c2hvdyIpO2MucXVldWV8fChoPW0uX3F1ZXVlSG9va3MoYSwiZngiKSxudWxsPT1oLnVucXVldWVkJiYoaC51bnF1ZXVlZD0wLGk9aC5lbXB0eS5maXJlLGguZW1wdHkuZmlyZT1mdW5jdGlvbigpe2gudW5xdWV1ZWR8fGkoKX0pLGgudW5xdWV1ZWQrKyxuLmFsd2F5cyhmdW5jdGlvbigpe24uYWx3YXlzKGZ1bmN0aW9uKCl7aC51bnF1ZXVlZC0tLG0ucXVldWUoYSwiZngiKS5sZW5ndGh8fGguZW1wdHkuZmlyZSgpfSl9KSksMT09PWEubm9kZVR5cGUmJigiaGVpZ2h0ImluIGJ8fCJ3aWR0aCJpbiBiKSYmKGMub3ZlcmZsb3c9W3Aub3ZlcmZsb3cscC5vdmVyZmxvd1gscC5vdmVyZmxvd1ldLGo9bS5jc3MoYSwiZGlzcGxheSIpLGw9Im5vbmUiPT09aj9tLl9kYXRhKGEsIm9sZGRpc3BsYXkiKXx8RmIoYS5ub2RlTmFtZSk6aiwiaW5saW5lIj09PWwmJiJub25lIj09PW0uY3NzKGEsImZsb2F0IikmJihrLmlubGluZUJsb2NrTmVlZHNMYXlvdXQmJiJpbmxpbmUiIT09RmIoYS5ub2RlTmFtZSk/cC56b29tPTE6cC5kaXNwbGF5PSJpbmxpbmUtYmxvY2siKSksYy5vdmVyZmxvdyYmKHAub3ZlcmZsb3c9ImhpZGRlbiIsay5zaHJpbmtXcmFwQmxvY2tzKCl8fG4uYWx3YXlzKGZ1bmN0aW9uKCl7cC5vdmVyZmxvdz1jLm92ZXJmbG93WzBdLHAub3ZlcmZsb3dYPWMub3ZlcmZsb3dbMV0scC5vdmVyZmxvd1k9Yy5vdmVyZmxvd1syXX0pKTtmb3IoZCBpbiBiKWlmKGU9YltkXSxhYy5leGVjKGUpKXtpZihkZWxldGUgYltkXSxmPWZ8fCJ0b2dnbGUiPT09ZSxlPT09KHE/ImhpZGUiOiJzaG93Iikpe2lmKCJzaG93IiE9PWV8fCFyfHx2b2lkIDA9PT1yW2RdKWNvbnRpbnVlO3E9ITB9b1tkXT1yJiZyW2RdfHxtLnN0eWxlKGEsZCl9ZWxzZSBqPXZvaWQgMDtpZihtLmlzRW1wdHlPYmplY3QobykpImlubGluZSI9PT0oIm5vbmUiPT09aj9GYihhLm5vZGVOYW1lKTpqKSYmKHAuZGlzcGxheT1qKTtlbHNle3I/ImhpZGRlbiJpbiByJiYocT1yLmhpZGRlbik6cj1tLl9kYXRhKGEsImZ4c2hvdyIse30pLGYmJihyLmhpZGRlbj0hcSkscT9tKGEpLnNob3coKTpuLmRvbmUoZnVuY3Rpb24oKXttKGEpLmhpZGUoKX0pLG4uZG9uZShmdW5jdGlvbigpe3ZhciBiO20uX3JlbW92ZURhdGEoYSwiZnhzaG93Iik7Zm9yKGIgaW4gbyltLnN0eWxlKGEsYixvW2JdKX0pO2ZvcihkIGluIG8pZz1oYyhxP3JbZF06MCxkLG4pLGQgaW4gcnx8KHJbZF09Zy5zdGFydCxxJiYoZy5lbmQ9Zy5zdGFydCxnLnN0YXJ0PSJ3aWR0aCI9PT1kfHwiaGVpZ2h0Ij09PWQ/MTowKSl9fWZ1bmN0aW9uIGpjKGEsYil7dmFyIGMsZCxlLGYsZztmb3IoYyBpbiBhKWlmKGQ9bS5jYW1lbENhc2UoYyksZT1iW2RdLGY9YVtjXSxtLmlzQXJyYXkoZikmJihlPWZbMV0sZj1hW2NdPWZbMF0pLGMhPT1kJiYoYVtkXT1mLGRlbGV0ZSBhW2NdKSxnPW0uY3NzSG9va3NbZF0sZyYmImV4cGFuZCJpbiBnKXtmPWcuZXhwYW5kKGYpLGRlbGV0ZSBhW2RdO2ZvcihjIGluIGYpYyBpbiBhfHwoYVtjXT1mW2NdLGJbY109ZSl9ZWxzZSBiW2RdPWV9ZnVuY3Rpb24ga2MoYSxiLGMpe3ZhciBkLGUsZj0wLGc9ZGMubGVuZ3RoLGg9bS5EZWZlcnJlZCgpLmFsd2F5cyhmdW5jdGlvbigpe2RlbGV0ZSBpLmVsZW19KSxpPWZ1bmN0aW9uKCl7aWYoZSlyZXR1cm4hMTtmb3IodmFyIGI9JGJ8fGZjKCksYz1NYXRoLm1heCgwLGouc3RhcnRUaW1lK2ouZHVyYXRpb24tYiksZD1jL2ouZHVyYXRpb258fDAsZj0xLWQsZz0wLGk9ai50d2VlbnMubGVuZ3RoO2k+ZztnKyspai50d2VlbnNbZ10ucnVuKGYpO3JldHVybiBoLm5vdGlmeVdpdGgoYSxbaixmLGNdKSwxPmYmJmk/YzooaC5yZXNvbHZlV2l0aChhLFtqXSksITEpfSxqPWgucHJvbWlzZSh7ZWxlbTphLHByb3BzOm0uZXh0ZW5kKHt9LGIpLG9wdHM6bS5leHRlbmQoITAse3NwZWNpYWxFYXNpbmc6e319LGMpLG9yaWdpbmFsUHJvcGVydGllczpiLG9yaWdpbmFsT3B0aW9uczpjLHN0YXJ0VGltZTokYnx8ZmMoKSxkdXJhdGlvbjpjLmR1cmF0aW9uLHR3ZWVuczpbXSxjcmVhdGVUd2VlbjpmdW5jdGlvbihiLGMpe3ZhciBkPW0uVHdlZW4oYSxqLm9wdHMsYixjLGoub3B0cy5zcGVjaWFsRWFzaW5nW2JdfHxqLm9wdHMuZWFzaW5nKTtyZXR1cm4gai50d2VlbnMucHVzaChkKSxkfSxzdG9wOmZ1bmN0aW9uKGIpe3ZhciBjPTAsZD1iP2oudHdlZW5zLmxlbmd0aDowO2lmKGUpcmV0dXJuIHRoaXM7Zm9yKGU9ITA7ZD5jO2MrKylqLnR3ZWVuc1tjXS5ydW4oMSk7cmV0dXJuIGI/aC5yZXNvbHZlV2l0aChhLFtqLGJdKTpoLnJlamVjdFdpdGgoYSxbaixiXSksdGhpc319KSxrPWoucHJvcHM7Zm9yKGpjKGssai5vcHRzLnNwZWNpYWxFYXNpbmcpO2c+ZjtmKyspaWYoZD1kY1tmXS5jYWxsKGosYSxrLGoub3B0cykpcmV0dXJuIGQ7cmV0dXJuIG0ubWFwKGssaGMsaiksbS5pc0Z1bmN0aW9uKGoub3B0cy5zdGFydCkmJmoub3B0cy5zdGFydC5jYWxsKGEsaiksbS5meC50aW1lcihtLmV4dGVuZChpLHtlbGVtOmEsYW5pbTpqLHF1ZXVlOmoub3B0cy5xdWV1ZX0pKSxqLnByb2dyZXNzKGoub3B0cy5wcm9ncmVzcykuZG9uZShqLm9wdHMuZG9uZSxqLm9wdHMuY29tcGxldGUpLmZhaWwoai5vcHRzLmZhaWwpLmFsd2F5cyhqLm9wdHMuYWx3YXlzKX1tLkFuaW1hdGlvbj1tLmV4dGVuZChrYyx7dHdlZW5lcjpmdW5jdGlvbihhLGIpe20uaXNGdW5jdGlvbihhKT8oYj1hLGE9WyIqIl0pOmE9YS5zcGxpdCgiICIpO2Zvcih2YXIgYyxkPTAsZT1hLmxlbmd0aDtlPmQ7ZCsrKWM9YVtkXSxlY1tjXT1lY1tjXXx8W10sZWNbY10udW5zaGlmdChiKX0scHJlZmlsdGVyOmZ1bmN0aW9uKGEsYil7Yj9kYy51bnNoaWZ0KGEpOmRjLnB1c2goYSl9fSksbS5zcGVlZD1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9YSYmIm9iamVjdCI9PXR5cGVvZiBhP20uZXh0ZW5kKHt9LGEpOntjb21wbGV0ZTpjfHwhYyYmYnx8bS5pc0Z1bmN0aW9uKGEpJiZhLGR1cmF0aW9uOmEsZWFzaW5nOmMmJmJ8fGImJiFtLmlzRnVuY3Rpb24oYikmJmJ9O3JldHVybiBkLmR1cmF0aW9uPW0uZngub2ZmPzA6Im51bWJlciI9PXR5cGVvZiBkLmR1cmF0aW9uP2QuZHVyYXRpb246ZC5kdXJhdGlvbiBpbiBtLmZ4LnNwZWVkcz9tLmZ4LnNwZWVkc1tkLmR1cmF0aW9uXTptLmZ4LnNwZWVkcy5fZGVmYXVsdCwobnVsbD09ZC5xdWV1ZXx8ZC5xdWV1ZT09PSEwKSYmKGQucXVldWU9ImZ4IiksZC5vbGQ9ZC5jb21wbGV0ZSxkLmNvbXBsZXRlPWZ1bmN0aW9uKCl7bS5pc0Z1bmN0aW9uKGQub2xkKSYmZC5vbGQuY2FsbCh0aGlzKSxkLnF1ZXVlJiZtLmRlcXVldWUodGhpcyxkLnF1ZXVlKX0sZH0sbS5mbi5leHRlbmQoe2ZhZGVUbzpmdW5jdGlvbihhLGIsYyxkKXtyZXR1cm4gdGhpcy5maWx0ZXIoVSkuY3NzKCJvcGFjaXR5IiwwKS5zaG93KCkuZW5kKCkuYW5pbWF0ZSh7b3BhY2l0eTpifSxhLGMsZCl9LGFuaW1hdGU6ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9bS5pc0VtcHR5T2JqZWN0KGEpLGY9bS5zcGVlZChiLGMsZCksZz1mdW5jdGlvbigpe3ZhciBiPWtjKHRoaXMsbS5leHRlbmQoe30sYSksZik7KGV8fG0uX2RhdGEodGhpcywiZmluaXNoIikpJiZiLnN0b3AoITApfTtyZXR1cm4gZy5maW5pc2g9ZyxlfHxmLnF1ZXVlPT09ITE/dGhpcy5lYWNoKGcpOnRoaXMucXVldWUoZi5xdWV1ZSxnKX0sc3RvcDpmdW5jdGlvbihhLGIsYyl7dmFyIGQ9ZnVuY3Rpb24oYSl7dmFyIGI9YS5zdG9wO2RlbGV0ZSBhLnN0b3AsYihjKX07cmV0dXJuInN0cmluZyIhPXR5cGVvZiBhJiYoYz1iLGI9YSxhPXZvaWQgMCksYiYmYSE9PSExJiZ0aGlzLnF1ZXVlKGF8fCJmeCIsW10pLHRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciBiPSEwLGU9bnVsbCE9YSYmYSsicXVldWVIb29rcyIsZj1tLnRpbWVycyxnPW0uX2RhdGEodGhpcyk7aWYoZSlnW2VdJiZnW2VdLnN0b3AmJmQoZ1tlXSk7ZWxzZSBmb3IoZSBpbiBnKWdbZV0mJmdbZV0uc3RvcCYmY2MudGVzdChlKSYmZChnW2VdKTtmb3IoZT1mLmxlbmd0aDtlLS07KWZbZV0uZWxlbSE9PXRoaXN8fG51bGwhPWEmJmZbZV0ucXVldWUhPT1hfHwoZltlXS5hbmltLnN0b3AoYyksYj0hMSxmLnNwbGljZShlLDEpKTsoYnx8IWMpJiZtLmRlcXVldWUodGhpcyxhKX0pfSxmaW5pc2g6ZnVuY3Rpb24oYSl7cmV0dXJuIGEhPT0hMSYmKGE9YXx8ImZ4IiksdGhpcy5lYWNoKGZ1bmN0aW9uKCl7dmFyIGIsYz1tLl9kYXRhKHRoaXMpLGQ9Y1thKyJxdWV1ZSJdLGU9Y1thKyJxdWV1ZUhvb2tzIl0sZj1tLnRpbWVycyxnPWQ/ZC5sZW5ndGg6MDtmb3IoYy5maW5pc2g9ITAsbS5xdWV1ZSh0aGlzLGEsW10pLGUmJmUuc3RvcCYmZS5zdG9wLmNhbGwodGhpcywhMCksYj1mLmxlbmd0aDtiLS07KWZbYl0uZWxlbT09PXRoaXMmJmZbYl0ucXVldWU9PT1hJiYoZltiXS5hbmltLnN0b3AoITApLGYuc3BsaWNlKGIsMSkpO2ZvcihiPTA7Zz5iO2IrKylkW2JdJiZkW2JdLmZpbmlzaCYmZFtiXS5maW5pc2guY2FsbCh0aGlzKTtkZWxldGUgYy5maW5pc2h9KX19KSxtLmVhY2goWyJ0b2dnbGUiLCJzaG93IiwiaGlkZSJdLGZ1bmN0aW9uKGEsYil7dmFyIGM9bS5mbltiXTttLmZuW2JdPWZ1bmN0aW9uKGEsZCxlKXtyZXR1cm4gbnVsbD09YXx8ImJvb2xlYW4iPT10eXBlb2YgYT9jLmFwcGx5KHRoaXMsYXJndW1lbnRzKTp0aGlzLmFuaW1hdGUoZ2MoYiwhMCksYSxkLGUpfX0pLG0uZWFjaCh7c2xpZGVEb3duOmdjKCJzaG93Iiksc2xpZGVVcDpnYygiaGlkZSIpLHNsaWRlVG9nZ2xlOmdjKCJ0b2dnbGUiKSxmYWRlSW46e29wYWNpdHk6InNob3cifSxmYWRlT3V0OntvcGFjaXR5OiJoaWRlIn0sZmFkZVRvZ2dsZTp7b3BhY2l0eToidG9nZ2xlIn19LGZ1bmN0aW9uKGEsYil7bS5mblthXT1mdW5jdGlvbihhLGMsZCl7cmV0dXJuIHRoaXMuYW5pbWF0ZShiLGEsYyxkKX19KSxtLnRpbWVycz1bXSxtLmZ4LnRpY2s9ZnVuY3Rpb24oKXt2YXIgYSxiPW0udGltZXJzLGM9MDtmb3IoJGI9bS5ub3coKTtjPGIubGVuZ3RoO2MrKylhPWJbY10sYSgpfHxiW2NdIT09YXx8Yi5zcGxpY2UoYy0tLDEpO2IubGVuZ3RofHxtLmZ4LnN0b3AoKSwkYj12b2lkIDB9LG0uZngudGltZXI9ZnVuY3Rpb24oYSl7bS50aW1lcnMucHVzaChhKSxhKCk/bS5meC5zdGFydCgpOm0udGltZXJzLnBvcCgpfSxtLmZ4LmludGVydmFsPTEzLG0uZnguc3RhcnQ9ZnVuY3Rpb24oKXtfYnx8KF9iPXNldEludGVydmFsKG0uZngudGljayxtLmZ4LmludGVydmFsKSl9LG0uZnguc3RvcD1mdW5jdGlvbigpe2NsZWFySW50ZXJ2YWwoX2IpLF9iPW51bGx9LG0uZnguc3BlZWRzPXtzbG93OjYwMCxmYXN0OjIwMCxfZGVmYXVsdDo0MDB9LG0uZm4uZGVsYXk9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYT1tLmZ4P20uZnguc3BlZWRzW2FdfHxhOmEsYj1ifHwiZngiLHRoaXMucXVldWUoYixmdW5jdGlvbihiLGMpe3ZhciBkPXNldFRpbWVvdXQoYixhKTtjLnN0b3A9ZnVuY3Rpb24oKXtjbGVhclRpbWVvdXQoZCl9fSl9LGZ1bmN0aW9uKCl7dmFyIGEsYixjLGQsZTtiPXkuY3JlYXRlRWxlbWVudCgiZGl2IiksYi5zZXRBdHRyaWJ1dGUoImNsYXNzTmFtZSIsInQiKSxiLmlubmVySFRNTD0iICA8bGluay8+PHRhYmxlPjwvdGFibGU+PGEgaHJlZj0nL2EnPmE8L2E+PGlucHV0IHR5cGU9J2NoZWNrYm94Jy8+IixkPWIuZ2V0RWxlbWVudHNCeVRhZ05hbWUoImEiKVswXSxjPXkuY3JlYXRlRWxlbWVudCgic2VsZWN0IiksZT1jLmFwcGVuZENoaWxkKHkuY3JlYXRlRWxlbWVudCgib3B0aW9uIikpLGE9Yi5nZXRFbGVtZW50c0J5VGFnTmFtZSgiaW5wdXQiKVswXSxkLnN0eWxlLmNzc1RleHQ9InRvcDoxcHgiLGsuZ2V0U2V0QXR0cmlidXRlPSJ0IiE9PWIuY2xhc3NOYW1lLGsuc3R5bGU9L3RvcC8udGVzdChkLmdldEF0dHJpYnV0ZSgic3R5bGUiKSksay5ocmVmTm9ybWFsaXplZD0iL2EiPT09ZC5nZXRBdHRyaWJ1dGUoImhyZWYiKSxrLmNoZWNrT249ISFhLnZhbHVlLGsub3B0U2VsZWN0ZWQ9ZS5zZWxlY3RlZCxrLmVuY3R5cGU9ISF5LmNyZWF0ZUVsZW1lbnQoImZvcm0iKS5lbmN0eXBlLGMuZGlzYWJsZWQ9ITAsay5vcHREaXNhYmxlZD0hZS5kaXNhYmxlZCxhPXkuY3JlYXRlRWxlbWVudCgiaW5wdXQiKSxhLnNldEF0dHJpYnV0ZSgidmFsdWUiLCIiKSxrLmlucHV0PSIiPT09YS5nZXRBdHRyaWJ1dGUoInZhbHVlIiksYS52YWx1ZT0idCIsYS5zZXRBdHRyaWJ1dGUoInR5cGUiLCJyYWRpbyIpLGsucmFkaW9WYWx1ZT0idCI9PT1hLnZhbHVlfSgpO3ZhciBsYz0vXHIvZzttLmZuLmV4dGVuZCh7dmFsOmZ1bmN0aW9uKGEpe3ZhciBiLGMsZCxlPXRoaXNbMF07e2lmKGFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIGQ9bS5pc0Z1bmN0aW9uKGEpLHRoaXMuZWFjaChmdW5jdGlvbihjKXt2YXIgZTsxPT09dGhpcy5ub2RlVHlwZSYmKGU9ZD9hLmNhbGwodGhpcyxjLG0odGhpcykudmFsKCkpOmEsbnVsbD09ZT9lPSIiOiJudW1iZXIiPT10eXBlb2YgZT9lKz0iIjptLmlzQXJyYXkoZSkmJihlPW0ubWFwKGUsZnVuY3Rpb24oYSl7cmV0dXJuIG51bGw9PWE/IiI6YSsiIn0pKSxiPW0udmFsSG9va3NbdGhpcy50eXBlXXx8bS52YWxIb29rc1t0aGlzLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCldLGImJiJzZXQiaW4gYiYmdm9pZCAwIT09Yi5zZXQodGhpcyxlLCJ2YWx1ZSIpfHwodGhpcy52YWx1ZT1lKSl9KTtpZihlKXJldHVybiBiPW0udmFsSG9va3NbZS50eXBlXXx8bS52YWxIb29rc1tlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCldLGImJiJnZXQiaW4gYiYmdm9pZCAwIT09KGM9Yi5nZXQoZSwidmFsdWUiKSk/YzooYz1lLnZhbHVlLCJzdHJpbmciPT10eXBlb2YgYz9jLnJlcGxhY2UobGMsIiIpOm51bGw9PWM/IiI6Yyl9fX0pLG0uZXh0ZW5kKHt2YWxIb29rczp7b3B0aW9uOntnZXQ6ZnVuY3Rpb24oYSl7dmFyIGI9bS5maW5kLmF0dHIoYSwidmFsdWUiKTtyZXR1cm4gbnVsbCE9Yj9iOm0udHJpbShtLnRleHQoYSkpfX0sc2VsZWN0OntnZXQ6ZnVuY3Rpb24oYSl7Zm9yKHZhciBiLGMsZD1hLm9wdGlvbnMsZT1hLnNlbGVjdGVkSW5kZXgsZj0ic2VsZWN0LW9uZSI9PT1hLnR5cGV8fDA+ZSxnPWY/bnVsbDpbXSxoPWY/ZSsxOmQubGVuZ3RoLGk9MD5lP2g6Zj9lOjA7aD5pO2krKylpZihjPWRbaV0sISghYy5zZWxlY3RlZCYmaSE9PWV8fChrLm9wdERpc2FibGVkP2MuZGlzYWJsZWQ6bnVsbCE9PWMuZ2V0QXR0cmlidXRlKCJkaXNhYmxlZCIpKXx8Yy5wYXJlbnROb2RlLmRpc2FibGVkJiZtLm5vZGVOYW1lKGMucGFyZW50Tm9kZSwib3B0Z3JvdXAiKSkpe2lmKGI9bShjKS52YWwoKSxmKXJldHVybiBiO2cucHVzaChiKX1yZXR1cm4gZ30sc2V0OmZ1bmN0aW9uKGEsYil7dmFyIGMsZCxlPWEub3B0aW9ucyxmPW0ubWFrZUFycmF5KGIpLGc9ZS5sZW5ndGg7d2hpbGUoZy0tKWlmKGQ9ZVtnXSxtLmluQXJyYXkobS52YWxIb29rcy5vcHRpb24uZ2V0KGQpLGYpPj0wKXRyeXtkLnNlbGVjdGVkPWM9ITB9Y2F0Y2goaCl7ZC5zY3JvbGxIZWlnaHR9ZWxzZSBkLnNlbGVjdGVkPSExO3JldHVybiBjfHwoYS5zZWxlY3RlZEluZGV4PS0xKSxlfX19fSksbS5lYWNoKFsicmFkaW8iLCJjaGVja2JveCJdLGZ1bmN0aW9uKCl7bS52YWxIb29rc1t0aGlzXT17c2V0OmZ1bmN0aW9uKGEsYil7cmV0dXJuIG0uaXNBcnJheShiKT9hLmNoZWNrZWQ9bS5pbkFycmF5KG0oYSkudmFsKCksYik+PTA6dm9pZCAwfX0say5jaGVja09ufHwobS52YWxIb29rc1t0aGlzXS5nZXQ9ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGw9PT1hLmdldEF0dHJpYnV0ZSgidmFsdWUiKT8ib24iOmEudmFsdWV9KX0pO3ZhciBtYyxuYyxvYz1tLmV4cHIuYXR0ckhhbmRsZSxwYz0vXig/OmNoZWNrZWR8c2VsZWN0ZWQpJC9pLHFjPWsuZ2V0U2V0QXR0cmlidXRlLHJjPWsuaW5wdXQ7bS5mbi5leHRlbmQoe2F0dHI6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gVih0aGlzLG0uYXR0cixhLGIsYXJndW1lbnRzLmxlbmd0aD4xKX0scmVtb3ZlQXR0cjpmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7bS5yZW1vdmVBdHRyKHRoaXMsYSl9KX19KSxtLmV4dGVuZCh7YXR0cjpmdW5jdGlvbihhLGIsYyl7dmFyIGQsZSxmPWEubm9kZVR5cGU7aWYoYSYmMyE9PWYmJjghPT1mJiYyIT09ZilyZXR1cm4gdHlwZW9mIGEuZ2V0QXR0cmlidXRlPT09Sz9tLnByb3AoYSxiLGMpOigxPT09ZiYmbS5pc1hNTERvYyhhKXx8KGI9Yi50b0xvd2VyQ2FzZSgpLGQ9bS5hdHRySG9va3NbYl18fChtLmV4cHIubWF0Y2guYm9vbC50ZXN0KGIpP25jOm1jKSksdm9pZCAwPT09Yz9kJiYiZ2V0ImluIGQmJm51bGwhPT0oZT1kLmdldChhLGIpKT9lOihlPW0uZmluZC5hdHRyKGEsYiksbnVsbD09ZT92b2lkIDA6ZSk6bnVsbCE9PWM/ZCYmInNldCJpbiBkJiZ2b2lkIDAhPT0oZT1kLnNldChhLGMsYikpP2U6KGEuc2V0QXR0cmlidXRlKGIsYysiIiksYyk6dm9pZCBtLnJlbW92ZUF0dHIoYSxiKSl9LHJlbW92ZUF0dHI6ZnVuY3Rpb24oYSxiKXt2YXIgYyxkLGU9MCxmPWImJmIubWF0Y2goRSk7aWYoZiYmMT09PWEubm9kZVR5cGUpd2hpbGUoYz1mW2UrK10pZD1tLnByb3BGaXhbY118fGMsbS5leHByLm1hdGNoLmJvb2wudGVzdChjKT9yYyYmcWN8fCFwYy50ZXN0KGMpP2FbZF09ITE6YVttLmNhbWVsQ2FzZSgiZGVmYXVsdC0iK2MpXT1hW2RdPSExOm0uYXR0cihhLGMsIiIpLGEucmVtb3ZlQXR0cmlidXRlKHFjP2M6ZCl9LGF0dHJIb29rczp7dHlwZTp7c2V0OmZ1bmN0aW9uKGEsYil7aWYoIWsucmFkaW9WYWx1ZSYmInJhZGlvIj09PWImJm0ubm9kZU5hbWUoYSwiaW5wdXQiKSl7dmFyIGM9YS52YWx1ZTtyZXR1cm4gYS5zZXRBdHRyaWJ1dGUoInR5cGUiLGIpLGMmJihhLnZhbHVlPWMpLGJ9fX19fSksbmM9e3NldDpmdW5jdGlvbihhLGIsYyl7cmV0dXJuIGI9PT0hMT9tLnJlbW92ZUF0dHIoYSxjKTpyYyYmcWN8fCFwYy50ZXN0KGMpP2Euc2V0QXR0cmlidXRlKCFxYyYmbS5wcm9wRml4W2NdfHxjLGMpOmFbbS5jYW1lbENhc2UoImRlZmF1bHQtIitjKV09YVtjXT0hMCxjfX0sbS5lYWNoKG0uZXhwci5tYXRjaC5ib29sLnNvdXJjZS5tYXRjaCgvXHcrL2cpLGZ1bmN0aW9uKGEsYil7dmFyIGM9b2NbYl18fG0uZmluZC5hdHRyO29jW2JdPXJjJiZxY3x8IXBjLnRlc3QoYik/ZnVuY3Rpb24oYSxiLGQpe3ZhciBlLGY7cmV0dXJuIGR8fChmPW9jW2JdLG9jW2JdPWUsZT1udWxsIT1jKGEsYixkKT9iLnRvTG93ZXJDYXNlKCk6bnVsbCxvY1tiXT1mKSxlfTpmdW5jdGlvbihhLGIsYyl7cmV0dXJuIGM/dm9pZCAwOmFbbS5jYW1lbENhc2UoImRlZmF1bHQtIitiKV0/Yi50b0xvd2VyQ2FzZSgpOm51bGx9fSkscmMmJnFjfHwobS5hdHRySG9va3MudmFsdWU9e3NldDpmdW5jdGlvbihhLGIsYyl7cmV0dXJuIG0ubm9kZU5hbWUoYSwiaW5wdXQiKT92b2lkKGEuZGVmYXVsdFZhbHVlPWIpOm1jJiZtYy5zZXQoYSxiLGMpfX0pLHFjfHwobWM9e3NldDpmdW5jdGlvbihhLGIsYyl7dmFyIGQ9YS5nZXRBdHRyaWJ1dGVOb2RlKGMpO3JldHVybiBkfHxhLnNldEF0dHJpYnV0ZU5vZGUoZD1hLm93bmVyRG9jdW1lbnQuY3JlYXRlQXR0cmlidXRlKGMpKSxkLnZhbHVlPWIrPSIiLCJ2YWx1ZSI9PT1jfHxiPT09YS5nZXRBdHRyaWJ1dGUoYyk/Yjp2b2lkIDB9fSxvYy5pZD1vYy5uYW1lPW9jLmNvb3Jkcz1mdW5jdGlvbihhLGIsYyl7dmFyIGQ7cmV0dXJuIGM/dm9pZCAwOihkPWEuZ2V0QXR0cmlidXRlTm9kZShiKSkmJiIiIT09ZC52YWx1ZT9kLnZhbHVlOm51bGx9LG0udmFsSG9va3MuYnV0dG9uPXtnZXQ6ZnVuY3Rpb24oYSxiKXt2YXIgYz1hLmdldEF0dHJpYnV0ZU5vZGUoYik7cmV0dXJuIGMmJmMuc3BlY2lmaWVkP2MudmFsdWU6dm9pZCAwfSxzZXQ6bWMuc2V0fSxtLmF0dHJIb29rcy5jb250ZW50ZWRpdGFibGU9e3NldDpmdW5jdGlvbihhLGIsYyl7bWMuc2V0KGEsIiI9PT1iPyExOmIsYyl9fSxtLmVhY2goWyJ3aWR0aCIsImhlaWdodCJdLGZ1bmN0aW9uKGEsYil7bS5hdHRySG9va3NbYl09e3NldDpmdW5jdGlvbihhLGMpe3JldHVybiIiPT09Yz8oYS5zZXRBdHRyaWJ1dGUoYiwiYXV0byIpLGMpOnZvaWQgMH19fSkpLGsuc3R5bGV8fChtLmF0dHJIb29rcy5zdHlsZT17Z2V0OmZ1bmN0aW9uKGEpe3JldHVybiBhLnN0eWxlLmNzc1RleHR8fHZvaWQgMH0sc2V0OmZ1bmN0aW9uKGEsYil7cmV0dXJuIGEuc3R5bGUuY3NzVGV4dD1iKyIifX0pO3ZhciBzYz0vXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b258b2JqZWN0KSQvaSx0Yz0vXig/OmF8YXJlYSkkL2k7bS5mbi5leHRlbmQoe3Byb3A6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gVih0aGlzLG0ucHJvcCxhLGIsYXJndW1lbnRzLmxlbmd0aD4xKX0scmVtb3ZlUHJvcDpmdW5jdGlvbihhKXtyZXR1cm4gYT1tLnByb3BGaXhbYV18fGEsdGhpcy5lYWNoKGZ1bmN0aW9uKCl7dHJ5e3RoaXNbYV09dm9pZCAwLGRlbGV0ZSB0aGlzW2FdfWNhdGNoKGIpe319KX19KSxtLmV4dGVuZCh7cHJvcEZpeDp7ImZvciI6Imh0bWxGb3IiLCJjbGFzcyI6ImNsYXNzTmFtZSJ9LHByb3A6ZnVuY3Rpb24oYSxiLGMpe3ZhciBkLGUsZixnPWEubm9kZVR5cGU7aWYoYSYmMyE9PWcmJjghPT1nJiYyIT09ZylyZXR1cm4gZj0xIT09Z3x8IW0uaXNYTUxEb2MoYSksZiYmKGI9bS5wcm9wRml4W2JdfHxiLGU9bS5wcm9wSG9va3NbYl0pLHZvaWQgMCE9PWM/ZSYmInNldCJpbiBlJiZ2b2lkIDAhPT0oZD1lLnNldChhLGMsYikpP2Q6YVtiXT1jOmUmJiJnZXQiaW4gZSYmbnVsbCE9PShkPWUuZ2V0KGEsYikpP2Q6YVtiXX0scHJvcEhvb2tzOnt0YWJJbmRleDp7Z2V0OmZ1bmN0aW9uKGEpe3ZhciBiPW0uZmluZC5hdHRyKGEsInRhYmluZGV4Iik7cmV0dXJuIGI/cGFyc2VJbnQoYiwxMCk6c2MudGVzdChhLm5vZGVOYW1lKXx8dGMudGVzdChhLm5vZGVOYW1lKSYmYS5ocmVmPzA6LTF9fX19KSxrLmhyZWZOb3JtYWxpemVkfHxtLmVhY2goWyJocmVmIiwic3JjIl0sZnVuY3Rpb24oYSxiKXttLnByb3BIb29rc1tiXT17Z2V0OmZ1bmN0aW9uKGEpe3JldHVybiBhLmdldEF0dHJpYnV0ZShiLDQpfX19KSxrLm9wdFNlbGVjdGVkfHwobS5wcm9wSG9va3Muc2VsZWN0ZWQ9e2dldDpmdW5jdGlvbihhKXt2YXIgYj1hLnBhcmVudE5vZGU7cmV0dXJuIGImJihiLnNlbGVjdGVkSW5kZXgsYi5wYXJlbnROb2RlJiZiLnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleCksbnVsbH19KSxtLmVhY2goWyJ0YWJJbmRleCIsInJlYWRPbmx5IiwibWF4TGVuZ3RoIiwiY2VsbFNwYWNpbmciLCJjZWxsUGFkZGluZyIsInJvd1NwYW4iLCJjb2xTcGFuIiwidXNlTWFwIiwiZnJhbWVCb3JkZXIiLCJjb250ZW50RWRpdGFibGUiXSxmdW5jdGlvbigpe20ucHJvcEZpeFt0aGlzLnRvTG93ZXJDYXNlKCldPXRoaXN9KSxrLmVuY3R5cGV8fChtLnByb3BGaXguZW5jdHlwZT0iZW5jb2RpbmciKTt2YXIgdWM9L1tcdFxyXG5cZl0vZzttLmZuLmV4dGVuZCh7YWRkQ2xhc3M6ZnVuY3Rpb24oYSl7dmFyIGIsYyxkLGUsZixnLGg9MCxpPXRoaXMubGVuZ3RoLGo9InN0cmluZyI9PXR5cGVvZiBhJiZhO2lmKG0uaXNGdW5jdGlvbihhKSlyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGIpe20odGhpcykuYWRkQ2xhc3MoYS5jYWxsKHRoaXMsYix0aGlzLmNsYXNzTmFtZSkpfSk7aWYoailmb3IoYj0oYXx8IiIpLm1hdGNoKEUpfHxbXTtpPmg7aCsrKWlmKGM9dGhpc1toXSxkPTE9PT1jLm5vZGVUeXBlJiYoYy5jbGFzc05hbWU/KCIgIitjLmNsYXNzTmFtZSsiICIpLnJlcGxhY2UodWMsIiAiKToiICIpKXtmPTA7d2hpbGUoZT1iW2YrK10pZC5pbmRleE9mKCIgIitlKyIgIik8MCYmKGQrPWUrIiAiKTtnPW0udHJpbShkKSxjLmNsYXNzTmFtZSE9PWcmJihjLmNsYXNzTmFtZT1nKX1yZXR1cm4gdGhpc30scmVtb3ZlQ2xhc3M6ZnVuY3Rpb24oYSl7dmFyIGIsYyxkLGUsZixnLGg9MCxpPXRoaXMubGVuZ3RoLGo9MD09PWFyZ3VtZW50cy5sZW5ndGh8fCJzdHJpbmciPT10eXBlb2YgYSYmYTtpZihtLmlzRnVuY3Rpb24oYSkpcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihiKXttKHRoaXMpLnJlbW92ZUNsYXNzKGEuY2FsbCh0aGlzLGIsdGhpcy5jbGFzc05hbWUpKX0pO2lmKGopZm9yKGI9KGF8fCIiKS5tYXRjaChFKXx8W107aT5oO2grKylpZihjPXRoaXNbaF0sZD0xPT09Yy5ub2RlVHlwZSYmKGMuY2xhc3NOYW1lPygiICIrYy5jbGFzc05hbWUrIiAiKS5yZXBsYWNlKHVjLCIgIik6IiIpKXtmPTA7d2hpbGUoZT1iW2YrK10pd2hpbGUoZC5pbmRleE9mKCIgIitlKyIgIik+PTApZD1kLnJlcGxhY2UoIiAiK2UrIiAiLCIgIik7Zz1hP20udHJpbShkKToiIixjLmNsYXNzTmFtZSE9PWcmJihjLmNsYXNzTmFtZT1nKX1yZXR1cm4gdGhpc30sdG9nZ2xlQ2xhc3M6ZnVuY3Rpb24oYSxiKXt2YXIgYz10eXBlb2YgYTtyZXR1cm4iYm9vbGVhbiI9PXR5cGVvZiBiJiYic3RyaW5nIj09PWM/Yj90aGlzLmFkZENsYXNzKGEpOnRoaXMucmVtb3ZlQ2xhc3MoYSk6dGhpcy5lYWNoKG0uaXNGdW5jdGlvbihhKT9mdW5jdGlvbihjKXttKHRoaXMpLnRvZ2dsZUNsYXNzKGEuY2FsbCh0aGlzLGMsdGhpcy5jbGFzc05hbWUsYiksYil9OmZ1bmN0aW9uKCl7aWYoInN0cmluZyI9PT1jKXt2YXIgYixkPTAsZT1tKHRoaXMpLGY9YS5tYXRjaChFKXx8W107d2hpbGUoYj1mW2QrK10pZS5oYXNDbGFzcyhiKT9lLnJlbW92ZUNsYXNzKGIpOmUuYWRkQ2xhc3MoYil9ZWxzZShjPT09S3x8ImJvb2xlYW4iPT09YykmJih0aGlzLmNsYXNzTmFtZSYmbS5fZGF0YSh0aGlzLCJfX2NsYXNzTmFtZV9fIix0aGlzLmNsYXNzTmFtZSksdGhpcy5jbGFzc05hbWU9dGhpcy5jbGFzc05hbWV8fGE9PT0hMT8iIjptLl9kYXRhKHRoaXMsIl9fY2xhc3NOYW1lX18iKXx8IiIpfSl9LGhhc0NsYXNzOmZ1bmN0aW9uKGEpe2Zvcih2YXIgYj0iICIrYSsiICIsYz0wLGQ9dGhpcy5sZW5ndGg7ZD5jO2MrKylpZigxPT09dGhpc1tjXS5ub2RlVHlwZSYmKCIgIit0aGlzW2NdLmNsYXNzTmFtZSsiICIpLnJlcGxhY2UodWMsIiAiKS5pbmRleE9mKGIpPj0wKXJldHVybiEwO3JldHVybiExfX0pLG0uZWFjaCgiYmx1ciBmb2N1cyBmb2N1c2luIGZvY3Vzb3V0IGxvYWQgcmVzaXplIHNjcm9sbCB1bmxvYWQgY2xpY2sgZGJsY2xpY2sgbW91c2Vkb3duIG1vdXNldXAgbW91c2Vtb3ZlIG1vdXNlb3ZlciBtb3VzZW91dCBtb3VzZWVudGVyIG1vdXNlbGVhdmUgY2hhbmdlIHNlbGVjdCBzdWJtaXQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBlcnJvciBjb250ZXh0bWVudSIuc3BsaXQoIiAiKSxmdW5jdGlvbihhLGIpe20uZm5bYl09ZnVuY3Rpb24oYSxjKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD4wP3RoaXMub24oYixudWxsLGEsYyk6dGhpcy50cmlnZ2VyKGIpfX0pLG0uZm4uZXh0ZW5kKHtob3ZlcjpmdW5jdGlvbihhLGIpe3JldHVybiB0aGlzLm1vdXNlZW50ZXIoYSkubW91c2VsZWF2ZShifHxhKX0sYmluZDpmdW5jdGlvbihhLGIsYyl7cmV0dXJuIHRoaXMub24oYSxudWxsLGIsYyl9LHVuYmluZDpmdW5jdGlvbihhLGIpe3JldHVybiB0aGlzLm9mZihhLG51bGwsYil9LGRlbGVnYXRlOmZ1bmN0aW9uKGEsYixjLGQpe3JldHVybiB0aGlzLm9uKGIsYSxjLGQpfSx1bmRlbGVnYXRlOmZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gMT09PWFyZ3VtZW50cy5sZW5ndGg/dGhpcy5vZmYoYSwiKioiKTp0aGlzLm9mZihiLGF8fCIqKiIsYyl9fSk7dmFyIHZjPW0ubm93KCksd2M9L1w/Lyx4Yz0vKCwpfChcW3x7KXwofXxdKXwiKD86W14iXFxcclxuXXxcXFsiXFxcL2JmbnJ0XXxcXHVbXGRhLWZBLUZdezR9KSoiXHMqOj98dHJ1ZXxmYWxzZXxudWxsfC0/KD8hMFxkKVxkKyg/OlwuXGQrfCkoPzpbZUVdWystXT9cZCt8KS9nO20ucGFyc2VKU09OPWZ1bmN0aW9uKGIpe2lmKGEuSlNPTiYmYS5KU09OLnBhcnNlKXJldHVybiBhLkpTT04ucGFyc2UoYisiIik7dmFyIGMsZD1udWxsLGU9bS50cmltKGIrIiIpO3JldHVybiBlJiYhbS50cmltKGUucmVwbGFjZSh4YyxmdW5jdGlvbihhLGIsZSxmKXtyZXR1cm4gYyYmYiYmKGQ9MCksMD09PWQ/YTooYz1lfHxiLGQrPSFmLSFlLCIiKX0pKT9GdW5jdGlvbigicmV0dXJuICIrZSkoKTptLmVycm9yKCJJbnZhbGlkIEpTT046ICIrYil9LG0ucGFyc2VYTUw9ZnVuY3Rpb24oYil7dmFyIGMsZDtpZighYnx8InN0cmluZyIhPXR5cGVvZiBiKXJldHVybiBudWxsO3RyeXthLkRPTVBhcnNlcj8oZD1uZXcgRE9NUGFyc2VyLGM9ZC5wYXJzZUZyb21TdHJpbmcoYiwidGV4dC94bWwiKSk6KGM9bmV3IEFjdGl2ZVhPYmplY3QoIk1pY3Jvc29mdC5YTUxET00iKSxjLmFzeW5jPSJmYWxzZSIsYy5sb2FkWE1MKGIpKX1jYXRjaChlKXtjPXZvaWQgMH1yZXR1cm4gYyYmYy5kb2N1bWVudEVsZW1lbnQmJiFjLmdldEVsZW1lbnRzQnlUYWdOYW1lKCJwYXJzZXJlcnJvciIpLmxlbmd0aHx8bS5lcnJvcigiSW52YWxpZCBYTUw6ICIrYiksY307dmFyIHljLHpjLEFjPS8jLiokLyxCYz0vKFs/Jl0pXz1bXiZdKi8sQ2M9L14oLio/KTpbIFx0XSooW15cclxuXSopXHI/JC9nbSxEYz0vXig/OmFib3V0fGFwcHxhcHAtc3RvcmFnZXwuKy1leHRlbnNpb258ZmlsZXxyZXN8d2lkZ2V0KTokLyxFYz0vXig/OkdFVHxIRUFEKSQvLEZjPS9eXC9cLy8sR2M9L14oW1x3ListXSs6KSg/OlwvXC8oPzpbXlwvPyNdKkB8KShbXlwvPyM6XSopKD86OihcZCspfCl8KS8sSGM9e30sSWM9e30sSmM9IiovIi5jb25jYXQoIioiKTt0cnl7emM9bG9jYXRpb24uaHJlZn1jYXRjaChLYyl7emM9eS5jcmVhdGVFbGVtZW50KCJhIiksemMuaHJlZj0iIix6Yz16Yy5ocmVmfXljPUdjLmV4ZWMoemMudG9Mb3dlckNhc2UoKSl8fFtdO2Z1bmN0aW9uIExjKGEpe3JldHVybiBmdW5jdGlvbihiLGMpeyJzdHJpbmciIT10eXBlb2YgYiYmKGM9YixiPSIqIik7dmFyIGQsZT0wLGY9Yi50b0xvd2VyQ2FzZSgpLm1hdGNoKEUpfHxbXTtpZihtLmlzRnVuY3Rpb24oYykpd2hpbGUoZD1mW2UrK10pIisiPT09ZC5jaGFyQXQoMCk/KGQ9ZC5zbGljZSgxKXx8IioiLChhW2RdPWFbZF18fFtdKS51bnNoaWZ0KGMpKTooYVtkXT1hW2RdfHxbXSkucHVzaChjKX19ZnVuY3Rpb24gTWMoYSxiLGMsZCl7dmFyIGU9e30sZj1hPT09SWM7ZnVuY3Rpb24gZyhoKXt2YXIgaTtyZXR1cm4gZVtoXT0hMCxtLmVhY2goYVtoXXx8W10sZnVuY3Rpb24oYSxoKXt2YXIgaj1oKGIsYyxkKTtyZXR1cm4ic3RyaW5nIiE9dHlwZW9mIGp8fGZ8fGVbal0/Zj8hKGk9aik6dm9pZCAwOihiLmRhdGFUeXBlcy51bnNoaWZ0KGopLGcoaiksITEpfSksaX1yZXR1cm4gZyhiLmRhdGFUeXBlc1swXSl8fCFlWyIqIl0mJmcoIioiKX1mdW5jdGlvbiBOYyhhLGIpe3ZhciBjLGQsZT1tLmFqYXhTZXR0aW5ncy5mbGF0T3B0aW9uc3x8e307Zm9yKGQgaW4gYil2b2lkIDAhPT1iW2RdJiYoKGVbZF0/YTpjfHwoYz17fSkpW2RdPWJbZF0pO3JldHVybiBjJiZtLmV4dGVuZCghMCxhLGMpLGF9ZnVuY3Rpb24gT2MoYSxiLGMpe3ZhciBkLGUsZixnLGg9YS5jb250ZW50cyxpPWEuZGF0YVR5cGVzO3doaWxlKCIqIj09PWlbMF0paS5zaGlmdCgpLHZvaWQgMD09PWUmJihlPWEubWltZVR5cGV8fGIuZ2V0UmVzcG9uc2VIZWFkZXIoIkNvbnRlbnQtVHlwZSIpKTtpZihlKWZvcihnIGluIGgpaWYoaFtnXSYmaFtnXS50ZXN0KGUpKXtpLnVuc2hpZnQoZyk7YnJlYWt9aWYoaVswXWluIGMpZj1pWzBdO2Vsc2V7Zm9yKGcgaW4gYyl7aWYoIWlbMF18fGEuY29udmVydGVyc1tnKyIgIitpWzBdXSl7Zj1nO2JyZWFrfWR8fChkPWcpfWY9Znx8ZH1yZXR1cm4gZj8oZiE9PWlbMF0mJmkudW5zaGlmdChmKSxjW2ZdKTp2b2lkIDB9ZnVuY3Rpb24gUGMoYSxiLGMsZCl7dmFyIGUsZixnLGgsaSxqPXt9LGs9YS5kYXRhVHlwZXMuc2xpY2UoKTtpZihrWzFdKWZvcihnIGluIGEuY29udmVydGVycylqW2cudG9Mb3dlckNhc2UoKV09YS5jb252ZXJ0ZXJzW2ddO2Y9ay5zaGlmdCgpO3doaWxlKGYpaWYoYS5yZXNwb25zZUZpZWxkc1tmXSYmKGNbYS5yZXNwb25zZUZpZWxkc1tmXV09YiksIWkmJmQmJmEuZGF0YUZpbHRlciYmKGI9YS5kYXRhRmlsdGVyKGIsYS5kYXRhVHlwZSkpLGk9ZixmPWsuc2hpZnQoKSlpZigiKiI9PT1mKWY9aTtlbHNlIGlmKCIqIiE9PWkmJmkhPT1mKXtpZihnPWpbaSsiICIrZl18fGpbIiogIitmXSwhZylmb3IoZSBpbiBqKWlmKGg9ZS5zcGxpdCgiICIpLGhbMV09PT1mJiYoZz1qW2krIiAiK2hbMF1dfHxqWyIqICIraFswXV0pKXtnPT09ITA/Zz1qW2VdOmpbZV0hPT0hMCYmKGY9aFswXSxrLnVuc2hpZnQoaFsxXSkpO2JyZWFrfWlmKGchPT0hMClpZihnJiZhWyJ0aHJvd3MiXSliPWcoYik7ZWxzZSB0cnl7Yj1nKGIpfWNhdGNoKGwpe3JldHVybntzdGF0ZToicGFyc2VyZXJyb3IiLGVycm9yOmc/bDoiTm8gY29udmVyc2lvbiBmcm9tICIraSsiIHRvICIrZn19fXJldHVybntzdGF0ZToic3VjY2VzcyIsZGF0YTpifX1tLmV4dGVuZCh7YWN0aXZlOjAsbGFzdE1vZGlmaWVkOnt9LGV0YWc6e30sYWpheFNldHRpbmdzOnt1cmw6emMsdHlwZToiR0VUIixpc0xvY2FsOkRjLnRlc3QoeWNbMV0pLGdsb2JhbDohMCxwcm9jZXNzRGF0YTohMCxhc3luYzohMCxjb250ZW50VHlwZToiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PVVURi04IixhY2NlcHRzOnsiKiI6SmMsdGV4dDoidGV4dC9wbGFpbiIsaHRtbDoidGV4dC9odG1sIix4bWw6ImFwcGxpY2F0aW9uL3htbCwgdGV4dC94bWwiLGpzb246ImFwcGxpY2F0aW9uL2pzb24sIHRleHQvamF2YXNjcmlwdCJ9LGNvbnRlbnRzOnt4bWw6L3htbC8saHRtbDovaHRtbC8sanNvbjovanNvbi99LHJlc3BvbnNlRmllbGRzOnt4bWw6InJlc3BvbnNlWE1MIix0ZXh0OiJyZXNwb25zZVRleHQiLGpzb246InJlc3BvbnNlSlNPTiJ9LGNvbnZlcnRlcnM6eyIqIHRleHQiOlN0cmluZywidGV4dCBodG1sIjohMCwidGV4dCBqc29uIjptLnBhcnNlSlNPTiwidGV4dCB4bWwiOm0ucGFyc2VYTUx9LGZsYXRPcHRpb25zOnt1cmw6ITAsY29udGV4dDohMH19LGFqYXhTZXR1cDpmdW5jdGlvbihhLGIpe3JldHVybiBiP05jKE5jKGEsbS5hamF4U2V0dGluZ3MpLGIpOk5jKG0uYWpheFNldHRpbmdzLGEpfSxhamF4UHJlZmlsdGVyOkxjKEhjKSxhamF4VHJhbnNwb3J0OkxjKEljKSxhamF4OmZ1bmN0aW9uKGEsYil7Im9iamVjdCI9PXR5cGVvZiBhJiYoYj1hLGE9dm9pZCAwKSxiPWJ8fHt9O3ZhciBjLGQsZSxmLGcsaCxpLGosaz1tLmFqYXhTZXR1cCh7fSxiKSxsPWsuY29udGV4dHx8ayxuPWsuY29udGV4dCYmKGwubm9kZVR5cGV8fGwuanF1ZXJ5KT9tKGwpOm0uZXZlbnQsbz1tLkRlZmVycmVkKCkscD1tLkNhbGxiYWNrcygib25jZSBtZW1vcnkiKSxxPWsuc3RhdHVzQ29kZXx8e30scj17fSxzPXt9LHQ9MCx1PSJjYW5jZWxlZCIsdj17cmVhZHlTdGF0ZTowLGdldFJlc3BvbnNlSGVhZGVyOmZ1bmN0aW9uKGEpe3ZhciBiO2lmKDI9PT10KXtpZighail7aj17fTt3aGlsZShiPUNjLmV4ZWMoZikpaltiWzFdLnRvTG93ZXJDYXNlKCldPWJbMl19Yj1qW2EudG9Mb3dlckNhc2UoKV19cmV0dXJuIG51bGw9PWI/bnVsbDpifSxnZXRBbGxSZXNwb25zZUhlYWRlcnM6ZnVuY3Rpb24oKXtyZXR1cm4gMj09PXQ/ZjpudWxsfSxzZXRSZXF1ZXN0SGVhZGVyOmZ1bmN0aW9uKGEsYil7dmFyIGM9YS50b0xvd2VyQ2FzZSgpO3JldHVybiB0fHwoYT1zW2NdPXNbY118fGEsclthXT1iKSx0aGlzfSxvdmVycmlkZU1pbWVUeXBlOmZ1bmN0aW9uKGEpe3JldHVybiB0fHwoay5taW1lVHlwZT1hKSx0aGlzfSxzdGF0dXNDb2RlOmZ1bmN0aW9uKGEpe3ZhciBiO2lmKGEpaWYoMj50KWZvcihiIGluIGEpcVtiXT1bcVtiXSxhW2JdXTtlbHNlIHYuYWx3YXlzKGFbdi5zdGF0dXNdKTtyZXR1cm4gdGhpc30sYWJvcnQ6ZnVuY3Rpb24oYSl7dmFyIGI9YXx8dTtyZXR1cm4gaSYmaS5hYm9ydChiKSx4KDAsYiksdGhpc319O2lmKG8ucHJvbWlzZSh2KS5jb21wbGV0ZT1wLmFkZCx2LnN1Y2Nlc3M9di5kb25lLHYuZXJyb3I9di5mYWlsLGsudXJsPSgoYXx8ay51cmx8fHpjKSsiIikucmVwbGFjZShBYywiIikucmVwbGFjZShGYyx5Y1sxXSsiLy8iKSxrLnR5cGU9Yi5tZXRob2R8fGIudHlwZXx8ay5tZXRob2R8fGsudHlwZSxrLmRhdGFUeXBlcz1tLnRyaW0oay5kYXRhVHlwZXx8IioiKS50b0xvd2VyQ2FzZSgpLm1hdGNoKEUpfHxbIiJdLG51bGw9PWsuY3Jvc3NEb21haW4mJihjPUdjLmV4ZWMoay51cmwudG9Mb3dlckNhc2UoKSksay5jcm9zc0RvbWFpbj0hKCFjfHxjWzFdPT09eWNbMV0mJmNbMl09PT15Y1syXSYmKGNbM118fCgiaHR0cDoiPT09Y1sxXT8iODAiOiI0NDMiKSk9PT0oeWNbM118fCgiaHR0cDoiPT09eWNbMV0/IjgwIjoiNDQzIikpKSksay5kYXRhJiZrLnByb2Nlc3NEYXRhJiYic3RyaW5nIiE9dHlwZW9mIGsuZGF0YSYmKGsuZGF0YT1tLnBhcmFtKGsuZGF0YSxrLnRyYWRpdGlvbmFsKSksTWMoSGMsayxiLHYpLDI9PT10KXJldHVybiB2O2g9ay5nbG9iYWwsaCYmMD09PW0uYWN0aXZlKysmJm0uZXZlbnQudHJpZ2dlcigiYWpheFN0YXJ0Iiksay50eXBlPWsudHlwZS50b1VwcGVyQ2FzZSgpLGsuaGFzQ29udGVudD0hRWMudGVzdChrLnR5cGUpLGU9ay51cmwsay5oYXNDb250ZW50fHwoay5kYXRhJiYoZT1rLnVybCs9KHdjLnRlc3QoZSk/IiYiOiI/Iikray5kYXRhLGRlbGV0ZSBrLmRhdGEpLGsuY2FjaGU9PT0hMSYmKGsudXJsPUJjLnRlc3QoZSk/ZS5yZXBsYWNlKEJjLCIkMV89Iit2YysrKTplKyh3Yy50ZXN0KGUpPyImIjoiPyIpKyJfPSIrdmMrKykpLGsuaWZNb2RpZmllZCYmKG0ubGFzdE1vZGlmaWVkW2VdJiZ2LnNldFJlcXVlc3RIZWFkZXIoIklmLU1vZGlmaWVkLVNpbmNlIixtLmxhc3RNb2RpZmllZFtlXSksbS5ldGFnW2VdJiZ2LnNldFJlcXVlc3RIZWFkZXIoIklmLU5vbmUtTWF0Y2giLG0uZXRhZ1tlXSkpLChrLmRhdGEmJmsuaGFzQ29udGVudCYmay5jb250ZW50VHlwZSE9PSExfHxiLmNvbnRlbnRUeXBlKSYmdi5zZXRSZXF1ZXN0SGVhZGVyKCJDb250ZW50LVR5cGUiLGsuY29udGVudFR5cGUpLHYuc2V0UmVxdWVzdEhlYWRlcigiQWNjZXB0IixrLmRhdGFUeXBlc1swXSYmay5hY2NlcHRzW2suZGF0YVR5cGVzWzBdXT9rLmFjY2VwdHNbay5kYXRhVHlwZXNbMF1dKygiKiIhPT1rLmRhdGFUeXBlc1swXT8iLCAiK0pjKyI7IHE9MC4wMSI6IiIpOmsuYWNjZXB0c1siKiJdKTtmb3IoZCBpbiBrLmhlYWRlcnMpdi5zZXRSZXF1ZXN0SGVhZGVyKGQsay5oZWFkZXJzW2RdKTtpZihrLmJlZm9yZVNlbmQmJihrLmJlZm9yZVNlbmQuY2FsbChsLHYsayk9PT0hMXx8Mj09PXQpKXJldHVybiB2LmFib3J0KCk7dT0iYWJvcnQiO2ZvcihkIGlue3N1Y2Nlc3M6MSxlcnJvcjoxLGNvbXBsZXRlOjF9KXZbZF0oa1tkXSk7aWYoaT1NYyhJYyxrLGIsdikpe3YucmVhZHlTdGF0ZT0xLGgmJm4udHJpZ2dlcigiYWpheFNlbmQiLFt2LGtdKSxrLmFzeW5jJiZrLnRpbWVvdXQ+MCYmKGc9c2V0VGltZW91dChmdW5jdGlvbigpe3YuYWJvcnQoInRpbWVvdXQiKX0say50aW1lb3V0KSk7dHJ5e3Q9MSxpLnNlbmQocix4KX1jYXRjaCh3KXtpZighKDI+dCkpdGhyb3cgdzt4KC0xLHcpfX1lbHNlIHgoLTEsIk5vIFRyYW5zcG9ydCIpO2Z1bmN0aW9uIHgoYSxiLGMsZCl7dmFyIGoscixzLHUsdyx4PWI7MiE9PXQmJih0PTIsZyYmY2xlYXJUaW1lb3V0KGcpLGk9dm9pZCAwLGY9ZHx8IiIsdi5yZWFkeVN0YXRlPWE+MD80OjAsaj1hPj0yMDAmJjMwMD5hfHwzMDQ9PT1hLGMmJih1PU9jKGssdixjKSksdT1QYyhrLHUsdixqKSxqPyhrLmlmTW9kaWZpZWQmJih3PXYuZ2V0UmVzcG9uc2VIZWFkZXIoIkxhc3QtTW9kaWZpZWQiKSx3JiYobS5sYXN0TW9kaWZpZWRbZV09dyksdz12LmdldFJlc3BvbnNlSGVhZGVyKCJldGFnIiksdyYmKG0uZXRhZ1tlXT13KSksMjA0PT09YXx8IkhFQUQiPT09ay50eXBlP3g9Im5vY29udGVudCI6MzA0PT09YT94PSJub3Rtb2RpZmllZCI6KHg9dS5zdGF0ZSxyPXUuZGF0YSxzPXUuZXJyb3Isaj0hcykpOihzPXgsKGF8fCF4KSYmKHg9ImVycm9yIiwwPmEmJihhPTApKSksdi5zdGF0dXM9YSx2LnN0YXR1c1RleHQ9KGJ8fHgpKyIiLGo/by5yZXNvbHZlV2l0aChsLFtyLHgsdl0pOm8ucmVqZWN0V2l0aChsLFt2LHgsc10pLHYuc3RhdHVzQ29kZShxKSxxPXZvaWQgMCxoJiZuLnRyaWdnZXIoaj8iYWpheFN1Y2Nlc3MiOiJhamF4RXJyb3IiLFt2LGssaj9yOnNdKSxwLmZpcmVXaXRoKGwsW3YseF0pLGgmJihuLnRyaWdnZXIoImFqYXhDb21wbGV0ZSIsW3Ysa10pLC0tbS5hY3RpdmV8fG0uZXZlbnQudHJpZ2dlcigiYWpheFN0b3AiKSkpfXJldHVybiB2fSxnZXRKU09OOmZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gbS5nZXQoYSxiLGMsImpzb24iKX0sZ2V0U2NyaXB0OmZ1bmN0aW9uKGEsYil7cmV0dXJuIG0uZ2V0KGEsdm9pZCAwLGIsInNjcmlwdCIpfX0pLG0uZWFjaChbImdldCIsInBvc3QiXSxmdW5jdGlvbihhLGIpe21bYl09ZnVuY3Rpb24oYSxjLGQsZSl7cmV0dXJuIG0uaXNGdW5jdGlvbihjKSYmKGU9ZXx8ZCxkPWMsYz12b2lkIDApLG0uYWpheCh7dXJsOmEsdHlwZTpiLGRhdGFUeXBlOmUsZGF0YTpjLHN1Y2Nlc3M6ZH0pfX0pLG0uZWFjaChbImFqYXhTdGFydCIsImFqYXhTdG9wIiwiYWpheENvbXBsZXRlIiwiYWpheEVycm9yIiwiYWpheFN1Y2Nlc3MiLCJhamF4U2VuZCJdLGZ1bmN0aW9uKGEsYil7bS5mbltiXT1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5vbihiLGEpfX0pLG0uX2V2YWxVcmw9ZnVuY3Rpb24oYSl7cmV0dXJuIG0uYWpheCh7dXJsOmEsdHlwZToiR0VUIixkYXRhVHlwZToic2NyaXB0Iixhc3luYzohMSxnbG9iYWw6ITEsInRocm93cyI6ITB9KX0sbS5mbi5leHRlbmQoe3dyYXBBbGw6ZnVuY3Rpb24oYSl7aWYobS5pc0Z1bmN0aW9uKGEpKXJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oYil7bSh0aGlzKS53cmFwQWxsKGEuY2FsbCh0aGlzLGIpKX0pO2lmKHRoaXNbMF0pe3ZhciBiPW0oYSx0aGlzWzBdLm93bmVyRG9jdW1lbnQpLmVxKDApLmNsb25lKCEwKTt0aGlzWzBdLnBhcmVudE5vZGUmJmIuaW5zZXJ0QmVmb3JlKHRoaXNbMF0pLGIubWFwKGZ1bmN0aW9uKCl7dmFyIGE9dGhpczt3aGlsZShhLmZpcnN0Q2hpbGQmJjE9PT1hLmZpcnN0Q2hpbGQubm9kZVR5cGUpYT1hLmZpcnN0Q2hpbGQ7cmV0dXJuIGF9KS5hcHBlbmQodGhpcyl9cmV0dXJuIHRoaXN9LHdyYXBJbm5lcjpmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5lYWNoKG0uaXNGdW5jdGlvbihhKT9mdW5jdGlvbihiKXttKHRoaXMpLndyYXBJbm5lcihhLmNhbGwodGhpcyxiKSl9OmZ1bmN0aW9uKCl7dmFyIGI9bSh0aGlzKSxjPWIuY29udGVudHMoKTtjLmxlbmd0aD9jLndyYXBBbGwoYSk6Yi5hcHBlbmQoYSl9KX0sd3JhcDpmdW5jdGlvbihhKXt2YXIgYj1tLmlzRnVuY3Rpb24oYSk7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihjKXttKHRoaXMpLndyYXBBbGwoYj9hLmNhbGwodGhpcyxjKTphKX0pfSx1bndyYXA6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wYXJlbnQoKS5lYWNoKGZ1bmN0aW9uKCl7bS5ub2RlTmFtZSh0aGlzLCJib2R5Iil8fG0odGhpcykucmVwbGFjZVdpdGgodGhpcy5jaGlsZE5vZGVzKX0pLmVuZCgpfX0pLG0uZXhwci5maWx0ZXJzLmhpZGRlbj1mdW5jdGlvbihhKXtyZXR1cm4gYS5vZmZzZXRXaWR0aDw9MCYmYS5vZmZzZXRIZWlnaHQ8PTB8fCFrLnJlbGlhYmxlSGlkZGVuT2Zmc2V0cygpJiYibm9uZSI9PT0oYS5zdHlsZSYmYS5zdHlsZS5kaXNwbGF5fHxtLmNzcyhhLCJkaXNwbGF5IikpfSxtLmV4cHIuZmlsdGVycy52aXNpYmxlPWZ1bmN0aW9uKGEpe3JldHVybiFtLmV4cHIuZmlsdGVycy5oaWRkZW4oYSl9O3ZhciBRYz0vJTIwL2csUmM9L1xbXF0kLyxTYz0vXHI/XG4vZyxUYz0vXig/OnN1Ym1pdHxidXR0b258aW1hZ2V8cmVzZXR8ZmlsZSkkL2ksVWM9L14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8a2V5Z2VuKS9pO2Z1bmN0aW9uIFZjKGEsYixjLGQpe3ZhciBlO2lmKG0uaXNBcnJheShiKSltLmVhY2goYixmdW5jdGlvbihiLGUpe2N8fFJjLnRlc3QoYSk/ZChhLGUpOlZjKGErIlsiKygib2JqZWN0Ij09dHlwZW9mIGU/YjoiIikrIl0iLGUsYyxkKX0pO2Vsc2UgaWYoY3x8Im9iamVjdCIhPT1tLnR5cGUoYikpZChhLGIpO2Vsc2UgZm9yKGUgaW4gYilWYyhhKyJbIitlKyJdIixiW2VdLGMsZCl9bS5wYXJhbT1mdW5jdGlvbihhLGIpe3ZhciBjLGQ9W10sZT1mdW5jdGlvbihhLGIpe2I9bS5pc0Z1bmN0aW9uKGIpP2IoKTpudWxsPT1iPyIiOmIsZFtkLmxlbmd0aF09ZW5jb2RlVVJJQ29tcG9uZW50KGEpKyI9IitlbmNvZGVVUklDb21wb25lbnQoYil9O2lmKHZvaWQgMD09PWImJihiPW0uYWpheFNldHRpbmdzJiZtLmFqYXhTZXR0aW5ncy50cmFkaXRpb25hbCksbS5pc0FycmF5KGEpfHxhLmpxdWVyeSYmIW0uaXNQbGFpbk9iamVjdChhKSltLmVhY2goYSxmdW5jdGlvbigpe2UodGhpcy5uYW1lLHRoaXMudmFsdWUpfSk7ZWxzZSBmb3IoYyBpbiBhKVZjKGMsYVtjXSxiLGUpO3JldHVybiBkLmpvaW4oIiYiKS5yZXBsYWNlKFFjLCIrIil9LG0uZm4uZXh0ZW5kKHtzZXJpYWxpemU6ZnVuY3Rpb24oKXtyZXR1cm4gbS5wYXJhbSh0aGlzLnNlcmlhbGl6ZUFycmF5KCkpfSxzZXJpYWxpemVBcnJheTpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1hcChmdW5jdGlvbigpe3ZhciBhPW0ucHJvcCh0aGlzLCJlbGVtZW50cyIpO3JldHVybiBhP20ubWFrZUFycmF5KGEpOnRoaXN9KS5maWx0ZXIoZnVuY3Rpb24oKXt2YXIgYT10aGlzLnR5cGU7cmV0dXJuIHRoaXMubmFtZSYmIW0odGhpcykuaXMoIjpkaXNhYmxlZCIpJiZVYy50ZXN0KHRoaXMubm9kZU5hbWUpJiYhVGMudGVzdChhKSYmKHRoaXMuY2hlY2tlZHx8IVcudGVzdChhKSl9KS5tYXAoZnVuY3Rpb24oYSxiKXt2YXIgYz1tKHRoaXMpLnZhbCgpO3JldHVybiBudWxsPT1jP251bGw6bS5pc0FycmF5KGMpP20ubWFwKGMsZnVuY3Rpb24oYSl7cmV0dXJue25hbWU6Yi5uYW1lLHZhbHVlOmEucmVwbGFjZShTYywiXHJcbiIpfX0pOntuYW1lOmIubmFtZSx2YWx1ZTpjLnJlcGxhY2UoU2MsIlxyXG4iKX19KS5nZXQoKX19KSxtLmFqYXhTZXR0aW5ncy54aHI9dm9pZCAwIT09YS5BY3RpdmVYT2JqZWN0P2Z1bmN0aW9uKCl7cmV0dXJuIXRoaXMuaXNMb2NhbCYmL14oZ2V0fHBvc3R8aGVhZHxwdXR8ZGVsZXRlfG9wdGlvbnMpJC9pLnRlc3QodGhpcy50eXBlKSYmWmMoKXx8JGMoKX06WmM7dmFyIFdjPTAsWGM9e30sWWM9bS5hamF4U2V0dGluZ3MueGhyKCk7YS5BY3RpdmVYT2JqZWN0JiZtKGEpLm9uKCJ1bmxvYWQiLGZ1bmN0aW9uKCl7Zm9yKHZhciBhIGluIFhjKVhjW2FdKHZvaWQgMCwhMCl9KSxrLmNvcnM9ISFZYyYmIndpdGhDcmVkZW50aWFscyJpbiBZYyxZYz1rLmFqYXg9ISFZYyxZYyYmbS5hamF4VHJhbnNwb3J0KGZ1bmN0aW9uKGEpe2lmKCFhLmNyb3NzRG9tYWlufHxrLmNvcnMpe3ZhciBiO3JldHVybntzZW5kOmZ1bmN0aW9uKGMsZCl7dmFyIGUsZj1hLnhocigpLGc9KytXYztpZihmLm9wZW4oYS50eXBlLGEudXJsLGEuYXN5bmMsYS51c2VybmFtZSxhLnBhc3N3b3JkKSxhLnhockZpZWxkcylmb3IoZSBpbiBhLnhockZpZWxkcylmW2VdPWEueGhyRmllbGRzW2VdO2EubWltZVR5cGUmJmYub3ZlcnJpZGVNaW1lVHlwZSYmZi5vdmVycmlkZU1pbWVUeXBlKGEubWltZVR5cGUpLGEuY3Jvc3NEb21haW58fGNbIlgtUmVxdWVzdGVkLVdpdGgiXXx8KGNbIlgtUmVxdWVzdGVkLVdpdGgiXT0iWE1MSHR0cFJlcXVlc3QiKTtmb3IoZSBpbiBjKXZvaWQgMCE9PWNbZV0mJmYuc2V0UmVxdWVzdEhlYWRlcihlLGNbZV0rIiIpO2Yuc2VuZChhLmhhc0NvbnRlbnQmJmEuZGF0YXx8bnVsbCksYj1mdW5jdGlvbihjLGUpe3ZhciBoLGksajtpZihiJiYoZXx8ND09PWYucmVhZHlTdGF0ZSkpaWYoZGVsZXRlIFhjW2ddLGI9dm9pZCAwLGYub25yZWFkeXN0YXRlY2hhbmdlPW0ubm9vcCxlKTQhPT1mLnJlYWR5U3RhdGUmJmYuYWJvcnQoKTtlbHNle2o9e30saD1mLnN0YXR1cywic3RyaW5nIj09dHlwZW9mIGYucmVzcG9uc2VUZXh0JiYoai50ZXh0PWYucmVzcG9uc2VUZXh0KTt0cnl7aT1mLnN0YXR1c1RleHR9Y2F0Y2goayl7aT0iIn1ofHwhYS5pc0xvY2FsfHxhLmNyb3NzRG9tYWluPzEyMjM9PT1oJiYoaD0yMDQpOmg9ai50ZXh0PzIwMDo0MDR9aiYmZChoLGksaixmLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKX0sYS5hc3luYz80PT09Zi5yZWFkeVN0YXRlP3NldFRpbWVvdXQoYik6Zi5vbnJlYWR5c3RhdGVjaGFuZ2U9WGNbZ109YjpiKCl9LGFib3J0OmZ1bmN0aW9uKCl7YiYmYih2b2lkIDAsITApfX19fSk7ZnVuY3Rpb24gWmMoKXt0cnl7cmV0dXJuIG5ldyBhLlhNTEh0dHBSZXF1ZXN0fWNhdGNoKGIpe319ZnVuY3Rpb24gJGMoKXt0cnl7cmV0dXJuIG5ldyBhLkFjdGl2ZVhPYmplY3QoIk1pY3Jvc29mdC5YTUxIVFRQIil9Y2F0Y2goYil7fX1tLmFqYXhTZXR1cCh7YWNjZXB0czp7c2NyaXB0OiJ0ZXh0L2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2VjbWFzY3JpcHQsIGFwcGxpY2F0aW9uL3gtZWNtYXNjcmlwdCJ9LGNvbnRlbnRzOntzY3JpcHQ6Lyg/OmphdmF8ZWNtYSlzY3JpcHQvfSxjb252ZXJ0ZXJzOnsidGV4dCBzY3JpcHQiOmZ1bmN0aW9uKGEpe3JldHVybiBtLmdsb2JhbEV2YWwoYSksYX19fSksbS5hamF4UHJlZmlsdGVyKCJzY3JpcHQiLGZ1bmN0aW9uKGEpe3ZvaWQgMD09PWEuY2FjaGUmJihhLmNhY2hlPSExKSxhLmNyb3NzRG9tYWluJiYoYS50eXBlPSJHRVQiLGEuZ2xvYmFsPSExKX0pLG0uYWpheFRyYW5zcG9ydCgic2NyaXB0IixmdW5jdGlvbihhKXtpZihhLmNyb3NzRG9tYWluKXt2YXIgYixjPXkuaGVhZHx8bSgiaGVhZCIpWzBdfHx5LmRvY3VtZW50RWxlbWVudDtyZXR1cm57c2VuZDpmdW5jdGlvbihkLGUpe2I9eS5jcmVhdGVFbGVtZW50KCJzY3JpcHQiKSxiLmFzeW5jPSEwLGEuc2NyaXB0Q2hhcnNldCYmKGIuY2hhcnNldD1hLnNjcmlwdENoYXJzZXQpLGIuc3JjPWEudXJsLGIub25sb2FkPWIub25yZWFkeXN0YXRlY2hhbmdlPWZ1bmN0aW9uKGEsYyl7KGN8fCFiLnJlYWR5U3RhdGV8fC9sb2FkZWR8Y29tcGxldGUvLnRlc3QoYi5yZWFkeVN0YXRlKSkmJihiLm9ubG9hZD1iLm9ucmVhZHlzdGF0ZWNoYW5nZT1udWxsLGIucGFyZW50Tm9kZSYmYi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGIpLGI9bnVsbCxjfHxlKDIwMCwic3VjY2VzcyIpKX0sYy5pbnNlcnRCZWZvcmUoYixjLmZpcnN0Q2hpbGQpfSxhYm9ydDpmdW5jdGlvbigpe2ImJmIub25sb2FkKHZvaWQgMCwhMCl9fX19KTt2YXIgX2M9W10sYWQ9Lyg9KVw/KD89JnwkKXxcP1w/LzttLmFqYXhTZXR1cCh7anNvbnA6ImNhbGxiYWNrIixqc29ucENhbGxiYWNrOmZ1bmN0aW9uKCl7dmFyIGE9X2MucG9wKCl8fG0uZXhwYW5kbysiXyIrdmMrKztyZXR1cm4gdGhpc1thXT0hMCxhfX0pLG0uYWpheFByZWZpbHRlcigianNvbiBqc29ucCIsZnVuY3Rpb24oYixjLGQpe3ZhciBlLGYsZyxoPWIuanNvbnAhPT0hMSYmKGFkLnRlc3QoYi51cmwpPyJ1cmwiOiJzdHJpbmciPT10eXBlb2YgYi5kYXRhJiYhKGIuY29udGVudFR5cGV8fCIiKS5pbmRleE9mKCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQiKSYmYWQudGVzdChiLmRhdGEpJiYiZGF0YSIpO3JldHVybiBofHwianNvbnAiPT09Yi5kYXRhVHlwZXNbMF0/KGU9Yi5qc29ucENhbGxiYWNrPW0uaXNGdW5jdGlvbihiLmpzb25wQ2FsbGJhY2spP2IuanNvbnBDYWxsYmFjaygpOmIuanNvbnBDYWxsYmFjayxoP2JbaF09YltoXS5yZXBsYWNlKGFkLCIkMSIrZSk6Yi5qc29ucCE9PSExJiYoYi51cmwrPSh3Yy50ZXN0KGIudXJsKT8iJiI6Ij8iKStiLmpzb25wKyI9IitlKSxiLmNvbnZlcnRlcnNbInNjcmlwdCBqc29uIl09ZnVuY3Rpb24oKXtyZXR1cm4gZ3x8bS5lcnJvcihlKyIgd2FzIG5vdCBjYWxsZWQiKSxnWzBdfSxiLmRhdGFUeXBlc1swXT0ianNvbiIsZj1hW2VdLGFbZV09ZnVuY3Rpb24oKXtnPWFyZ3VtZW50c30sZC5hbHdheXMoZnVuY3Rpb24oKXthW2VdPWYsYltlXSYmKGIuanNvbnBDYWxsYmFjaz1jLmpzb25wQ2FsbGJhY2ssX2MucHVzaChlKSksZyYmbS5pc0Z1bmN0aW9uKGYpJiZmKGdbMF0pLGc9Zj12b2lkIDB9KSwic2NyaXB0Iik6dm9pZCAwfSksbS5wYXJzZUhUTUw9ZnVuY3Rpb24oYSxiLGMpe2lmKCFhfHwic3RyaW5nIiE9dHlwZW9mIGEpcmV0dXJuIG51bGw7ImJvb2xlYW4iPT10eXBlb2YgYiYmKGM9YixiPSExKSxiPWJ8fHk7dmFyIGQ9dS5leGVjKGEpLGU9IWMmJltdO3JldHVybiBkP1tiLmNyZWF0ZUVsZW1lbnQoZFsxXSldOihkPW0uYnVpbGRGcmFnbWVudChbYV0sYixlKSxlJiZlLmxlbmd0aCYmbShlKS5yZW1vdmUoKSxtLm1lcmdlKFtdLGQuY2hpbGROb2RlcykpfTt2YXIgYmQ9bS5mbi5sb2FkO20uZm4ubG9hZD1mdW5jdGlvbihhLGIsYyl7aWYoInN0cmluZyIhPXR5cGVvZiBhJiZiZClyZXR1cm4gYmQuYXBwbHkodGhpcyxhcmd1bWVudHMpO3ZhciBkLGUsZixnPXRoaXMsaD1hLmluZGV4T2YoIiAiKTtyZXR1cm4gaD49MCYmKGQ9bS50cmltKGEuc2xpY2UoaCxhLmxlbmd0aCkpLGE9YS5zbGljZSgwLGgpKSxtLmlzRnVuY3Rpb24oYik/KGM9YixiPXZvaWQgMCk6YiYmIm9iamVjdCI9PXR5cGVvZiBiJiYoZj0iUE9TVCIpLGcubGVuZ3RoPjAmJm0uYWpheCh7dXJsOmEsdHlwZTpmLGRhdGFUeXBlOiJodG1sIixkYXRhOmJ9KS5kb25lKGZ1bmN0aW9uKGEpe2U9YXJndW1lbnRzLGcuaHRtbChkP20oIjxkaXY+IikuYXBwZW5kKG0ucGFyc2VIVE1MKGEpKS5maW5kKGQpOmEpfSkuY29tcGxldGUoYyYmZnVuY3Rpb24oYSxiKXtnLmVhY2goYyxlfHxbYS5yZXNwb25zZVRleHQsYixhXSl9KSx0aGlzfSxtLmV4cHIuZmlsdGVycy5hbmltYXRlZD1mdW5jdGlvbihhKXtyZXR1cm4gbS5ncmVwKG0udGltZXJzLGZ1bmN0aW9uKGIpe3JldHVybiBhPT09Yi5lbGVtfSkubGVuZ3RofTt2YXIgY2Q9YS5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7ZnVuY3Rpb24gZGQoYSl7cmV0dXJuIG0uaXNXaW5kb3coYSk/YTo5PT09YS5ub2RlVHlwZT9hLmRlZmF1bHRWaWV3fHxhLnBhcmVudFdpbmRvdzohMX1tLm9mZnNldD17c2V0T2Zmc2V0OmZ1bmN0aW9uKGEsYixjKXt2YXIgZCxlLGYsZyxoLGksaixrPW0uY3NzKGEsInBvc2l0aW9uIiksbD1tKGEpLG49e307InN0YXRpYyI9PT1rJiYoYS5zdHlsZS5wb3NpdGlvbj0icmVsYXRpdmUiKSxoPWwub2Zmc2V0KCksZj1tLmNzcyhhLCJ0b3AiKSxpPW0uY3NzKGEsImxlZnQiKSxqPSgiYWJzb2x1dGUiPT09a3x8ImZpeGVkIj09PWspJiZtLmluQXJyYXkoImF1dG8iLFtmLGldKT4tMSxqPyhkPWwucG9zaXRpb24oKSxnPWQudG9wLGU9ZC5sZWZ0KTooZz1wYXJzZUZsb2F0KGYpfHwwLGU9cGFyc2VGbG9hdChpKXx8MCksbS5pc0Z1bmN0aW9uKGIpJiYoYj1iLmNhbGwoYSxjLGgpKSxudWxsIT1iLnRvcCYmKG4udG9wPWIudG9wLWgudG9wK2cpLG51bGwhPWIubGVmdCYmKG4ubGVmdD1iLmxlZnQtaC5sZWZ0K2UpLCJ1c2luZyJpbiBiP2IudXNpbmcuY2FsbChhLG4pOmwuY3NzKG4pfX0sbS5mbi5leHRlbmQoe29mZnNldDpmdW5jdGlvbihhKXtpZihhcmd1bWVudHMubGVuZ3RoKXJldHVybiB2b2lkIDA9PT1hP3RoaXM6dGhpcy5lYWNoKGZ1bmN0aW9uKGIpe20ub2Zmc2V0LnNldE9mZnNldCh0aGlzLGEsYil9KTt2YXIgYixjLGQ9e3RvcDowLGxlZnQ6MH0sZT10aGlzWzBdLGY9ZSYmZS5vd25lckRvY3VtZW50O2lmKGYpcmV0dXJuIGI9Zi5kb2N1bWVudEVsZW1lbnQsbS5jb250YWlucyhiLGUpPyh0eXBlb2YgZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QhPT1LJiYoZD1lLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKSxjPWRkKGYpLHt0b3A6ZC50b3ArKGMucGFnZVlPZmZzZXR8fGIuc2Nyb2xsVG9wKS0oYi5jbGllbnRUb3B8fDApLGxlZnQ6ZC5sZWZ0KyhjLnBhZ2VYT2Zmc2V0fHxiLnNjcm9sbExlZnQpLShiLmNsaWVudExlZnR8fDApfSk6ZH0scG9zaXRpb246ZnVuY3Rpb24oKXtpZih0aGlzWzBdKXt2YXIgYSxiLGM9e3RvcDowLGxlZnQ6MH0sZD10aGlzWzBdO3JldHVybiJmaXhlZCI9PT1tLmNzcyhkLCJwb3NpdGlvbiIpP2I9ZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTooYT10aGlzLm9mZnNldFBhcmVudCgpLGI9dGhpcy5vZmZzZXQoKSxtLm5vZGVOYW1lKGFbMF0sImh0bWwiKXx8KGM9YS5vZmZzZXQoKSksYy50b3ArPW0uY3NzKGFbMF0sImJvcmRlclRvcFdpZHRoIiwhMCksYy5sZWZ0Kz1tLmNzcyhhWzBdLCJib3JkZXJMZWZ0V2lkdGgiLCEwKSkse3RvcDpiLnRvcC1jLnRvcC1tLmNzcyhkLCJtYXJnaW5Ub3AiLCEwKSxsZWZ0OmIubGVmdC1jLmxlZnQtbS5jc3MoZCwibWFyZ2luTGVmdCIsITApfX19LG9mZnNldFBhcmVudDpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1hcChmdW5jdGlvbigpe3ZhciBhPXRoaXMub2Zmc2V0UGFyZW50fHxjZDt3aGlsZShhJiYhbS5ub2RlTmFtZShhLCJodG1sIikmJiJzdGF0aWMiPT09bS5jc3MoYSwicG9zaXRpb24iKSlhPWEub2Zmc2V0UGFyZW50O3JldHVybiBhfHxjZH0pfX0pLG0uZWFjaCh7c2Nyb2xsTGVmdDoicGFnZVhPZmZzZXQiLHNjcm9sbFRvcDoicGFnZVlPZmZzZXQifSxmdW5jdGlvbihhLGIpe3ZhciBjPS9ZLy50ZXN0KGIpO20uZm5bYV09ZnVuY3Rpb24oZCl7cmV0dXJuIFYodGhpcyxmdW5jdGlvbihhLGQsZSl7dmFyIGY9ZGQoYSk7cmV0dXJuIHZvaWQgMD09PWU/Zj9iIGluIGY/ZltiXTpmLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudFtkXTphW2RdOnZvaWQoZj9mLnNjcm9sbFRvKGM/bShmKS5zY3JvbGxMZWZ0KCk6ZSxjP2U6bShmKS5zY3JvbGxUb3AoKSk6YVtkXT1lKX0sYSxkLGFyZ3VtZW50cy5sZW5ndGgsbnVsbCl9fSksbS5lYWNoKFsidG9wIiwibGVmdCJdLGZ1bmN0aW9uKGEsYil7bS5jc3NIb29rc1tiXT1MYihrLnBpeGVsUG9zaXRpb24sZnVuY3Rpb24oYSxjKXtyZXR1cm4gYz8oYz1KYihhLGIpLEhiLnRlc3QoYyk/bShhKS5wb3NpdGlvbigpW2JdKyJweCI6Yyk6dm9pZCAwfSl9KSxtLmVhY2goe0hlaWdodDoiaGVpZ2h0IixXaWR0aDoid2lkdGgifSxmdW5jdGlvbihhLGIpe20uZWFjaCh7cGFkZGluZzoiaW5uZXIiK2EsY29udGVudDpiLCIiOiJvdXRlciIrYX0sZnVuY3Rpb24oYyxkKXttLmZuW2RdPWZ1bmN0aW9uKGQsZSl7dmFyIGY9YXJndW1lbnRzLmxlbmd0aCYmKGN8fCJib29sZWFuIiE9dHlwZW9mIGQpLGc9Y3x8KGQ9PT0hMHx8ZT09PSEwPyJtYXJnaW4iOiJib3JkZXIiKTtyZXR1cm4gVih0aGlzLGZ1bmN0aW9uKGIsYyxkKXt2YXIgZTtyZXR1cm4gbS5pc1dpbmRvdyhiKT9iLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudFsiY2xpZW50IithXTo5PT09Yi5ub2RlVHlwZT8oZT1iLmRvY3VtZW50RWxlbWVudCxNYXRoLm1heChiLmJvZHlbInNjcm9sbCIrYV0sZVsic2Nyb2xsIithXSxiLmJvZHlbIm9mZnNldCIrYV0sZVsib2Zmc2V0IithXSxlWyJjbGllbnQiK2FdKSk6dm9pZCAwPT09ZD9tLmNzcyhiLGMsZyk6bS5zdHlsZShiLGMsZCxnKX0sYixmP2Q6dm9pZCAwLGYsbnVsbCl9fSl9KSxtLmZuLnNpemU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sZW5ndGh9LG0uZm4uYW5kU2VsZj1tLmZuLmFkZEJhY2ssImZ1bmN0aW9uIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZCYmZGVmaW5lKCJqcXVlcnkiLFtdLGZ1bmN0aW9uKCl7cmV0dXJuIG19KTt2YXIgZWQ9YS5qUXVlcnksZmQ9YS4kO3JldHVybiBtLm5vQ29uZmxpY3Q9ZnVuY3Rpb24oYil7cmV0dXJuIGEuJD09PW0mJihhLiQ9ZmQpLGImJmEualF1ZXJ5PT09bSYmKGEualF1ZXJ5PWVkKSxtfSx0eXBlb2YgYj09PUsmJihhLmpRdWVyeT1hLiQ9bSksbX0pOwo="></script>
<script src="data:application/x-javascript;base64,IWZ1bmN0aW9uKGUpeyJ1bmRlZmluZWQiIT10eXBlb2YgZXhwb3J0cz9lKGV4cG9ydHMpOih3aW5kb3cuaGxqcz1lKHt9KSwiZnVuY3Rpb24iPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kJiZkZWZpbmUoImhsanMiLFtdLGZ1bmN0aW9uKCl7cmV0dXJuIHdpbmRvdy5obGpzfSkpfShmdW5jdGlvbihlKXtmdW5jdGlvbiB0KGUpe3JldHVybiBlLnJlcGxhY2UoLyYvZ20sIiZhbXA7IikucmVwbGFjZSgvPC9nbSwiJmx0OyIpLnJlcGxhY2UoLz4vZ20sIiZndDsiKX1mdW5jdGlvbiByKGUpe3JldHVybiBlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCl9ZnVuY3Rpb24gYShlLHQpe3ZhciByPWUmJmUuZXhlYyh0KTtyZXR1cm4gciYmMD09ci5pbmRleH1mdW5jdGlvbiBuKGUpe3JldHVybi9eKG5vLT9oaWdobGlnaHR8cGxhaW58dGV4dCkkL2kudGVzdChlKX1mdW5jdGlvbiBpKGUpe3ZhciB0LHIsYSxpPWUuY2xhc3NOYW1lKyIgIjtpZihpKz1lLnBhcmVudE5vZGU/ZS5wYXJlbnROb2RlLmNsYXNzTmFtZToiIixyPS9cYmxhbmcoPzp1YWdlKT8tKFtcdy1dKylcYi9pLmV4ZWMoaSkpcmV0dXJuIHkoclsxXSk/clsxXToibm8taGlnaGxpZ2h0Ijtmb3IoaT1pLnNwbGl0KC9ccysvKSx0PTAsYT1pLmxlbmd0aDthPnQ7dCsrKWlmKHkoaVt0XSl8fG4oaVt0XSkpcmV0dXJuIGlbdF19ZnVuY3Rpb24gcyhlLHQpe3ZhciByLGE9e307Zm9yKHIgaW4gZSlhW3JdPWVbcl07aWYodClmb3IociBpbiB0KWFbcl09dFtyXTtyZXR1cm4gYX1mdW5jdGlvbiBjKGUpe3ZhciB0PVtdO3JldHVybiBmdW5jdGlvbiBhKGUsbil7Zm9yKHZhciBpPWUuZmlyc3RDaGlsZDtpO2k9aS5uZXh0U2libGluZykzPT1pLm5vZGVUeXBlP24rPWkubm9kZVZhbHVlLmxlbmd0aDoxPT1pLm5vZGVUeXBlJiYodC5wdXNoKHtldmVudDoic3RhcnQiLG9mZnNldDpuLG5vZGU6aX0pLG49YShpLG4pLHIoaSkubWF0Y2goL2JyfGhyfGltZ3xpbnB1dC8pfHx0LnB1c2goe2V2ZW50OiJzdG9wIixvZmZzZXQ6bixub2RlOml9KSk7cmV0dXJuIG59KGUsMCksdH1mdW5jdGlvbiBvKGUsYSxuKXtmdW5jdGlvbiBpKCl7cmV0dXJuIGUubGVuZ3RoJiZhLmxlbmd0aD9lWzBdLm9mZnNldCE9YVswXS5vZmZzZXQ/ZVswXS5vZmZzZXQ8YVswXS5vZmZzZXQ/ZTphOiJzdGFydCI9PWFbMF0uZXZlbnQ/ZTphOmUubGVuZ3RoP2U6YX1mdW5jdGlvbiBzKGUpe2Z1bmN0aW9uIGEoZSl7cmV0dXJuIiAiK2Uubm9kZU5hbWUrJz0iJyt0KGUudmFsdWUpKyciJ311Kz0iPCIrcihlKStBcnJheS5wcm90b3R5cGUubWFwLmNhbGwoZS5hdHRyaWJ1dGVzLGEpLmpvaW4oIiIpKyI+In1mdW5jdGlvbiBjKGUpe3UrPSI8LyIrcihlKSsiPiJ9ZnVuY3Rpb24gbyhlKXsoInN0YXJ0Ij09ZS5ldmVudD9zOmMpKGUubm9kZSl9Zm9yKHZhciBsPTAsdT0iIixkPVtdO2UubGVuZ3RofHxhLmxlbmd0aDspe3ZhciBiPWkoKTtpZih1Kz10KG4uc3Vic3RyKGwsYlswXS5vZmZzZXQtbCkpLGw9YlswXS5vZmZzZXQsYj09ZSl7ZC5yZXZlcnNlKCkuZm9yRWFjaChjKTtkbyBvKGIuc3BsaWNlKDAsMSlbMF0pLGI9aSgpO3doaWxlKGI9PWUmJmIubGVuZ3RoJiZiWzBdLm9mZnNldD09bCk7ZC5yZXZlcnNlKCkuZm9yRWFjaChzKX1lbHNlInN0YXJ0Ij09YlswXS5ldmVudD9kLnB1c2goYlswXS5ub2RlKTpkLnBvcCgpLG8oYi5zcGxpY2UoMCwxKVswXSl9cmV0dXJuIHUrdChuLnN1YnN0cihsKSl9ZnVuY3Rpb24gbChlKXtmdW5jdGlvbiB0KGUpe3JldHVybiBlJiZlLnNvdXJjZXx8ZX1mdW5jdGlvbiByKHIsYSl7cmV0dXJuIG5ldyBSZWdFeHAodChyKSwibSIrKGUuY0k/ImkiOiIiKSsoYT8iZyI6IiIpKX1mdW5jdGlvbiBhKG4saSl7aWYoIW4uY29tcGlsZWQpe2lmKG4uY29tcGlsZWQ9ITAsbi5rPW4ua3x8bi5iSyxuLmspe3ZhciBjPXt9LG89ZnVuY3Rpb24odCxyKXtlLmNJJiYocj1yLnRvTG93ZXJDYXNlKCkpLHIuc3BsaXQoIiAiKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3ZhciByPWUuc3BsaXQoInwiKTtjW3JbMF1dPVt0LHJbMV0/TnVtYmVyKHJbMV0pOjFdfSl9OyJzdHJpbmciPT10eXBlb2Ygbi5rP28oImtleXdvcmQiLG4uayk6T2JqZWN0LmtleXMobi5rKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe28oZSxuLmtbZV0pfSksbi5rPWN9bi5sUj1yKG4ubHx8L1xiXHcrXGIvLCEwKSxpJiYobi5iSyYmKG4uYj0iXFxiKCIrbi5iSy5zcGxpdCgiICIpLmpvaW4oInwiKSsiKVxcYiIpLG4uYnx8KG4uYj0vXEJ8XGIvKSxuLmJSPXIobi5iKSxuLmV8fG4uZVd8fChuLmU9L1xCfFxiLyksbi5lJiYobi5lUj1yKG4uZSkpLG4udEU9dChuLmUpfHwiIixuLmVXJiZpLnRFJiYobi50RSs9KG4uZT8ifCI6IiIpK2kudEUpKSxuLmkmJihuLmlSPXIobi5pKSksdm9pZCAwPT09bi5yJiYobi5yPTEpLG4uY3x8KG4uYz1bXSk7dmFyIGw9W107bi5jLmZvckVhY2goZnVuY3Rpb24oZSl7ZS52P2Uudi5mb3JFYWNoKGZ1bmN0aW9uKHQpe2wucHVzaChzKGUsdCkpfSk6bC5wdXNoKCJzZWxmIj09ZT9uOmUpfSksbi5jPWwsbi5jLmZvckVhY2goZnVuY3Rpb24oZSl7YShlLG4pfSksbi5zdGFydHMmJmEobi5zdGFydHMsaSk7dmFyIHU9bi5jLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5iSz8iXFwuPygiK2UuYisiKVxcLj8iOmUuYn0pLmNvbmNhdChbbi50RSxuLmldKS5tYXAodCkuZmlsdGVyKEJvb2xlYW4pO24udD11Lmxlbmd0aD9yKHUuam9pbigifCIpLCEwKTp7ZXhlYzpmdW5jdGlvbigpe3JldHVybiBudWxsfX19fWEoZSl9ZnVuY3Rpb24gdShlLHIsbixpKXtmdW5jdGlvbiBzKGUsdCl7Zm9yKHZhciByPTA7cjx0LmMubGVuZ3RoO3IrKylpZihhKHQuY1tyXS5iUixlKSlyZXR1cm4gdC5jW3JdfWZ1bmN0aW9uIGMoZSx0KXtpZihhKGUuZVIsdCkpe2Zvcig7ZS5lbmRzUGFyZW50JiZlLnBhcmVudDspZT1lLnBhcmVudDtyZXR1cm4gZX1yZXR1cm4gZS5lVz9jKGUucGFyZW50LHQpOnZvaWQgMH1mdW5jdGlvbiBvKGUsdCl7cmV0dXJuIW4mJmEodC5pUixlKX1mdW5jdGlvbiBiKGUsdCl7dmFyIHI9di5jST90WzBdLnRvTG93ZXJDYXNlKCk6dFswXTtyZXR1cm4gZS5rLmhhc093blByb3BlcnR5KHIpJiZlLmtbcl19ZnVuY3Rpb24gcChlLHQscixhKXt2YXIgbj1hPyIiOncuY2xhc3NQcmVmaXgsaT0nPHNwYW4gY2xhc3M9IicrbixzPXI/IiI6Ijwvc3Bhbj4iO3JldHVybiBpKz1lKyciPicsaSt0K3N9ZnVuY3Rpb24gbSgpe2lmKCF4LmspcmV0dXJuIHQoRSk7dmFyIGU9IiIscj0wO3gubFIubGFzdEluZGV4PTA7Zm9yKHZhciBhPXgubFIuZXhlYyhFKTthOyl7ZSs9dChFLnN1YnN0cihyLGEuaW5kZXgtcikpO3ZhciBuPWIoeCxhKTtuPyhCKz1uWzFdLGUrPXAoblswXSx0KGFbMF0pKSk6ZSs9dChhWzBdKSxyPXgubFIubGFzdEluZGV4LGE9eC5sUi5leGVjKEUpfXJldHVybiBlK3QoRS5zdWJzdHIocikpfWZ1bmN0aW9uIGYoKXt2YXIgZT0ic3RyaW5nIj09dHlwZW9mIHguc0w7aWYoZSYmIU5beC5zTF0pcmV0dXJuIHQoRSk7dmFyIHI9ZT91KHguc0wsRSwhMCxDW3guc0xdKTpkKEUseC5zTC5sZW5ndGg/eC5zTDp2b2lkIDApO3JldHVybiB4LnI+MCYmKEIrPXIuciksZSYmKENbeC5zTF09ci50b3ApLHAoci5sYW5ndWFnZSxyLnZhbHVlLCExLCEwKX1mdW5jdGlvbiBnKCl7cmV0dXJuIHZvaWQgMCE9PXguc0w/ZigpOm0oKX1mdW5jdGlvbiBoKGUscil7dmFyIGE9ZS5jTj9wKGUuY04sIiIsITApOiIiO2UuckI/KE0rPWEsRT0iIik6ZS5lQj8oTSs9dChyKSthLEU9IiIpOihNKz1hLEU9cikseD1PYmplY3QuY3JlYXRlKGUse3BhcmVudDp7dmFsdWU6eH19KX1mdW5jdGlvbiBfKGUscil7aWYoRSs9ZSx2b2lkIDA9PT1yKXJldHVybiBNKz1nKCksMDt2YXIgYT1zKHIseCk7aWYoYSlyZXR1cm4gTSs9ZygpLGgoYSxyKSxhLnJCPzA6ci5sZW5ndGg7dmFyIG49Yyh4LHIpO2lmKG4pe3ZhciBpPXg7aS5yRXx8aS5lRXx8KEUrPXIpLE0rPWcoKTtkbyB4LmNOJiYoTSs9Ijwvc3Bhbj4iKSxCKz14LnIseD14LnBhcmVudDt3aGlsZSh4IT1uLnBhcmVudCk7cmV0dXJuIGkuZUUmJihNKz10KHIpKSxFPSIiLG4uc3RhcnRzJiZoKG4uc3RhcnRzLCIiKSxpLnJFPzA6ci5sZW5ndGh9aWYobyhyLHgpKXRocm93IG5ldyBFcnJvcignSWxsZWdhbCBsZXhlbWUgIicrcisnIiBmb3IgbW9kZSAiJysoeC5jTnx8Ijx1bm5hbWVkPiIpKyciJyk7cmV0dXJuIEUrPXIsci5sZW5ndGh8fDF9dmFyIHY9eShlKTtpZighdil0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbGFuZ3VhZ2U6ICInK2UrJyInKTtsKHYpO3ZhciBrLHg9aXx8dixDPXt9LE09IiI7Zm9yKGs9eDtrIT12O2s9ay5wYXJlbnQpay5jTiYmKE09cChrLmNOLCIiLCEwKStNKTt2YXIgRT0iIixCPTA7dHJ5e2Zvcih2YXIgJCx6LEw9MDs7KXtpZih4LnQubGFzdEluZGV4PUwsJD14LnQuZXhlYyhyKSwhJClicmVhazt6PV8oci5zdWJzdHIoTCwkLmluZGV4LUwpLCRbMF0pLEw9JC5pbmRleCt6fWZvcihfKHIuc3Vic3RyKEwpKSxrPXg7ay5wYXJlbnQ7az1rLnBhcmVudClrLmNOJiYoTSs9Ijwvc3Bhbj4iKTtyZXR1cm57cjpCLHZhbHVlOk0sbGFuZ3VhZ2U6ZSx0b3A6eH19Y2F0Y2gocSl7aWYoLTEhPXEubWVzc2FnZS5pbmRleE9mKCJJbGxlZ2FsIikpcmV0dXJue3I6MCx2YWx1ZTp0KHIpfTt0aHJvdyBxfX1mdW5jdGlvbiBkKGUscil7cj1yfHx3Lmxhbmd1YWdlc3x8T2JqZWN0LmtleXMoTik7dmFyIGE9e3I6MCx2YWx1ZTp0KGUpfSxuPWE7cmV0dXJuIHIuZm9yRWFjaChmdW5jdGlvbih0KXtpZih5KHQpKXt2YXIgcj11KHQsZSwhMSk7ci5sYW5ndWFnZT10LHIucj5uLnImJihuPXIpLHIucj5hLnImJihuPWEsYT1yKX19KSxuLmxhbmd1YWdlJiYoYS5zZWNvbmRfYmVzdD1uKSxhfWZ1bmN0aW9uIGIoZSl7cmV0dXJuIHcudGFiUmVwbGFjZSYmKGU9ZS5yZXBsYWNlKC9eKCg8W14+XSs+fFx0KSspL2dtLGZ1bmN0aW9uKGUsdCl7cmV0dXJuIHQucmVwbGFjZSgvXHQvZyx3LnRhYlJlcGxhY2UpfSkpLHcudXNlQlImJihlPWUucmVwbGFjZSgvXG4vZywiPGJyPiIpKSxlfWZ1bmN0aW9uIHAoZSx0LHIpe3ZhciBhPXQ/a1t0XTpyLG49W2UudHJpbSgpXTtyZXR1cm4gZS5tYXRjaCgvXGJobGpzXGIvKXx8bi5wdXNoKCJobGpzIiksLTE9PT1lLmluZGV4T2YoYSkmJm4ucHVzaChhKSxuLmpvaW4oIiAiKS50cmltKCl9ZnVuY3Rpb24gbShlKXt2YXIgdD1pKGUpO2lmKCFuKHQpKXt2YXIgcjt3LnVzZUJSPyhyPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCIsImRpdiIpLHIuaW5uZXJIVE1MPWUuaW5uZXJIVE1MLnJlcGxhY2UoL1xuL2csIiIpLnJlcGxhY2UoLzxiclsgXC9dKj4vZywiXG4iKSk6cj1lO3ZhciBhPXIudGV4dENvbnRlbnQscz10P3UodCxhLCEwKTpkKGEpLGw9YyhyKTtpZihsLmxlbmd0aCl7dmFyIG09ZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIiwiZGl2Iik7bS5pbm5lckhUTUw9cy52YWx1ZSxzLnZhbHVlPW8obCxjKG0pLGEpfXMudmFsdWU9YihzLnZhbHVlKSxlLmlubmVySFRNTD1zLnZhbHVlLGUuY2xhc3NOYW1lPXAoZS5jbGFzc05hbWUsdCxzLmxhbmd1YWdlKSxlLnJlc3VsdD17bGFuZ3VhZ2U6cy5sYW5ndWFnZSxyZTpzLnJ9LHMuc2Vjb25kX2Jlc3QmJihlLnNlY29uZF9iZXN0PXtsYW5ndWFnZTpzLnNlY29uZF9iZXN0Lmxhbmd1YWdlLHJlOnMuc2Vjb25kX2Jlc3Qucn0pfX1mdW5jdGlvbiBmKGUpe3c9cyh3LGUpfWZ1bmN0aW9uIGcoKXtpZighZy5jYWxsZWQpe2cuY2FsbGVkPSEwO3ZhciBlPWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoInByZSBjb2RlIik7QXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbChlLG0pfX1mdW5jdGlvbiBoKCl7YWRkRXZlbnRMaXN0ZW5lcigiRE9NQ29udGVudExvYWRlZCIsZywhMSksYWRkRXZlbnRMaXN0ZW5lcigibG9hZCIsZywhMSl9ZnVuY3Rpb24gXyh0LHIpe3ZhciBhPU5bdF09cihlKTthLmFsaWFzZXMmJmEuYWxpYXNlcy5mb3JFYWNoKGZ1bmN0aW9uKGUpe2tbZV09dH0pfWZ1bmN0aW9uIHYoKXtyZXR1cm4gT2JqZWN0LmtleXMoTil9ZnVuY3Rpb24geShlKXtyZXR1cm4gZT0oZXx8IiIpLnRvTG93ZXJDYXNlKCksTltlXXx8TltrW2VdXX12YXIgdz17Y2xhc3NQcmVmaXg6ImhsanMtIix0YWJSZXBsYWNlOm51bGwsdXNlQlI6ITEsbGFuZ3VhZ2VzOnZvaWQgMH0sTj17fSxrPXt9O3JldHVybiBlLmhpZ2hsaWdodD11LGUuaGlnaGxpZ2h0QXV0bz1kLGUuZml4TWFya3VwPWIsZS5oaWdobGlnaHRCbG9jaz1tLGUuY29uZmlndXJlPWYsZS5pbml0SGlnaGxpZ2h0aW5nPWcsZS5pbml0SGlnaGxpZ2h0aW5nT25Mb2FkPWgsZS5yZWdpc3Rlckxhbmd1YWdlPV8sZS5saXN0TGFuZ3VhZ2VzPXYsZS5nZXRMYW5ndWFnZT15LGUuaW5oZXJpdD1zLGUuSVI9IlthLXpBLVpdXFx3KiIsZS5VSVI9IlthLXpBLVpfXVxcdyoiLGUuTlI9IlxcYlxcZCsoXFwuXFxkKyk/IixlLkNOUj0iKFxcYjBbeFhdW2EtZkEtRjAtOV0rfChcXGJcXGQrKFxcLlxcZCopP3xcXC5cXGQrKShbZUVdWy0rXT9cXGQrKT8pIixlLkJOUj0iXFxiKDBiWzAxXSspIixlLlJTUj0iIXwhPXwhPT18JXwlPXwmfCYmfCY9fFxcKnxcXCo9fFxcK3xcXCs9fCx8LXwtPXwvPXwvfDp8O3w8PHw8PD18PD18PHw9PT18PT18PXw+Pj49fD4+PXw+PXw+Pj58Pj58PnxcXD98XFxbfFxce3xcXCh8XFxefFxcXj18XFx8fFxcfD18XFx8XFx8fH4iLGUuQkU9e2I6IlxcXFxbXFxzXFxTXSIscjowfSxlLkFTTT17Y046InN0cmluZyIsYjoiJyIsZToiJyIsaToiXFxuIixjOltlLkJFXX0sZS5RU009e2NOOiJzdHJpbmciLGI6JyInLGU6JyInLGk6IlxcbiIsYzpbZS5CRV19LGUuUFdNPXtiOi9cYihhfGFufHRoZXxhcmV8SXxJJ218aXNuJ3R8ZG9uJ3R8ZG9lc24ndHx3b24ndHxidXR8anVzdHxzaG91bGR8cHJldHR5fHNpbXBseXxlbm91Z2h8Z29ubmF8Z29pbmd8d3RmfHNvfHN1Y2h8d2lsbHx5b3V8eW91cnxsaWtlKVxiL30sZS5DPWZ1bmN0aW9uKHQscixhKXt2YXIgbj1lLmluaGVyaXQoe2NOOiJjb21tZW50IixiOnQsZTpyLGM6W119LGF8fHt9KTtyZXR1cm4gbi5jLnB1c2goZS5QV00pLG4uYy5wdXNoKHtjTjoiZG9jdGFnIixiOiIoPzpUT0RPfEZJWE1FfE5PVEV8QlVHfFhYWCk6IixyOjB9KSxufSxlLkNMQ009ZS5DKCIvLyIsIiQiKSxlLkNCQ009ZS5DKCIvXFwqIiwiXFwqLyIpLGUuSENNPWUuQygiIyIsIiQiKSxlLk5NPXtjTjoibnVtYmVyIixiOmUuTlIscjowfSxlLkNOTT17Y046Im51bWJlciIsYjplLkNOUixyOjB9LGUuQk5NPXtjTjoibnVtYmVyIixiOmUuQk5SLHI6MH0sZS5DU1NOTT17Y046Im51bWJlciIsYjplLk5SKyIoJXxlbXxleHxjaHxyZW18dnd8dmh8dm1pbnx2bWF4fGNtfG1tfGlufHB0fHBjfHB4fGRlZ3xncmFkfHJhZHx0dXJufHN8bXN8SHp8a0h6fGRwaXxkcGNtfGRwcHgpPyIscjowfSxlLlJNPXtjTjoicmVnZXhwIixiOi9cLy8sZTovXC9bZ2ltdXldKi8saTovXG4vLGM6W2UuQkUse2I6L1xbLyxlOi9cXS8scjowLGM6W2UuQkVdfV19LGUuVE09e2NOOiJ0aXRsZSIsYjplLklSLHI6MH0sZS5VVE09e2NOOiJ0aXRsZSIsYjplLlVJUixyOjB9LGUucmVnaXN0ZXJMYW5ndWFnZSgiYXBhY2hlIixmdW5jdGlvbihlKXt2YXIgdD17Y046Im51bWJlciIsYjoiW1xcJCVdXFxkKyJ9O3JldHVybnthbGlhc2VzOlsiYXBhY2hlY29uZiJdLGNJOiEwLGM6W2UuSENNLHtjTjoidGFnIixiOiI8Lz8iLGU6Ij4ifSx7Y046ImtleXdvcmQiLGI6L1x3Ky8scjowLGs6e2NvbW1vbjoib3JkZXIgZGVueSBhbGxvdyBzZXRlbnYgcmV3cml0ZXJ1bGUgcmV3cml0ZWVuZ2luZSByZXdyaXRlY29uZCBkb2N1bWVudHJvb3Qgc2V0aGFuZGxlciBlcnJvcmRvY3VtZW50IGxvYWRtb2R1bGUgb3B0aW9ucyBoZWFkZXIgbGlzdGVuIHNlcnZlcnJvb3Qgc2VydmVybmFtZSJ9LHN0YXJ0czp7ZTovJC8scjowLGs6e2xpdGVyYWw6Im9uIG9mZiBhbGwifSxjOlt7Y046InNxYnJhY2tldCIsYjoiXFxzXFxbIixlOiJcXF0kIn0se2NOOiJjYnJhY2tldCIsYjoiW1xcJCVdXFx7IixlOiJcXH0iLGM6WyJzZWxmIix0XX0sdCxlLlFTTV19fV0saTovXFMvfX0pLGUucmVnaXN0ZXJMYW5ndWFnZSgiYmFzaCIsZnVuY3Rpb24oZSl7dmFyIHQ9e2NOOiJ2YXJpYWJsZSIsdjpbe2I6L1wkW1x3XGQjQF1bXHdcZF9dKi99LHtiOi9cJFx7KC4qPyl9L31dfSxyPXtjTjoic3RyaW5nIixiOi8iLyxlOi8iLyxjOltlLkJFLHQse2NOOiJ2YXJpYWJsZSIsYjovXCRcKC8sZTovXCkvLGM6W2UuQkVdfV19LGE9e2NOOiJzdHJpbmciLGI6LycvLGU6LycvfTtyZXR1cm57YWxpYXNlczpbInNoIiwienNoIl0sbDovLT9bYS16XC5dKy8sazp7a2V5d29yZDoiaWYgdGhlbiBlbHNlIGVsaWYgZmkgZm9yIHdoaWxlIGluIGRvIGRvbmUgY2FzZSBlc2FjIGZ1bmN0aW9uIixsaXRlcmFsOiJ0cnVlIGZhbHNlIixidWlsdF9pbjoiYnJlYWsgY2QgY29udGludWUgZXZhbCBleGVjIGV4aXQgZXhwb3J0IGdldG9wdHMgaGFzaCBwd2QgcmVhZG9ubHkgcmV0dXJuIHNoaWZ0IHRlc3QgdGltZXMgdHJhcCB1bWFzayB1bnNldCBhbGlhcyBiaW5kIGJ1aWx0aW4gY2FsbGVyIGNvbW1hbmQgZGVjbGFyZSBlY2hvIGVuYWJsZSBoZWxwIGxldCBsb2NhbCBsb2dvdXQgbWFwZmlsZSBwcmludGYgcmVhZCByZWFkYXJyYXkgc291cmNlIHR5cGUgdHlwZXNldCB1bGltaXQgdW5hbGlhcyBzZXQgc2hvcHQgYXV0b2xvYWQgYmcgYmluZGtleSBieWUgY2FwIGNoZGlyIGNsb25lIGNvbXBhcmd1bWVudHMgY29tcGNhbGwgY29tcGN0bCBjb21wZGVzY3JpYmUgY29tcGZpbGVzIGNvbXBncm91cHMgY29tcHF1b3RlIGNvbXB0YWdzIGNvbXB0cnkgY29tcHZhbHVlcyBkaXJzIGRpc2FibGUgZGlzb3duIGVjaG90YyBlY2hvdGkgZW11bGF0ZSBmYyBmZyBmbG9hdCBmdW5jdGlvbnMgZ2V0Y2FwIGdldGxuIGhpc3RvcnkgaW50ZWdlciBqb2JzIGtpbGwgbGltaXQgbG9nIG5vZ2xvYiBwb3BkIHByaW50IHB1c2hkIHB1c2hsbiByZWhhc2ggc2NoZWQgc2V0Y2FwIHNldG9wdCBzdGF0IHN1c3BlbmQgdHR5Y3RsIHVuZnVuY3Rpb24gdW5oYXNoIHVubGltaXQgdW5zZXRvcHQgdmFyZWQgd2FpdCB3aGVuY2Ugd2hlcmUgd2hpY2ggemNvbXBpbGUgemZvcm1hdCB6ZnRwIHpsZSB6bW9kbG9hZCB6cGFyc2VvcHRzIHpwcm9mIHpwdHkgenJlZ2V4cGFyc2UgenNvY2tldCB6c3R5bGUgenRjcCIsb3BlcmF0b3I6Ii1uZSAtZXEgLWx0IC1ndCAtZiAtZCAtZSAtcyAtbCAtYSJ9LGM6W3tjTjoic2hlYmFuZyIsYjovXiMhW15cbl0rc2hccyokLyxyOjEwfSx7Y046ImZ1bmN0aW9uIixiOi9cd1tcd1xkX10qXHMqXChccypcKVxzKlx7LyxyQjohMCxjOltlLmluaGVyaXQoZS5UTSx7YjovXHdbXHdcZF9dKi99KV0scjowfSxlLkhDTSxlLk5NLHIsYSx0XX19KSxlLnJlZ2lzdGVyTGFuZ3VhZ2UoImNvZmZlZXNjcmlwdCIsZnVuY3Rpb24oZSl7dmFyIHQ9e2tleXdvcmQ6ImluIGlmIGZvciB3aGlsZSBmaW5hbGx5IG5ldyBkbyByZXR1cm4gZWxzZSBicmVhayBjYXRjaCBpbnN0YW5jZW9mIHRocm93IHRyeSB0aGlzIHN3aXRjaCBjb250aW51ZSB0eXBlb2YgZGVsZXRlIGRlYnVnZ2VyIHN1cGVyIHRoZW4gdW5sZXNzIHVudGlsIGxvb3Agb2YgYnkgd2hlbiBhbmQgb3IgaXMgaXNudCBub3QiLGxpdGVyYWw6InRydWUgZmFsc2UgbnVsbCB1bmRlZmluZWQgeWVzIG5vIG9uIG9mZiIsYnVpbHRfaW46Im5wbSByZXF1aXJlIGNvbnNvbGUgcHJpbnQgbW9kdWxlIGdsb2JhbCB3aW5kb3cgZG9jdW1lbnQifSxyPSJbQS1aYS16JF9dWzAtOUEtWmEteiRfXSoiLGE9e2NOOiJzdWJzdCIsYjovI1x7LyxlOi99LyxrOnR9LG49W2UuQk5NLGUuaW5oZXJpdChlLkNOTSx7c3RhcnRzOntlOiIoXFxzKi8pPyIscjowfX0pLHtjTjoic3RyaW5nIix2Olt7YjovJycnLyxlOi8nJycvLGM6W2UuQkVdfSx7YjovJy8sZTovJy8sYzpbZS5CRV19LHtiOi8iIiIvLGU6LyIiIi8sYzpbZS5CRSxhXX0se2I6LyIvLGU6LyIvLGM6W2UuQkUsYV19XX0se2NOOiJyZWdleHAiLHY6W3tiOiIvLy8iLGU6Ii8vLyIsYzpbYSxlLkhDTV19LHtiOiIvL1tnaW1dKiIscjowfSx7YjovXC8oPyFbICpdKShcXFwvfC4pKj9cL1tnaW1dKig/PVxXfCQpL31dfSx7Y046InByb3BlcnR5IixiOiJAIityfSx7YjoiYCIsZToiYCIsZUI6ITAsZUU6ITAsc0w6ImphdmFzY3JpcHQifV07YS5jPW47dmFyIGk9ZS5pbmhlcml0KGUuVE0se2I6cn0pLHM9IihcXCguKlxcKSk/XFxzKlxcQlstPV0+IixjPXtjTjoicGFyYW1zIixiOiJcXChbXlxcKF0iLHJCOiEwLGM6W3tiOi9cKC8sZTovXCkvLGs6dCxjOlsic2VsZiJdLmNvbmNhdChuKX1dfTtyZXR1cm57YWxpYXNlczpbImNvZmZlZSIsImNzb24iLCJpY2VkIl0sazp0LGk6L1wvXCovLGM6bi5jb25jYXQoW2UuQygiIyMjIiwiIyMjIiksZS5IQ00se2NOOiJmdW5jdGlvbiIsYjoiXlxccyoiK3IrIlxccyo9XFxzKiIrcyxlOiJbLT1dPiIsckI6ITAsYzpbaSxjXX0se2I6L1s6XCgsPV1ccyovLHI6MCxjOlt7Y046ImZ1bmN0aW9uIixiOnMsZToiWy09XT4iLHJCOiEwLGM6W2NdfV19LHtjTjoiY2xhc3MiLGJLOiJjbGFzcyIsZToiJCIsaTovWzo9IlxbXF1dLyxjOlt7Yks6ImV4dGVuZHMiLGVXOiEwLGk6L1s6PSJcW1xdXS8sYzpbaV19LGldfSx7Y046ImF0dHJpYnV0ZSIsYjpyKyI6IixlOiI6IixyQjohMCxyRTohMCxyOjB9XSl9fSksZS5yZWdpc3Rlckxhbmd1YWdlKCJjcHAiLGZ1bmN0aW9uKGUpe3ZhciB0PXtjTjoia2V5d29yZCIsYjoiXFxiW2EtelxcZF9dKl90XFxiIn0scj17Y046InN0cmluZyIsdjpbZS5pbmhlcml0KGUuUVNNLHtiOicoKHU4P3xVKXxMKT8iJ30pLHtiOicodTg/fFUpP1IiJyxlOiciJyxjOltlLkJFXX0se2I6IidcXFxcPy4iLGU6IiciLGk6Ii4ifV19LGE9e2NOOiJudW1iZXIiLHY6W3tiOiJcXGIoXFxkKyhcXC5cXGQqKT98XFwuXFxkKykodXxVfGx8THx1bHxVTHxmfEYpIn0se2I6ZS5DTlJ9XX0sbj17Y046InByZXByb2Nlc3NvciIsYjoiIyIsZToiJCIsazoiaWYgZWxzZSBlbGlmIGVuZGlmIGRlZmluZSB1bmRlZiB3YXJuaW5nIGVycm9yIGxpbmUgcHJhZ21hIGlmZGVmIGlmbmRlZiIsYzpbe2I6L1xcXG4vLHI6MH0se2JLOiJpbmNsdWRlIixlOiIkIixjOltyLHtjTjoic3RyaW5nIixiOiI8IixlOiI+IixpOiJcXG4ifV19LHIsYSxlLkNMQ00sZS5DQkNNXX0saT1lLklSKyJcXHMqXFwoIixzPXtrZXl3b3JkOiJpbnQgZmxvYXQgd2hpbGUgcHJpdmF0ZSBjaGFyIGNhdGNoIGV4cG9ydCB2aXJ0dWFsIG9wZXJhdG9yIHNpemVvZiBkeW5hbWljX2Nhc3R8MTAgdHlwZWRlZiBjb25zdF9jYXN0fDEwIGNvbnN0IHN0cnVjdCBmb3Igc3RhdGljX2Nhc3R8MTAgdW5pb24gbmFtZXNwYWNlIHVuc2lnbmVkIGxvbmcgdm9sYXRpbGUgc3RhdGljIHByb3RlY3RlZCBib29sIHRlbXBsYXRlIG11dGFibGUgaWYgcHVibGljIGZyaWVuZCBkbyBnb3RvIGF1dG8gdm9pZCBlbnVtIGVsc2UgYnJlYWsgZXh0ZXJuIHVzaW5nIGNsYXNzIGFzbSBjYXNlIHR5cGVpZCBzaG9ydCByZWludGVycHJldF9jYXN0fDEwIGRlZmF1bHQgZG91YmxlIHJlZ2lzdGVyIGV4cGxpY2l0IHNpZ25lZCB0eXBlbmFtZSB0cnkgdGhpcyBzd2l0Y2ggY29udGludWUgaW5saW5lIGRlbGV0ZSBhbGlnbm9mIGNvbnN0ZXhwciBkZWNsdHlwZSBub2V4Y2VwdCBzdGF0aWNfYXNzZXJ0IHRocmVhZF9sb2NhbCByZXN0cmljdCBfQm9vbCBjb21wbGV4IF9Db21wbGV4IF9JbWFnaW5hcnkgYXRvbWljX2Jvb2wgYXRvbWljX2NoYXIgYXRvbWljX3NjaGFyIGF0b21pY191Y2hhciBhdG9taWNfc2hvcnQgYXRvbWljX3VzaG9ydCBhdG9taWNfaW50IGF0b21pY191aW50IGF0b21pY19sb25nIGF0b21pY191bG9uZyBhdG9taWNfbGxvbmcgYXRvbWljX3VsbG9uZyIsYnVpbHRfaW46InN0ZCBzdHJpbmcgY2luIGNvdXQgY2VyciBjbG9nIHN0ZGluIHN0ZG91dCBzdGRlcnIgc3RyaW5nc3RyZWFtIGlzdHJpbmdzdHJlYW0gb3N0cmluZ3N0cmVhbSBhdXRvX3B0ciBkZXF1ZSBsaXN0IHF1ZXVlIHN0YWNrIHZlY3RvciBtYXAgc2V0IGJpdHNldCBtdWx0aXNldCBtdWx0aW1hcCB1bm9yZGVyZWRfc2V0IHVub3JkZXJlZF9tYXAgdW5vcmRlcmVkX211bHRpc2V0IHVub3JkZXJlZF9tdWx0aW1hcCBhcnJheSBzaGFyZWRfcHRyIGFib3J0IGFicyBhY29zIGFzaW4gYXRhbjIgYXRhbiBjYWxsb2MgY2VpbCBjb3NoIGNvcyBleGl0IGV4cCBmYWJzIGZsb29yIGZtb2QgZnByaW50ZiBmcHV0cyBmcmVlIGZyZXhwIGZzY2FuZiBpc2FsbnVtIGlzYWxwaGEgaXNjbnRybCBpc2RpZ2l0IGlzZ3JhcGggaXNsb3dlciBpc3ByaW50IGlzcHVuY3QgaXNzcGFjZSBpc3VwcGVyIGlzeGRpZ2l0IHRvbG93ZXIgdG91cHBlciBsYWJzIGxkZXhwIGxvZzEwIGxvZyBtYWxsb2MgcmVhbGxvYyBtZW1jaHIgbWVtY21wIG1lbWNweSBtZW1zZXQgbW9kZiBwb3cgcHJpbnRmIHB1dGNoYXIgcHV0cyBzY2FuZiBzaW5oIHNpbiBzbnByaW50ZiBzcHJpbnRmIHNxcnQgc3NjYW5mIHN0cmNhdCBzdHJjaHIgc3RyY21wIHN0cmNweSBzdHJjc3BuIHN0cmxlbiBzdHJuY2F0IHN0cm5jbXAgc3RybmNweSBzdHJwYnJrIHN0cnJjaHIgc3Ryc3BuIHN0cnN0ciB0YW5oIHRhbiB2ZnByaW50ZiB2cHJpbnRmIHZzcHJpbnRmIixsaXRlcmFsOiJ0cnVlIGZhbHNlIG51bGxwdHIgTlVMTCJ9O3JldHVybnthbGlhc2VzOlsiYyIsImNjIiwiaCIsImMrKyIsImgrKyIsImhwcCJdLGs6cyxpOiI8LyIsYzpbdCxlLkNMQ00sZS5DQkNNLGEscixuLHtiOiJcXGIoZGVxdWV8bGlzdHxxdWV1ZXxzdGFja3x2ZWN0b3J8bWFwfHNldHxiaXRzZXR8bXVsdGlzZXR8bXVsdGltYXB8dW5vcmRlcmVkX21hcHx1bm9yZGVyZWRfc2V0fHVub3JkZXJlZF9tdWx0aXNldHx1bm9yZGVyZWRfbXVsdGltYXB8YXJyYXkpXFxzKjwiLGU6Ij4iLGs6cyxjOlsic2VsZiIsdF19LHtiOmUuSVIrIjo6IixrOnN9LHtiSzoibmV3IHRocm93IHJldHVybiBlbHNlIixyOjB9LHtjTjoiZnVuY3Rpb24iLGI6IigiK2UuSVIrIltcXComXFxzXSspKyIraSxyQjohMCxlOi9bezs9XS8sZUU6ITAsazpzLGk6L1teXHdcc1wqJl0vLGM6W3tiOmksckI6ITAsYzpbZS5UTV0scjowfSx7Y046InBhcmFtcyIsYjovXCgvLGU6L1wpLyxrOnMscjowLGM6W2UuQ0xDTSxlLkNCQ00scixhXX0sZS5DTENNLGUuQ0JDTSxuXX1dfX0pLGUucmVnaXN0ZXJMYW5ndWFnZSgiY3MiLGZ1bmN0aW9uKGUpe3ZhciB0PSJhYnN0cmFjdCBhcyBiYXNlIGJvb2wgYnJlYWsgYnl0ZSBjYXNlIGNhdGNoIGNoYXIgY2hlY2tlZCBjb25zdCBjb250aW51ZSBkZWNpbWFsIGR5bmFtaWMgZGVmYXVsdCBkZWxlZ2F0ZSBkbyBkb3VibGUgZWxzZSBlbnVtIGV2ZW50IGV4cGxpY2l0IGV4dGVybiBmYWxzZSBmaW5hbGx5IGZpeGVkIGZsb2F0IGZvciBmb3JlYWNoIGdvdG8gaWYgaW1wbGljaXQgaW4gaW50IGludGVyZmFjZSBpbnRlcm5hbCBpcyBsb2NrIGxvbmcgbnVsbCB3aGVuIG9iamVjdCBvcGVyYXRvciBvdXQgb3ZlcnJpZGUgcGFyYW1zIHByaXZhdGUgcHJvdGVjdGVkIHB1YmxpYyByZWFkb25seSByZWYgc2J5dGUgc2VhbGVkIHNob3J0IHNpemVvZiBzdGFja2FsbG9jIHN0YXRpYyBzdHJpbmcgc3RydWN0IHN3aXRjaCB0aGlzIHRydWUgdHJ5IHR5cGVvZiB1aW50IHVsb25nIHVuY2hlY2tlZCB1bnNhZmUgdXNob3J0IHVzaW5nIHZpcnR1YWwgdm9sYXRpbGUgdm9pZCB3aGlsZSBhc3luYyBwcm90ZWN0ZWQgcHVibGljIHByaXZhdGUgaW50ZXJuYWwgYXNjZW5kaW5nIGRlc2NlbmRpbmcgZnJvbSBnZXQgZ3JvdXAgaW50byBqb2luIGxldCBvcmRlcmJ5IHBhcnRpYWwgc2VsZWN0IHNldCB2YWx1ZSB2YXIgd2hlcmUgeWllbGQiLHI9ZS5JUisiKDwiK2UuSVIrIj4pPyI7cmV0dXJue2FsaWFzZXM6WyJjc2hhcnAiXSxrOnQsaTovOjovLGM6W2UuQygiLy8vIiwiJCIse3JCOiEwLGM6W3tjTjoieG1sRG9jVGFnIix2Olt7YjoiLy8vIixyOjB9LHtiOiI8IS0tfC0tPiJ9LHtiOiI8Lz8iLGU6Ij4ifV19XX0pLGUuQ0xDTSxlLkNCQ00se2NOOiJwcmVwcm9jZXNzb3IiLGI6IiMiLGU6IiQiLGs6ImlmIGVsc2UgZWxpZiBlbmRpZiBkZWZpbmUgdW5kZWYgd2FybmluZyBlcnJvciBsaW5lIHJlZ2lvbiBlbmRyZWdpb24gcHJhZ21hIGNoZWNrc3VtIn0se2NOOiJzdHJpbmciLGI6J0AiJyxlOiciJyxjOlt7YjonIiInfV19LGUuQVNNLGUuUVNNLGUuQ05NLHtiSzoiY2xhc3MgaW50ZXJmYWNlIixlOi9bezs9XS8saTovW15cczpdLyxjOltlLlRNLGUuQ0xDTSxlLkNCQ01dfSx7Yks6Im5hbWVzcGFjZSIsZTovW3s7PV0vLGk6L1teXHM6XS8sYzpbe2NOOiJ0aXRsZSIsYjoiW2EtekEtWl0oXFwuP1xcdykqIixyOjB9LGUuQ0xDTSxlLkNCQ01dfSx7Yks6Im5ldyByZXR1cm4gdGhyb3cgYXdhaXQiLHI6MH0se2NOOiJmdW5jdGlvbiIsYjoiKCIrcisiXFxzKykrIitlLklSKyJcXHMqXFwoIixyQjohMCxlOi9bezs9XS8sZUU6ITAsazp0LGM6W3tiOmUuSVIrIlxccypcXCgiLHJCOiEwLGM6W2UuVE1dLHI6MH0se2NOOiJwYXJhbXMiLGI6L1woLyxlOi9cKS8sZUI6ITAsZUU6ITAsazp0LHI6MCxjOltlLkFTTSxlLlFTTSxlLkNOTSxlLkNCQ01dfSxlLkNMQ00sZS5DQkNNXX1dfX0pLGUucmVnaXN0ZXJMYW5ndWFnZSgiY3NzIixmdW5jdGlvbihlKXt2YXIgdD0iW2EtekEtWi1dW2EtekEtWjAtOV8tXSoiLHI9e2NOOiJmdW5jdGlvbiIsYjp0KyJcXCgiLHJCOiEwLGVFOiEwLGU6IlxcKCJ9LGE9e2NOOiJydWxlIixiOi9bQS1aXF9cLlwtXStccyo6LyxyQjohMCxlOiI7IixlVzohMCxjOlt7Y046ImF0dHJpYnV0ZSIsYjovXFMvLGU6IjoiLGVFOiEwLHN0YXJ0czp7Y046InZhbHVlIixlVzohMCxlRTohMCxjOltyLGUuQ1NTTk0sZS5RU00sZS5BU00sZS5DQkNNLHtjTjoiaGV4Y29sb3IiLGI6IiNbMC05QS1GYS1mXSsifSx7Y046ImltcG9ydGFudCIsYjoiIWltcG9ydGFudCJ9XX19XX07cmV0dXJue2NJOiEwLGk6L1s9XC98J1wkXS8sYzpbZS5DQkNNLHtjTjoiaWQiLGI6L1wjW0EtWmEtejAtOV8tXSsvfSx7Y046ImNsYXNzIixiOi9cLltBLVphLXowLTlfLV0rL30se2NOOiJhdHRyX3NlbGVjdG9yIixiOi9cWy8sZTovXF0vLGk6IiQifSx7Y046InBzZXVkbyIsYjovOig6KT9bYS16QS1aMC05XF9cLVwrXChcKSInXSsvfSx7Y046ImF0X3J1bGUiLGI6IkAoZm9udC1mYWNlfHBhZ2UpIixsOiJbYS16LV0rIixrOiJmb250LWZhY2UgcGFnZSJ9LHtjTjoiYXRfcnVsZSIsYjoiQCIsZToiW3s7XSIsYzpbe2NOOiJrZXl3b3JkIixiOi9cUysvfSx7YjovXHMvLGVXOiEwLGVFOiEwLHI6MCxjOltyLGUuQVNNLGUuUVNNLGUuQ1NTTk1dfV19LHtjTjoidGFnIixiOnQscjowfSx7Y046InJ1bGVzIixiOiJ7IixlOiJ9IixpOi9cUy8sYzpbZS5DQkNNLGFdfV19fSksZS5yZWdpc3Rlckxhbmd1YWdlKCJkaWZmIixmdW5jdGlvbihlKXtyZXR1cm57YWxpYXNlczpbInBhdGNoIl0sYzpbe2NOOiJjaHVuayIscjoxMCx2Olt7YjovXkBAICtcLVxkKyxcZCsgK1wrXGQrLFxkKyArQEAkL30se2I6L15cKlwqXCogK1xkKyxcZCsgK1wqXCpcKlwqJC99LHtiOi9eXC1cLVwtICtcZCssXGQrICtcLVwtXC1cLSQvfV19LHtjTjoiaGVhZGVyIix2Olt7YjovSW5kZXg6IC8sZTovJC99LHtiOi89PT09PS8sZTovPT09PT0kL30se2I6L15cLVwtXC0vLGU6LyQvfSx7YjovXlwqezN9IC8sZTovJC99LHtiOi9eXCtcK1wrLyxlOi8kL30se2I6L1wqezV9LyxlOi9cKns1fSQvfV19LHtjTjoiYWRkaXRpb24iLGI6Il5cXCsiLGU6IiQifSx7Y046ImRlbGV0aW9uIixiOiJeXFwtIixlOiIkIn0se2NOOiJjaGFuZ2UiLGI6Il5cXCEiLGU6IiQifV19fSksZS5yZWdpc3Rlckxhbmd1YWdlKCJodHRwIixmdW5jdGlvbihlKXtyZXR1cm57YWxpYXNlczpbImh0dHBzIl0saToiXFxTIixjOlt7Y046InN0YXR1cyIsYjoiXkhUVFAvWzAtOVxcLl0rIixlOiIkIixjOlt7Y046Im51bWJlciIsYjoiXFxiXFxkezN9XFxiIn1dfSx7Y046InJlcXVlc3QiLGI6Il5bQS1aXSsgKC4qPykgSFRUUC9bMC05XFwuXSskIixyQjohMCxlOiIkIixjOlt7Y046InN0cmluZyIsYjoiICIsZToiICIsZUI6ITAsZUU6ITB9XX0se2NOOiJhdHRyaWJ1dGUiLGI6Il5cXHciLGU6IjogIixlRTohMCxpOiJcXG58XFxzfD0iLHN0YXJ0czp7Y046InN0cmluZyIsZToiJCJ9fSx7YjoiXFxuXFxuIixzdGFydHM6e3NMOltdLGVXOiEwfX1dfX0pLGUucmVnaXN0ZXJMYW5ndWFnZSgiaW5pIixmdW5jdGlvbihlKXt2YXIgdD17Y046InN0cmluZyIsYzpbZS5CRV0sdjpbe2I6IicnJyIsZToiJycnIixyOjEwfSx7YjonIiIiJyxlOiciIiInLHI6MTB9LHtiOiciJyxlOiciJ30se2I6IiciLGU6IicifV19O3JldHVybnthbGlhc2VzOlsidG9tbCJdLGNJOiEwLGk6L1xTLyxjOltlLkMoIjsiLCIkIiksZS5IQ00se2NOOiJ0aXRsZSIsYjovXlxzKlxbKy8sZTovXF0rL30se2NOOiJzZXR0aW5nIixiOi9eW2EtejAtOVxbXF1fLV0rXHMqPVxzKi8sZToiJCIsYzpbe2NOOiJ2YWx1ZSIsZVc6ITAsazoib24gb2ZmIHRydWUgZmFsc2UgeWVzIG5vIixjOlt7Y046InZhcmlhYmxlIix2Olt7YjovXCRbXHdcZCJdW1x3XGRfXSovfSx7YjovXCRceyguKj8pfS99XX0sdCx7Y046Im51bWJlciIsYjovKFtcK1wtXSspP1tcZF0rX1tcZF9dKy99LGUuTk1dLHI6MH1dfV19fSksZS5yZWdpc3Rlckxhbmd1YWdlKCJqYXZhIixmdW5jdGlvbihlKXt2YXIgdD1lLlVJUisiKDwiK2UuVUlSKyI+KT8iLHI9ImZhbHNlIHN5bmNocm9uaXplZCBpbnQgYWJzdHJhY3QgZmxvYXQgcHJpdmF0ZSBjaGFyIGJvb2xlYW4gc3RhdGljIG51bGwgaWYgY29uc3QgZm9yIHRydWUgd2hpbGUgbG9uZyBzdHJpY3RmcCBmaW5hbGx5IHByb3RlY3RlZCBpbXBvcnQgbmF0aXZlIGZpbmFsIHZvaWQgZW51bSBlbHNlIGJyZWFrIHRyYW5zaWVudCBjYXRjaCBpbnN0YW5jZW9mIGJ5dGUgc3VwZXIgdm9sYXRpbGUgY2FzZSBhc3NlcnQgc2hvcnQgcGFja2FnZSBkZWZhdWx0IGRvdWJsZSBwdWJsaWMgdHJ5IHRoaXMgc3dpdGNoIGNvbnRpbnVlIHRocm93cyBwcm90ZWN0ZWQgcHVibGljIHByaXZhdGUiLGE9IlxcYigwW2JCXShbMDFdK1swMV9dK1swMV0rfFswMV0rKXwwW3hYXShbYS1mQS1GMC05XStbYS1mQS1GMC05X10rW2EtZkEtRjAtOV0rfFthLWZBLUYwLTldKyl8KChbXFxkXStbXFxkX10rW1xcZF0rfFtcXGRdKykoXFwuKFtcXGRdK1tcXGRfXStbXFxkXSt8W1xcZF0rKSk/fFxcLihbXFxkXStbXFxkX10rW1xcZF0rfFtcXGRdKykpKFtlRV1bLStdP1xcZCspPylbbExmRl0/IixuPXtjTjoibnVtYmVyIixiOmEscjowfTtyZXR1cm57YWxpYXNlczpbImpzcCJdLGs6cixpOi88XC98Iy8sYzpbZS5DKCIvXFwqXFwqIiwiXFwqLyIse3I6MCxjOlt7Y046ImRvY3RhZyIsYjoiQFtBLVphLXpdKyJ9XX0pLGUuQ0xDTSxlLkNCQ00sZS5BU00sZS5RU00se2NOOiJjbGFzcyIsYks6ImNsYXNzIGludGVyZmFjZSIsZTovW3s7PV0vLGVFOiEwLGs6ImNsYXNzIGludGVyZmFjZSIsaTovWzoiXFtcXV0vLGM6W3tiSzoiZXh0ZW5kcyBpbXBsZW1lbnRzIn0sZS5VVE1dfSx7Yks6Im5ldyB0aHJvdyByZXR1cm4gZWxzZSIscjowfSx7Y046ImZ1bmN0aW9uIixiOiIoIit0KyJcXHMrKSsiK2UuVUlSKyJcXHMqXFwoIixyQjohMCxlOi9bezs9XS8sZUU6ITAsazpyLGM6W3tiOmUuVUlSKyJcXHMqXFwoIixyQjohMCxyOjAsYzpbZS5VVE1dfSx7Y046InBhcmFtcyIsYjovXCgvLGU6L1wpLyxrOnIscjowLGM6W2UuQVNNLGUuUVNNLGUuQ05NLGUuQ0JDTV19LGUuQ0xDTSxlLkNCQ01dfSxuLHtjTjoiYW5ub3RhdGlvbiIsYjoiQFtBLVphLXpdKyJ9XX19KSxlLnJlZ2lzdGVyTGFuZ3VhZ2UoImphdmFzY3JpcHQiLGZ1bmN0aW9uKGUpe3JldHVybnthbGlhc2VzOlsianMiXSxrOntrZXl3b3JkOiJpbiBvZiBpZiBmb3Igd2hpbGUgZmluYWxseSB2YXIgbmV3IGZ1bmN0aW9uIGRvIHJldHVybiB2b2lkIGVsc2UgYnJlYWsgY2F0Y2ggaW5zdGFuY2VvZiB3aXRoIHRocm93IGNhc2UgZGVmYXVsdCB0cnkgdGhpcyBzd2l0Y2ggY29udGludWUgdHlwZW9mIGRlbGV0ZSBsZXQgeWllbGQgY29uc3QgZXhwb3J0IHN1cGVyIGRlYnVnZ2VyIGFzIGFzeW5jIGF3YWl0IixsaXRlcmFsOiJ0cnVlIGZhbHNlIG51bGwgdW5kZWZpbmVkIE5hTiBJbmZpbml0eSIsYnVpbHRfaW46ImV2YWwgaXNGaW5pdGUgaXNOYU4gcGFyc2VGbG9hdCBwYXJzZUludCBkZWNvZGVVUkkgZGVjb2RlVVJJQ29tcG9uZW50IGVuY29kZVVSSSBlbmNvZGVVUklDb21wb25lbnQgZXNjYXBlIHVuZXNjYXBlIE9iamVjdCBGdW5jdGlvbiBCb29sZWFuIEVycm9yIEV2YWxFcnJvciBJbnRlcm5hbEVycm9yIFJhbmdlRXJyb3IgUmVmZXJlbmNlRXJyb3IgU3RvcEl0ZXJhdGlvbiBTeW50YXhFcnJvciBUeXBlRXJyb3IgVVJJRXJyb3IgTnVtYmVyIE1hdGggRGF0ZSBTdHJpbmcgUmVnRXhwIEFycmF5IEZsb2F0MzJBcnJheSBGbG9hdDY0QXJyYXkgSW50MTZBcnJheSBJbnQzMkFycmF5IEludDhBcnJheSBVaW50MTZBcnJheSBVaW50MzJBcnJheSBVaW50OEFycmF5IFVpbnQ4Q2xhbXBlZEFycmF5IEFycmF5QnVmZmVyIERhdGFWaWV3IEpTT04gSW50bCBhcmd1bWVudHMgcmVxdWlyZSBtb2R1bGUgY29uc29sZSB3aW5kb3cgZG9jdW1lbnQgU3ltYm9sIFNldCBNYXAgV2Vha1NldCBXZWFrTWFwIFByb3h5IFJlZmxlY3QgUHJvbWlzZSJ9LGM6W3tjTjoicGkiLHI6MTAsYjovXlxzKlsnIl11c2UgKHN0cmljdHxhc20pWyciXS99LGUuQVNNLGUuUVNNLHtjTjoic3RyaW5nIixiOiJgIixlOiJgIixjOltlLkJFLHtjTjoic3Vic3QiLGI6IlxcJFxceyIsZToiXFx9In1dfSxlLkNMQ00sZS5DQkNNLHtjTjoibnVtYmVyIix2Olt7YjoiXFxiKDBbYkJdWzAxXSspIn0se2I6IlxcYigwW29PXVswLTddKykifSx7YjplLkNOUn1dLHI6MH0se2I6IigiK2UuUlNSKyJ8XFxiKGNhc2V8cmV0dXJufHRocm93KVxcYilcXHMqIixrOiJyZXR1cm4gdGhyb3cgY2FzZSIsYzpbZS5DTENNLGUuQ0JDTSxlLlJNLHtiOi88LyxlOi8+XHMqWyk7XF1dLyxyOjAsc0w6InhtbCJ9XSxyOjB9LHtjTjoiZnVuY3Rpb24iLGJLOiJmdW5jdGlvbiIsZTovXHsvLGVFOiEwLGM6W2UuaW5oZXJpdChlLlRNLHtiOi9bQS1aYS16JF9dWzAtOUEtWmEteiRfXSovfSkse2NOOiJwYXJhbXMiLGI6L1woLyxlOi9cKS8sZUI6ITAsZUU6ITAsYzpbZS5DTENNLGUuQ0JDTV19XSxpOi9cW3wlL30se2I6L1wkWyguXS99LHtiOiJcXC4iK2UuSVIscjowfSx7Yks6ImltcG9ydCIsZToiWzskXSIsazoiaW1wb3J0IGZyb20gYXMiLGM6W2UuQVNNLGUuUVNNXX0se2NOOiJjbGFzcyIsYks6ImNsYXNzIixlOi9bezs9XS8sZUU6ITAsaTovWzoiXFtcXV0vLGM6W3tiSzoiZXh0ZW5kcyJ9LGUuVVRNXX1dLGk6LyMvfX0pLGUucmVnaXN0ZXJMYW5ndWFnZSgianNvbiIsZnVuY3Rpb24oZSl7dmFyIHQ9e2xpdGVyYWw6InRydWUgZmFsc2UgbnVsbCJ9LHI9W2UuUVNNLGUuQ05NXSxhPXtjTjoidmFsdWUiLGU6IiwiLGVXOiEwLGVFOiEwLGM6cixrOnR9LG49e2I6InsiLGU6In0iLGM6W3tjTjoiYXR0cmlidXRlIixiOidcXHMqIicsZTonIlxccyo6XFxzKicsZUI6ITAsZUU6ITAsYzpbZS5CRV0saToiXFxuIixzdGFydHM6YX1dLGk6IlxcUyJ9LGk9e2I6IlxcWyIsZToiXFxdIixjOltlLmluaGVyaXQoYSx7Y046bnVsbH0pXSxpOiJcXFMifTtyZXR1cm4gci5zcGxpY2Uoci5sZW5ndGgsMCxuLGkpLHtjOnIsazp0LGk6IlxcUyJ9fSksZS5yZWdpc3Rlckxhbmd1YWdlKCJtYWtlZmlsZSIsZnVuY3Rpb24oZSl7dmFyIHQ9e2NOOiJ2YXJpYWJsZSIsYjovXCRcKC8sZTovXCkvLGM6W2UuQkVdfTtyZXR1cm57YWxpYXNlczpbIm1rIiwibWFrIl0sYzpbZS5IQ00se2I6L15cdytccypcVyo9LyxyQjohMCxyOjAsc3RhcnRzOntjTjoiY29uc3RhbnQiLGU6L1xzKlxXKj0vLGVFOiEwLHN0YXJ0czp7ZTovJC8scjowLGM6W3RdfX19LHtjTjoidGl0bGUiLGI6L15bXHddKzpccyokL30se2NOOiJwaG9ueSIsYjovXlwuUEhPTlk6LyxlOi8kLyxrOiIuUEhPTlkiLGw6L1tcLlx3XSsvfSx7YjovXlx0Ky8sZTovJC8scjowLGM6W2UuUVNNLHRdfV19fSksZS5yZWdpc3Rlckxhbmd1YWdlKCJ4bWwiLGZ1bmN0aW9uKGUpe3ZhciB0PSJbQS1aYS16MC05XFwuXzotXSsiLHI9e2I6LzxcPyhwaHApPyg/IVx3KS8sZTovXD8+LyxzTDoicGhwIn0sYT17ZVc6ITAsaTovPC8scjowLGM6W3Ise2NOOiJhdHRyaWJ1dGUiLGI6dCxyOjB9LHtiOiI9IixyOjAsYzpbe2NOOiJ2YWx1ZSIsYzpbcl0sdjpbe2I6LyIvLGU6LyIvfSx7YjovJy8sZTovJy99LHtiOi9bXlxzXC8+XSsvfV19XX1dfTtyZXR1cm57YWxpYXNlczpbImh0bWwiLCJ4aHRtbCIsInJzcyIsImF0b20iLCJ4c2wiLCJwbGlzdCJdLGNJOiEwLGM6W3tjTjoiZG9jdHlwZSIsYjoiPCFET0NUWVBFIixlOiI+IixyOjEwLGM6W3tiOiJcXFsiLGU6IlxcXSJ9XX0sZS5DKCI8IS0tIiwiLS0+Iix7cjoxMH0pLHtjTjoiY2RhdGEiLGI6IjxcXCFcXFtDREFUQVxcWyIsZToiXFxdXFxdPiIscjoxMH0se2NOOiJ0YWciLGI6IjxzdHlsZSg/PVxcc3w+fCQpIixlOiI+IixrOnt0aXRsZToic3R5bGUifSxjOlthXSxzdGFydHM6e2U6Ijwvc3R5bGU+IixyRTohMCxzTDoiY3NzIn19LHtjTjoidGFnIixiOiI8c2NyaXB0KD89XFxzfD58JCkiLGU6Ij4iLGs6e3RpdGxlOiJzY3JpcHQifSxjOlthXSxzdGFydHM6e2U6Ijwvc2NyaXB0PiIsckU6ITAsc0w6WyJhY3Rpb25zY3JpcHQiLCJqYXZhc2NyaXB0IiwiaGFuZGxlYmFycyJdfX0scix7Y046InBpIixiOi88XD9cdysvLGU6L1w/Pi8scjoxMH0se2NOOiJ0YWciLGI6IjwvPyIsZToiLz8+IixjOlt7Y046InRpdGxlIixiOi9bXiBcLz48XG5cdF0rLyxyOjB9LGFdfV19fSksZS5yZWdpc3Rlckxhbmd1YWdlKCJtYXJrZG93biIsZnVuY3Rpb24oZSl7cmV0dXJue2FsaWFzZXM6WyJtZCIsIm1rZG93biIsIm1rZCJdLGM6W3tjTjoiaGVhZGVyIix2Olt7YjoiXiN7MSw2fSIsZToiJCJ9LHtiOiJeLis/XFxuWz0tXXsyLH0kIn1dfSx7YjoiPCIsZToiPiIsc0w6InhtbCIscjowfSx7Y046ImJ1bGxldCIsYjoiXihbKistXXwoXFxkK1xcLikpXFxzKyJ9LHtjTjoic3Ryb25nIixiOiJbKl9dezJ9Lis/WypfXXsyfSJ9LHtjTjoiZW1waGFzaXMiLHY6W3tiOiJcXCouKz9cXCoifSx7YjoiXy4rP18iLHI6MH1dfSx7Y046ImJsb2NrcXVvdGUiLGI6Il4+XFxzKyIsZToiJCJ9LHtjTjoiY29kZSIsdjpbe2I6ImAuKz9gIn0se2I6Il4oIHs0fXwJKSIsZToiJCIscjowfV19LHtjTjoiaG9yaXpvbnRhbF9ydWxlIixiOiJeWy1cXCpdezMsfSIsZToiJCJ9LHtiOiJcXFsuKz9cXF1bXFwoXFxbXS4qP1tcXClcXF1dIixyQjohMCxjOlt7Y046ImxpbmtfbGFiZWwiLGI6IlxcWyIsZToiXFxdIixlQjohMCxyRTohMCxyOjB9LHtjTjoibGlua191cmwiLGI6IlxcXVxcKCIsZToiXFwpIixlQjohMCxlRTohMH0se2NOOiJsaW5rX3JlZmVyZW5jZSIsYjoiXFxdXFxbIixlOiJcXF0iLGVCOiEwLGVFOiEwfV0scjoxMH0se2I6Il5cXFsuK1xcXToiLHJCOiEwLGM6W3tjTjoibGlua19yZWZlcmVuY2UiLGI6IlxcWyIsZToiXFxdOiIsZUI6ITAsZUU6ITAsc3RhcnRzOntjTjoibGlua191cmwiLGU6IiQifX1dfV19fSksZS5yZWdpc3Rlckxhbmd1YWdlKCJuZ2lueCIsZnVuY3Rpb24oZSl7dmFyIHQ9e2NOOiJ2YXJpYWJsZSIsdjpbe2I6L1wkXGQrL30se2I6L1wkXHsvLGU6L30vfSx7YjoiW1xcJFxcQF0iK2UuVUlSfV19LHI9e2VXOiEwLGw6IlthLXovX10rIixrOntidWlsdF9pbjoib24gb2ZmIHllcyBubyB0cnVlIGZhbHNlIG5vbmUgYmxvY2tlZCBkZWJ1ZyBpbmZvIG5vdGljZSB3YXJuIGVycm9yIGNyaXQgc2VsZWN0IGJyZWFrIGxhc3QgcGVybWFuZW50IHJlZGlyZWN0IGtxdWV1ZSBydHNpZyBlcG9sbCBwb2xsIC9kZXYvcG9sbCJ9LHI6MCxpOiI9PiIsYzpbZS5IQ00se2NOOiJzdHJpbmciLGM6W2UuQkUsdF0sdjpbe2I6LyIvLGU6LyIvfSx7YjovJy8sZTovJy99XX0se2NOOiJ1cmwiLGI6IihbYS16XSspOi8iLGU6IlxccyIsZVc6ITAsZUU6ITAsYzpbdF19LHtjTjoicmVnZXhwIixjOltlLkJFLHRdLHY6W3tiOiJcXHNcXF4iLGU6Ilxcc3x7fDsiLHJFOiEwfSx7YjoiflxcKj9cXHMrIixlOiJcXHN8e3w7IixyRTohMH0se2I6IlxcKihcXC5bYS16XFwtXSspKyJ9LHtiOiIoW2EtelxcLV0rXFwuKStcXCoifV19LHtjTjoibnVtYmVyIixiOiJcXGJcXGR7MSwzfVxcLlxcZHsxLDN9XFwuXFxkezEsM31cXC5cXGR7MSwzfSg6XFxkezEsNX0pP1xcYiJ9LHtjTjoibnVtYmVyIixiOiJcXGJcXGQrW2tLbU1nR2RzaGR3eV0qXFxiIixyOjB9LHRdfTtyZXR1cm57YWxpYXNlczpbIm5naW54Y29uZiJdLGM6W2UuSENNLHtiOmUuVUlSKyJcXHMiLGU6Ijt8eyIsckI6ITAsYzpbe2NOOiJ0aXRsZSIsYjplLlVJUixzdGFydHM6cn1dLHI6MH1dLGk6IlteXFxzXFx9XSJ9fSksZS5yZWdpc3Rlckxhbmd1YWdlKCJvYmplY3RpdmVjIixmdW5jdGlvbihlKXt2YXIgdD17Y046ImJ1aWx0X2luIixiOiIoQVZ8Q0F8Q0Z8Q0d8Q0l8TUt8TVB8TlN8VUkpXFx3KyJ9LHI9e2tleXdvcmQ6ImludCBmbG9hdCB3aGlsZSBjaGFyIGV4cG9ydCBzaXplb2YgdHlwZWRlZiBjb25zdCBzdHJ1Y3QgZm9yIHVuaW9uIHVuc2lnbmVkIGxvbmcgdm9sYXRpbGUgc3RhdGljIGJvb2wgbXV0YWJsZSBpZiBkbyByZXR1cm4gZ290byB2b2lkIGVudW0gZWxzZSBicmVhayBleHRlcm4gYXNtIGNhc2Ugc2hvcnQgZGVmYXVsdCBkb3VibGUgcmVnaXN0ZXIgZXhwbGljaXQgc2lnbmVkIHR5cGVuYW1lIHRoaXMgc3dpdGNoIGNvbnRpbnVlIHdjaGFyX3QgaW5saW5lIHJlYWRvbmx5IGFzc2lnbiByZWFkd3JpdGUgc2VsZiBAc3luY2hyb25pemVkIGlkIHR5cGVvZiBub25hdG9taWMgc3VwZXIgdW5pY2hhciBJQk91dGxldCBJQkFjdGlvbiBzdHJvbmcgd2VhayBjb3B5IGluIG91dCBpbm91dCBieWNvcHkgYnlyZWYgb25ld2F5IF9fc3Ryb25nIF9fd2VhayBfX2Jsb2NrIF9fYXV0b3JlbGVhc2luZyBAcHJpdmF0ZSBAcHJvdGVjdGVkIEBwdWJsaWMgQHRyeSBAcHJvcGVydHkgQGVuZCBAdGhyb3cgQGNhdGNoIEBmaW5hbGx5IEBhdXRvcmVsZWFzZXBvb2wgQHN5bnRoZXNpemUgQGR5bmFtaWMgQHNlbGVjdG9yIEBvcHRpb25hbCBAcmVxdWlyZWQiLGxpdGVyYWw6ImZhbHNlIHRydWUgRkFMU0UgVFJVRSBuaWwgWUVTIE5PIE5VTEwiLGJ1aWx0X2luOiJCT09MIGRpc3BhdGNoX29uY2VfdCBkaXNwYXRjaF9xdWV1ZV90IGRpc3BhdGNoX3N5bmMgZGlzcGF0Y2hfYXN5bmMgZGlzcGF0Y2hfb25jZSJ9LGE9L1thLXpBLVpAXVthLXpBLVowLTlfXSovLG49IkBpbnRlcmZhY2UgQGNsYXNzIEBwcm90b2NvbCBAaW1wbGVtZW50YXRpb24iO3JldHVybnthbGlhc2VzOlsibW0iLCJvYmpjIiwib2JqLWMiXSxrOnIsbDphLGk6IjwvIixjOlt0LGUuQ0xDTSxlLkNCQ00sZS5DTk0sZS5RU00se2NOOiJzdHJpbmciLHY6W3tiOidAIicsZTonIicsaToiXFxuIixjOltlLkJFXX0se2I6IiciLGU6IlteXFxcXF0nIixpOiJbXlxcXFxdW14nXSJ9XX0se2NOOiJwcmVwcm9jZXNzb3IiLGI6IiMiLGU6IiQiLGM6W3tjTjoidGl0bGUiLHY6W3tiOiciJyxlOiciJ30se2I6IjwiLGU6Ij4ifV19XX0se2NOOiJjbGFzcyIsYjoiKCIrbi5zcGxpdCgiICIpLmpvaW4oInwiKSsiKVxcYiIsZToiKHt8JCkiLGVFOiEwLGs6bixsOmEsYzpbZS5VVE1dfSx7Y046InZhcmlhYmxlIixiOiJcXC4iK2UuVUlSLHI6MH1dfX0pLGUucmVnaXN0ZXJMYW5ndWFnZSgicGVybCIsZnVuY3Rpb24oZSl7dmFyIHQ9ImdldHB3ZW50IGdldHNlcnZlbnQgcXVvdGVtZXRhIG1zZ3JjdiBzY2FsYXIga2lsbCBkYm1jbG9zZSB1bmRlZiBsYyBtYSBzeXN3cml0ZSB0ciBzZW5kIHVtYXNrIHN5c29wZW4gc2htd3JpdGUgdmVjIHF4IHV0aW1lIGxvY2FsIG9jdCBzZW1jdGwgbG9jYWx0aW1lIHJlYWRwaXBlIGRvIHJldHVybiBmb3JtYXQgcmVhZCBzcHJpbnRmIGRibW9wZW4gcG9wIGdldHBncnAgbm90IGdldHB3bmFtIHJld2luZGRpciBxcWZpbGVubyBxdyBlbmRwcm90b2VudCB3YWl0IHNldGhvc3RlbnQgYmxlc3Mgc3wwIG9wZW5kaXIgY29udGludWUgZWFjaCBzbGVlcCBlbmRncmVudCBzaHV0ZG93biBkdW1wIGNob21wIGNvbm5lY3QgZ2V0c29ja25hbWUgZGllIHNvY2tldHBhaXIgY2xvc2UgZmxvY2sgZXhpc3RzIGluZGV4IHNobWdldHN1YiBmb3IgZW5kcHdlbnQgcmVkbyBsc3RhdCBtc2djdGwgc2V0cGdycCBhYnMgZXhpdCBzZWxlY3QgcHJpbnQgcmVmIGdldGhvc3RieWFkZHIgdW5zaGlmdCBmY250bCBzeXNjYWxsIGdvdG8gZ2V0bmV0YnlhZGRyIGpvaW4gZ210aW1lIHN5bWxpbmsgc2VtZ2V0IHNwbGljZSB4fDAgZ2V0cGVlcm5hbWUgcmVjdiBsb2cgc2V0c29ja29wdCBjb3MgbGFzdCByZXZlcnNlIGdldGhvc3RieW5hbWUgZ2V0Z3JuYW0gc3R1ZHkgZm9ybWxpbmUgZW5kaG9zdGVudCB0aW1lcyBjaG9wIGxlbmd0aCBnZXRob3N0ZW50IGdldG5ldGVudCBwYWNrIGdldHByb3RvZW50IGdldHNlcnZieW5hbWUgcmFuZCBta2RpciBwb3MgY2htb2QgeXwwIHN1YnN0ciBlbmRuZXRlbnQgcHJpbnRmIG5leHQgb3BlbiBtc2dzbmQgcmVhZGRpciB1c2UgdW5saW5rIGdldHNvY2tvcHQgZ2V0cHJpb3JpdHkgcmluZGV4IHdhbnRhcnJheSBoZXggc3lzdGVtIGdldHNlcnZieXBvcnQgZW5kc2VydmVudCBpbnQgY2hyIHVudGllIHJtZGlyIHByb3RvdHlwZSB0ZWxsIGxpc3RlbiBmb3JrIHNobXJlYWQgdWNmaXJzdCBzZXRwcm90b2VudCBlbHNlIHN5c3NlZWsgbGluayBnZXRncmdpZCBzaG1jdGwgd2FpdHBpZCB1bnBhY2sgZ2V0bmV0YnluYW1lIHJlc2V0IGNoZGlyIGdyZXAgc3BsaXQgcmVxdWlyZSBjYWxsZXIgbGNmaXJzdCB1bnRpbCB3YXJuIHdoaWxlIHZhbHVlcyBzaGlmdCB0ZWxsZGlyIGdldHB3dWlkIG15IGdldHByb3RvYnludW1iZXIgZGVsZXRlIGFuZCBzb3J0IHVjIGRlZmluZWQgc3JhbmQgYWNjZXB0IHBhY2thZ2Ugc2Vla2RpciBnZXRwcm90b2J5bmFtZSBzZW1vcCBvdXIgcmVuYW1lIHNlZWsgaWYgcXwwIGNocm9vdCBzeXNyZWFkIHNldHB3ZW50IG5vIGNyeXB0IGdldGMgY2hvd24gc3FydCB3cml0ZSBzZXRuZXRlbnQgc2V0cHJpb3JpdHkgZm9yZWFjaCB0aWUgc2luIG1zZ2dldCBtYXAgc3RhdCBnZXRsb2dpbiB1bmxlc3MgZWxzaWYgdHJ1bmNhdGUgZXhlYyBrZXlzIGdsb2IgdGllZCBjbG9zZWRpcmlvY3RsIHNvY2tldCByZWFkbGluayBldmFsIHhvciByZWFkbGluZSBiaW5tb2RlIHNldHNlcnZlbnQgZW9mIG9yZCBiaW5kIGFsYXJtIHBpcGUgYXRhbjIgZ2V0Z3JlbnQgZXhwIHRpbWUgcHVzaCBzZXRncmVudCBndCBsdCBvciBuZSBtfDAgYnJlYWsgZ2l2ZW4gc2F5IHN0YXRlIHdoZW4iLHI9e2NOOiJzdWJzdCIsYjoiWyRAXVxceyIsZToiXFx9IixrOnR9LGE9e2I6Ii0+eyIsZToifSJ9LG49e2NOOiJ2YXJpYWJsZSIsdjpbe2I6L1wkXGQvfSx7YjovW1wkJUBdKFxeXHdcYnwjXHcrKDo6XHcrKSp8e1x3K318XHcrKDo6XHcqKSopL30se2I6L1tcJCVAXVteXHNcd3tdLyxyOjB9XX0saT1bZS5CRSxyLG5dLHM9W24sZS5IQ00sZS5DKCJeXFw9XFx3IiwiXFw9Y3V0Iix7ZVc6ITB9KSxhLHtjTjoic3RyaW5nIixjOmksdjpbe2I6InFbcXd4cl0/XFxzKlxcKCIsZToiXFwpIixyOjV9LHtiOiJxW3F3eHJdP1xccypcXFsiLGU6IlxcXSIscjo1fSx7YjoicVtxd3hyXT9cXHMqXFx7IixlOiJcXH0iLHI6NX0se2I6InFbcXd4cl0/XFxzKlxcfCIsZToiXFx8IixyOjV9LHtiOiJxW3F3eHJdP1xccypcXDwiLGU6IlxcPiIscjo1fSx7YjoicXdcXHMrcSIsZToicSIscjo1fSx7YjoiJyIsZToiJyIsYzpbZS5CRV19LHtiOiciJyxlOiciJ30se2I6ImAiLGU6ImAiLGM6W2UuQkVdfSx7Yjoie1xcdyt9IixjOltdLHI6MH0se2I6Ii0/XFx3K1xccypcXD1cXD4iLGM6W10scjowfV19LHtjTjoibnVtYmVyIixiOiIoXFxiMFswLTdfXSspfChcXGIweFswLTlhLWZBLUZfXSspfChcXGJbMS05XVswLTlfXSooXFwuWzAtOV9dKyk/KXxbMF9dXFxiIixyOjB9LHtiOiIoXFwvXFwvfCIrZS5SU1IrInxcXGIoc3BsaXR8cmV0dXJufHByaW50fHJldmVyc2V8Z3JlcClcXGIpXFxzKiIsazoic3BsaXQgcmV0dXJuIHByaW50IHJldmVyc2UgZ3JlcCIscjowLGM6W2UuSENNLHtjTjoicmVnZXhwIixiOiIoc3x0cnx5KS8oXFxcXC58W14vXSkqLyhcXFxcLnxbXi9dKSovW2Etel0qIixyOjEwfSx7Y046InJlZ2V4cCIsYjoiKG18cXIpPy8iLGU6Ii9bYS16XSoiLGM6W2UuQkVdLHI6MH1dfSx7Y046InN1YiIsYks6InN1YiIsZToiKFxccypcXCguKj9cXCkpP1s7e10iLHI6NX0se2NOOiJvcGVyYXRvciIsYjoiLVxcd1xcYiIscjowfSx7YjoiXl9fREFUQV9fJCIsZToiXl9fRU5EX18kIixzTDoibW9qb2xpY2lvdXMiLGM6W3tiOiJeQEAuKiIsZToiJCIsY046ImNvbW1lbnQifV19XTtyZXR1cm4gci5jPXMsYS5jPXMse2FsaWFzZXM6WyJwbCJdLGs6dCxjOnN9fSksZS5yZWdpc3Rlckxhbmd1YWdlKCJwaHAiLGZ1bmN0aW9uKGUpe3ZhciB0PXtjTjoidmFyaWFibGUiLGI6IlxcJCtbYS16QS1aX38tw79dW2EtekEtWjAtOV9/LcO/XSoifSxyPXtjTjoicHJlcHJvY2Vzc29yIixiOi88XD8ocGhwKT98XD8+L30sYT17Y046InN0cmluZyIsYzpbZS5CRSxyXSx2Olt7YjonYiInLGU6JyInfSx7YjoiYiciLGU6IicifSxlLmluaGVyaXQoZS5BU00se2k6bnVsbH0pLGUuaW5oZXJpdChlLlFTTSx7aTpudWxsfSldfSxuPXt2OltlLkJOTSxlLkNOTV19O3JldHVybnthbGlhc2VzOlsicGhwMyIsInBocDQiLCJwaHA1IiwicGhwNiJdLGNJOiEwLGs6ImFuZCBpbmNsdWRlX29uY2UgbGlzdCBhYnN0cmFjdCBnbG9iYWwgcHJpdmF0ZSBlY2hvIGludGVyZmFjZSBhcyBzdGF0aWMgZW5kc3dpdGNoIGFycmF5IG51bGwgaWYgZW5kd2hpbGUgb3IgY29uc3QgZm9yIGVuZGZvcmVhY2ggc2VsZiB2YXIgd2hpbGUgaXNzZXQgcHVibGljIHByb3RlY3RlZCBleGl0IGZvcmVhY2ggdGhyb3cgZWxzZWlmIGluY2x1ZGUgX19GSUxFX18gZW1wdHkgcmVxdWlyZV9vbmNlIGRvIHhvciByZXR1cm4gcGFyZW50IGNsb25lIHVzZSBfX0NMQVNTX18gX19MSU5FX18gZWxzZSBicmVhayBwcmludCBldmFsIG5ldyBjYXRjaCBfX01FVEhPRF9fIGNhc2UgZXhjZXB0aW9uIGRlZmF1bHQgZGllIHJlcXVpcmUgX19GVU5DVElPTl9fIGVuZGRlY2xhcmUgZmluYWwgdHJ5IHN3aXRjaCBjb250aW51ZSBlbmRmb3IgZW5kaWYgZGVjbGFyZSB1bnNldCB0cnVlIGZhbHNlIHRyYWl0IGdvdG8gaW5zdGFuY2VvZiBpbnN0ZWFkb2YgX19ESVJfXyBfX05BTUVTUEFDRV9fIHlpZWxkIGZpbmFsbHkiLGM6W2UuQ0xDTSxlLkhDTSxlLkMoIi9cXCoiLCJcXCovIix7Yzpbe2NOOiJkb2N0YWciLGI6IkBbQS1aYS16XSsifSxyXX0pLGUuQygiX19oYWx0X2NvbXBpbGVyLis/OyIsITEse2VXOiEwLGs6Il9faGFsdF9jb21waWxlciIsbDplLlVJUn0pLHtjTjoic3RyaW5nIixiOi88PDxbJyJdP1x3K1snIl0/JC8sZTovXlx3Kzs/JC8sYzpbZS5CRSx7Y046InN1YnN0Iix2Olt7YjovXCRcdysvfSx7YjovXHtcJC8sZTovXH0vfV19XX0scix0LHtiOi8oOjp8LT4pK1thLXpBLVpfXHg3Zi1ceGZmXVthLXpBLVowLTlfXHg3Zi1ceGZmXSovfSx7Y046ImZ1bmN0aW9uIixiSzoiZnVuY3Rpb24iLGU6L1s7e10vLGVFOiEwLGk6IlxcJHxcXFt8JSIsYzpbZS5VVE0se2NOOiJwYXJhbXMiLGI6IlxcKCIsZToiXFwpIixjOlsic2VsZiIsdCxlLkNCQ00sYSxuXX1dfSx7Y046ImNsYXNzIixiSzoiY2xhc3MgaW50ZXJmYWNlIixlOiJ7IixlRTohMCxpOi9bOlwoXCQiXS8sYzpbe2JLOiJleHRlbmRzIGltcGxlbWVudHMifSxlLlVUTV19LHtiSzoibmFtZXNwYWNlIixlOiI7IixpOi9bXC4nXS8sYzpbZS5VVE1dfSx7Yks6InVzZSIsZToiOyIsYzpbZS5VVE1dfSx7YjoiPT4ifSxhLG5dfX0pLGUucmVnaXN0ZXJMYW5ndWFnZSgicHl0aG9uIixmdW5jdGlvbihlKXt2YXIgdD17Y046InByb21wdCIsYjovXig+Pj58XC5cLlwuKSAvfSxyPXtjTjoic3RyaW5nIixjOltlLkJFXSx2Olt7YjovKHV8Yik/cj8nJycvLGU6LycnJy8sYzpbdF0scjoxMH0se2I6Lyh1fGIpP3I/IiIiLyxlOi8iIiIvLGM6W3RdLHI6MTB9LHtiOi8odXxyfHVyKScvLGU6LycvLHI6MTB9LHtiOi8odXxyfHVyKSIvLGU6LyIvLHI6MTB9LHtiOi8oYnxiciknLyxlOi8nL30se2I6LyhifGJyKSIvLGU6LyIvfSxlLkFTTSxlLlFTTV19LGE9e2NOOiJudW1iZXIiLHI6MCx2Olt7YjplLkJOUisiW2xMakpdPyJ9LHtiOiJcXGIoMG9bMC03XSspW2xMakpdPyJ9LHtiOmUuQ05SKyJbbExqSl0/In1dfSxuPXtjTjoicGFyYW1zIixiOi9cKC8sZTovXCkvLGM6WyJzZWxmIix0LGEscl19O3JldHVybnthbGlhc2VzOlsicHkiLCJneXAiXSxrOntrZXl3b3JkOiJhbmQgZWxpZiBpcyBnbG9iYWwgYXMgaW4gaWYgZnJvbSByYWlzZSBmb3IgZXhjZXB0IGZpbmFsbHkgcHJpbnQgaW1wb3J0IHBhc3MgcmV0dXJuIGV4ZWMgZWxzZSBicmVhayBub3Qgd2l0aCBjbGFzcyBhc3NlcnQgeWllbGQgdHJ5IHdoaWxlIGNvbnRpbnVlIGRlbCBvciBkZWYgbGFtYmRhIGFzeW5jIGF3YWl0IG5vbmxvY2FsfDEwIE5vbmUgVHJ1ZSBGYWxzZSIsYnVpbHRfaW46IkVsbGlwc2lzIE5vdEltcGxlbWVudGVkIn0saTovKDxcL3wtPnxcPykvLGM6W3QsYSxyLGUuSENNLHt2Olt7Y046ImZ1bmN0aW9uIixiSzoiZGVmIixyOjEwfSx7Y046ImNsYXNzIixiSzoiY2xhc3MifV0sZTovOi8saTovWyR7PTtcbixdLyxjOltlLlVUTSxuXX0se2NOOiJkZWNvcmF0b3IiLGI6L15bXHQgXSpALyxlOi8kL30se2I6L1xiKHByaW50fGV4ZWMpXCgvfV19fSksZS5yZWdpc3Rlckxhbmd1YWdlKCJydWJ5IixmdW5jdGlvbihlKXt2YXIgdD0iW2EtekEtWl9dXFx3KlshPz1dP3xbLSt+XVxcQHw8PHw+Pnw9fnw9PT0/fDw9PnxbPD5dPT98XFwqXFwqfFstLyslXiYqfmB8XXxcXFtcXF09PyIscj0iYW5kIGZhbHNlIHRoZW4gZGVmaW5lZCBtb2R1bGUgaW4gcmV0dXJuIHJlZG8gaWYgQkVHSU4gcmV0cnkgZW5kIGZvciB0cnVlIHNlbGYgd2hlbiBuZXh0IHVudGlsIGRvIGJlZ2luIHVubGVzcyBFTkQgcmVzY3VlIG5pbCBlbHNlIGJyZWFrIHVuZGVmIG5vdCBzdXBlciBjbGFzcyBjYXNlIHJlcXVpcmUgeWllbGQgYWxpYXMgd2hpbGUgZW5zdXJlIGVsc2lmIG9yIGluY2x1ZGUgYXR0cl9yZWFkZXIgYXR0cl93cml0ZXIgYXR0cl9hY2Nlc3NvciIsYT17Y046ImRvY3RhZyIsYjoiQFtBLVphLXpdKyJ9LG49e2NOOiJ2YWx1ZSIsYjoiIzwiLGU6Ij4ifSxpPVtlLkMoIiMiLCIkIix7YzpbYV19KSxlLkMoIl5cXD1iZWdpbiIsIl5cXD1lbmQiLHtjOlthXSxyOjEwfSksZS5DKCJeX19FTkRfXyIsIlxcbiQiKV0scz17Y046InN1YnN0IixiOiIjXFx7IixlOiJ9IixrOnJ9LGM9e2NOOiJzdHJpbmciLGM6W2UuQkUsc10sdjpbe2I6LycvLGU6LycvfSx7YjovIi8sZTovIi99LHtiOi9gLyxlOi9gL30se2I6IiVbcVF3V3hdP1xcKCIsZToiXFwpIn0se2I6IiVbcVF3V3hdP1xcWyIsZToiXFxdIn0se2I6IiVbcVF3V3hdP3siLGU6In0ifSx7YjoiJVtxUXdXeF0/PCIsZToiPiJ9LHtiOiIlW3FRd1d4XT8vIixlOiIvIn0se2I6IiVbcVF3V3hdPyUiLGU6IiUifSx7YjoiJVtxUXdXeF0/LSIsZToiLSJ9LHtiOiIlW3FRd1d4XT9cXHwiLGU6IlxcfCJ9LHtiOi9cQlw/KFxcXGR7MSwzfXxcXHhbQS1GYS1mMC05XXsxLDJ9fFxcdVtBLUZhLWYwLTldezR9fFxcP1xTKVxiL31dfSxvPXtjTjoicGFyYW1zIixiOiJcXCgiLGU6IlxcKSIsazpyfSxsPVtjLG4se2NOOiJjbGFzcyIsYks6ImNsYXNzIG1vZHVsZSIsZToiJHw7IixpOi89LyxjOltlLmluaGVyaXQoZS5UTSx7YjoiW0EtWmEtel9dXFx3Kig6OlxcdyspKihcXD98XFwhKT8ifSkse2NOOiJpbmhlcml0YW5jZSIsYjoiPFxccyoiLGM6W3tjTjoicGFyZW50IixiOiIoIitlLklSKyI6Oik/IitlLklSfV19XS5jb25jYXQoaSl9LHtjTjoiZnVuY3Rpb24iLGJLOiJkZWYiLGU6IiR8OyIsYzpbZS5pbmhlcml0KGUuVE0se2I6dH0pLG9dLmNvbmNhdChpKX0se2NOOiJjb25zdGFudCIsYjoiKDo6KT8oXFxiW0EtWl1cXHcqKDo6KT8pKyIscjowfSx7Y046InN5bWJvbCIsYjplLlVJUisiKFxcIXxcXD8pPzoiLHI6MH0se2NOOiJzeW1ib2wiLGI6IjoiLGM6W2Mse2I6dH1dLHI6MH0se2NOOiJudW1iZXIiLGI6IihcXGIwWzAtN19dKyl8KFxcYjB4WzAtOWEtZkEtRl9dKyl8KFxcYlsxLTldWzAtOV9dKihcXC5bMC05X10rKT8pfFswX11cXGIiLHI6MH0se2NOOiJ2YXJpYWJsZSIsYjoiKFxcJFxcVyl8KChcXCR8XFxAXFxAPykoXFx3KykpIn0se2I6IigiK2UuUlNSKyIpXFxzKiIsYzpbbix7Y046InJlZ2V4cCIsYzpbZS5CRSxzXSxpOi9cbi8sdjpbe2I6Ii8iLGU6Ii9bYS16XSoifSx7YjoiJXJ7IixlOiJ9W2Etel0qIn0se2I6IiVyXFwoIixlOiJcXClbYS16XSoifSx7YjoiJXIhIixlOiIhW2Etel0qIn0se2I6IiVyXFxbIixlOiJcXF1bYS16XSoifV19XS5jb25jYXQoaSkscjowfV0uY29uY2F0KGkpO3MuYz1sLG8uYz1sO3ZhciB1PSJbPj9dPiIsZD0iW1xcdyNdK1xcKFxcdytcXCk6XFxkKzpcXGQrPiIsYj0iKFxcdystKT9cXGQrXFwuXFxkK1xcLlxcZChwXFxkKyk/W14+XSs+IixwPVt7YjovXlxzKj0+LyxjTjoic3RhdHVzIixzdGFydHM6e2U6IiQiLGM6bH19LHtjTjoicHJvbXB0IixiOiJeKCIrdSsifCIrZCsifCIrYisiKSIsc3RhcnRzOntlOiIkIixjOmx9fV07cmV0dXJue2FsaWFzZXM6WyJyYiIsImdlbXNwZWMiLCJwb2RzcGVjIiwidGhvciIsImlyYiJdLGs6cixpOi9cL1wqLyxjOmkuY29uY2F0KHApLmNvbmNhdChsKX19KSxlLnJlZ2lzdGVyTGFuZ3VhZ2UoInNxbCIsZnVuY3Rpb24oZSl7dmFyIHQ9ZS5DKCItLSIsIiQiKTtyZXR1cm57Y0k6ITAsaTovWzw+e30qXS8sYzpbe2NOOiJvcGVyYXRvciIsYks6ImJlZ2luIGVuZCBzdGFydCBjb21taXQgcm9sbGJhY2sgc2F2ZXBvaW50IGxvY2sgYWx0ZXIgY3JlYXRlIGRyb3AgcmVuYW1lIGNhbGwgZGVsZXRlIGRvIGhhbmRsZXIgaW5zZXJ0IGxvYWQgcmVwbGFjZSBzZWxlY3QgdHJ1bmNhdGUgdXBkYXRlIHNldCBzaG93IHByYWdtYSBncmFudCBtZXJnZSBkZXNjcmliZSB1c2UgZXhwbGFpbiBoZWxwIGRlY2xhcmUgcHJlcGFyZSBleGVjdXRlIGRlYWxsb2NhdGUgcmVsZWFzZSB1bmxvY2sgcHVyZ2UgcmVzZXQgY2hhbmdlIHN0b3AgYW5hbHl6ZSBjYWNoZSBmbHVzaCBvcHRpbWl6ZSByZXBhaXIga2lsbCBpbnN0YWxsIHVuaW5zdGFsbCBjaGVja3N1bSByZXN0b3JlIGNoZWNrIGJhY2t1cCByZXZva2UiLGU6LzsvLGVXOiEwLGs6e2tleXdvcmQ6ImFib3J0IGFicyBhYnNvbHV0ZSBhY2MgYWNjZSBhY2NlcCBhY2NlcHQgYWNjZXNzIGFjY2Vzc2VkIGFjY2Vzc2libGUgYWNjb3VudCBhY29zIGFjdGlvbiBhY3RpdmF0ZSBhZGQgYWRkdGltZSBhZG1pbiBhZG1pbmlzdGVyIGFkdmFuY2VkIGFkdmlzZSBhZXNfZGVjcnlwdCBhZXNfZW5jcnlwdCBhZnRlciBhZ2VudCBhZ2dyZWdhdGUgYWxpIGFsaWEgYWxpYXMgYWxsb2NhdGUgYWxsb3cgYWx0ZXIgYWx3YXlzIGFuYWx5emUgYW5jaWxsYXJ5IGFuZCBhbnkgYW55ZGF0YSBhbnlkYXRhc2V0IGFueXNjaGVtYSBhbnl0eXBlIGFwcGx5IGFyY2hpdmUgYXJjaGl2ZWQgYXJjaGl2ZWxvZyBhcmUgYXMgYXNjIGFzY2lpIGFzaW4gYXNzZW1ibHkgYXNzZXJ0aW9uIGFzc29jaWF0ZSBhc3luY2hyb25vdXMgYXQgYXRhbiBhdG4yIGF0dHIgYXR0cmkgYXR0cmliIGF0dHJpYnUgYXR0cmlidXQgYXR0cmlidXRlIGF0dHJpYnV0ZXMgYXVkaXQgYXV0aGVudGljYXRlZCBhdXRoZW50aWNhdGlvbiBhdXRoaWQgYXV0aG9ycyBhdXRvIGF1dG9hbGxvY2F0ZSBhdXRvZGJsaW5rIGF1dG9leHRlbmQgYXV0b21hdGljIGF2YWlsYWJpbGl0eSBhdmcgYmFja3VwIGJhZGZpbGUgYmFzaWNmaWxlIGJlZm9yZSBiZWdpbiBiZWdpbm5pbmcgYmVuY2htYXJrIGJldHdlZW4gYmZpbGUgYmZpbGVfYmFzZSBiaWcgYmlnZmlsZSBiaW4gYmluYXJ5X2RvdWJsZSBiaW5hcnlfZmxvYXQgYmlubG9nIGJpdF9hbmQgYml0X2NvdW50IGJpdF9sZW5ndGggYml0X29yIGJpdF94b3IgYml0bWFwIGJsb2JfYmFzZSBibG9jayBibG9ja3NpemUgYm9keSBib3RoIGJvdW5kIGJ1ZmZlcl9jYWNoZSBidWZmZXJfcG9vbCBidWlsZCBidWxrIGJ5IGJ5dGUgYnl0ZW9yZGVybWFyayBieXRlcyBjIGNhY2hlIGNhY2hpbmcgY2FsbCBjYWxsaW5nIGNhbmNlbCBjYXBhY2l0eSBjYXNjYWRlIGNhc2NhZGVkIGNhc2UgY2FzdCBjYXRhbG9nIGNhdGVnb3J5IGNlaWwgY2VpbGluZyBjaGFpbiBjaGFuZ2UgY2hhbmdlZCBjaGFyX2Jhc2UgY2hhcl9sZW5ndGggY2hhcmFjdGVyX2xlbmd0aCBjaGFyYWN0ZXJzIGNoYXJhY3RlcnNldCBjaGFyaW5kZXggY2hhcnNldCBjaGFyc2V0Zm9ybSBjaGFyc2V0aWQgY2hlY2sgY2hlY2tzdW0gY2hlY2tzdW1fYWdnIGNoaWxkIGNob29zZSBjaHIgY2h1bmsgY2xhc3MgY2xlYW51cCBjbGVhciBjbGllbnQgY2xvYiBjbG9iX2Jhc2UgY2xvbmUgY2xvc2UgY2x1c3Rlcl9pZCBjbHVzdGVyX3Byb2JhYmlsaXR5IGNsdXN0ZXJfc2V0IGNsdXN0ZXJpbmcgY29hbGVzY2UgY29lcmNpYmlsaXR5IGNvbCBjb2xsYXRlIGNvbGxhdGlvbiBjb2xsZWN0IGNvbHUgY29sdW0gY29sdW1uIGNvbHVtbl92YWx1ZSBjb2x1bW5zIGNvbHVtbnNfdXBkYXRlZCBjb21tZW50IGNvbW1pdCBjb21wYWN0IGNvbXBhdGliaWxpdHkgY29tcGlsZWQgY29tcGxldGUgY29tcG9zaXRlX2xpbWl0IGNvbXBvdW5kIGNvbXByZXNzIGNvbXB1dGUgY29uY2F0IGNvbmNhdF93cyBjb25jdXJyZW50IGNvbmZpcm0gY29ubiBjb25uZWMgY29ubmVjdCBjb25uZWN0X2J5X2lzY3ljbGUgY29ubmVjdF9ieV9pc2xlYWYgY29ubmVjdF9ieV9yb290IGNvbm5lY3RfdGltZSBjb25uZWN0aW9uIGNvbnNpZGVyIGNvbnNpc3RlbnQgY29uc3RhbnQgY29uc3RyYWludCBjb25zdHJhaW50cyBjb25zdHJ1Y3RvciBjb250YWluZXIgY29udGVudCBjb250ZW50cyBjb250ZXh0IGNvbnRyaWJ1dG9ycyBjb250cm9sZmlsZSBjb252IGNvbnZlcnQgY29udmVydF90eiBjb3JyIGNvcnJfayBjb3JyX3MgY29ycmVzcG9uZGluZyBjb3JydXB0aW9uIGNvcyBjb3N0IGNvdW50IGNvdW50X2JpZyBjb3VudGVkIGNvdmFyX3BvcCBjb3Zhcl9zYW1wIGNwdV9wZXJfY2FsbCBjcHVfcGVyX3Nlc3Npb24gY3JjMzIgY3JlYXRlIGNyZWF0aW9uIGNyaXRpY2FsIGNyb3NzIGN1YmUgY3VtZV9kaXN0IGN1cmRhdGUgY3VycmVudCBjdXJyZW50X2RhdGUgY3VycmVudF90aW1lIGN1cnJlbnRfdGltZXN0YW1wIGN1cnJlbnRfdXNlciBjdXJzb3IgY3VydGltZSBjdXN0b21kYXR1bSBjeWNsZSBkIGRhdGEgZGF0YWJhc2UgZGF0YWJhc2VzIGRhdGFmaWxlIGRhdGFmaWxlcyBkYXRhbGVuZ3RoIGRhdGVfYWRkIGRhdGVfY2FjaGUgZGF0ZV9mb3JtYXQgZGF0ZV9zdWIgZGF0ZWFkZCBkYXRlZGlmZiBkYXRlZnJvbXBhcnRzIGRhdGVuYW1lIGRhdGVwYXJ0IGRhdGV0aW1lMmZyb21wYXJ0cyBkYXkgZGF5X3RvX3NlY29uZCBkYXluYW1lIGRheW9mbW9udGggZGF5b2Z3ZWVrIGRheW9meWVhciBkYXlzIGRiX3JvbGVfY2hhbmdlIGRidGltZXpvbmUgZGRsIGRlYWxsb2NhdGUgZGVjbGFyZSBkZWNvZGUgZGVjb21wb3NlIGRlY3JlbWVudCBkZWNyeXB0IGRlZHVwbGljYXRlIGRlZiBkZWZhIGRlZmF1IGRlZmF1bCBkZWZhdWx0IGRlZmF1bHRzIGRlZmVycmVkIGRlZmkgZGVmaW4gZGVmaW5lIGRlZ3JlZXMgZGVsYXllZCBkZWxlZ2F0ZSBkZWxldGUgZGVsZXRlX2FsbCBkZWxpbWl0ZWQgZGVtYW5kIGRlbnNlX3JhbmsgZGVwdGggZGVxdWV1ZSBkZXNfZGVjcnlwdCBkZXNfZW5jcnlwdCBkZXNfa2V5X2ZpbGUgZGVzYyBkZXNjciBkZXNjcmkgZGVzY3JpYiBkZXNjcmliZSBkZXNjcmlwdG9yIGRldGVybWluaXN0aWMgZGlhZ25vc3RpY3MgZGlmZmVyZW5jZSBkaW1lbnNpb24gZGlyZWN0X2xvYWQgZGlyZWN0b3J5IGRpc2FibGUgZGlzYWJsZV9hbGwgZGlzYWxsb3cgZGlzYXNzb2NpYXRlIGRpc2NhcmRmaWxlIGRpc2Nvbm5lY3QgZGlza2dyb3VwIGRpc3RpbmN0IGRpc3RpbmN0cm93IGRpc3RyaWJ1dGUgZGlzdHJpYnV0ZWQgZGl2IGRvIGRvY3VtZW50IGRvbWFpbiBkb3RuZXQgZG91YmxlIGRvd25ncmFkZSBkcm9wIGR1bXBmaWxlIGR1cGxpY2F0ZSBkdXJhdGlvbiBlIGVhY2ggZWRpdGlvbiBlZGl0aW9uYWJsZSBlZGl0aW9ucyBlbGVtZW50IGVsbGlwc2lzIGVsc2UgZWxzaWYgZWx0IGVtcHR5IGVuYWJsZSBlbmFibGVfYWxsIGVuY2xvc2VkIGVuY29kZSBlbmNvZGluZyBlbmNyeXB0IGVuZCBlbmQtZXhlYyBlbmRpYW4gZW5mb3JjZWQgZW5naW5lIGVuZ2luZXMgZW5xdWV1ZSBlbnRlcnByaXNlIGVudGl0eWVzY2FwaW5nIGVvbW9udGggZXJyb3IgZXJyb3JzIGVzY2FwZWQgZXZhbG5hbWUgZXZhbHVhdGUgZXZlbnQgZXZlbnRkYXRhIGV2ZW50cyBleGNlcHQgZXhjZXB0aW9uIGV4Y2VwdGlvbnMgZXhjaGFuZ2UgZXhjbHVkZSBleGNsdWRpbmcgZXhlY3UgZXhlY3V0IGV4ZWN1dGUgZXhlbXB0IGV4aXN0cyBleGl0IGV4cCBleHBpcmUgZXhwbGFpbiBleHBvcnQgZXhwb3J0X3NldCBleHRlbmRlZCBleHRlbnQgZXh0ZXJuYWwgZXh0ZXJuYWxfMSBleHRlcm5hbF8yIGV4dGVybmFsbHkgZXh0cmFjdCBmIGZhaWxlZCBmYWlsZWRfbG9naW5fYXR0ZW1wdHMgZmFpbG92ZXIgZmFpbHVyZSBmYXIgZmFzdCBmZWF0dXJlX3NldCBmZWF0dXJlX3ZhbHVlIGZldGNoIGZpZWxkIGZpZWxkcyBmaWxlIGZpbGVfbmFtZV9jb252ZXJ0IGZpbGVzeXN0ZW1fbGlrZV9sb2dnaW5nIGZpbmFsIGZpbmlzaCBmaXJzdCBmaXJzdF92YWx1ZSBmaXhlZCBmbGFzaF9jYWNoZSBmbGFzaGJhY2sgZmxvb3IgZmx1c2ggZm9sbG93aW5nIGZvbGxvd3MgZm9yIGZvcmFsbCBmb3JjZSBmb3JtIGZvcm1hIGZvcm1hdCBmb3VuZCBmb3VuZF9yb3dzIGZyZWVsaXN0IGZyZWVsaXN0cyBmcmVlcG9vbHMgZnJlc2ggZnJvbSBmcm9tX2Jhc2U2NCBmcm9tX2RheXMgZnRwIGZ1bGwgZnVuY3Rpb24gZyBnZW5lcmFsIGdlbmVyYXRlZCBnZXQgZ2V0X2Zvcm1hdCBnZXRfbG9jayBnZXRkYXRlIGdldHV0Y2RhdGUgZ2xvYmFsIGdsb2JhbF9uYW1lIGdsb2JhbGx5IGdvIGdvdG8gZ3JhbnQgZ3JhbnRzIGdyZWF0ZXN0IGdyb3VwIGdyb3VwX2NvbmNhdCBncm91cF9pZCBncm91cGluZyBncm91cGluZ19pZCBncm91cHMgZ3RpZF9zdWJ0cmFjdCBndWFyYW50ZWUgZ3VhcmQgaGFuZGxlciBoYXNoIGhhc2hrZXlzIGhhdmluZyBoZWEgaGVhZCBoZWFkaSBoZWFkaW4gaGVhZGluZyBoZWFwIGhlbHAgaGV4IGhpZXJhcmNoeSBoaWdoIGhpZ2hfcHJpb3JpdHkgaG9zdHMgaG91ciBodHRwIGkgaWQgaWRlbnRfY3VycmVudCBpZGVudF9pbmNyIGlkZW50X3NlZWQgaWRlbnRpZmllZCBpZGVudGl0eSBpZGxlX3RpbWUgaWYgaWZudWxsIGlnbm9yZSBpaWYgaWxpa2UgaWxtIGltbWVkaWF0ZSBpbXBvcnQgaW4gaW5jbHVkZSBpbmNsdWRpbmcgaW5jcmVtZW50IGluZGV4IGluZGV4ZXMgaW5kZXhpbmcgaW5kZXh0eXBlIGluZGljYXRvciBpbmRpY2VzIGluZXQ2X2F0b24gaW5ldDZfbnRvYSBpbmV0X2F0b24gaW5ldF9udG9hIGluZmlsZSBpbml0aWFsIGluaXRpYWxpemVkIGluaXRpYWxseSBpbml0cmFucyBpbm1lbW9yeSBpbm5lciBpbm5vZGIgaW5wdXQgaW5zZXJ0IGluc3RhbGwgaW5zdGFuY2UgaW5zdGFudGlhYmxlIGluc3RyIGludGVyZmFjZSBpbnRlcmxlYXZlZCBpbnRlcnNlY3QgaW50byBpbnZhbGlkYXRlIGludmlzaWJsZSBpcyBpc19mcmVlX2xvY2sgaXNfaXB2NCBpc19pcHY0X2NvbXBhdCBpc19ub3QgaXNfbm90X251bGwgaXNfdXNlZF9sb2NrIGlzZGF0ZSBpc251bGwgaXNvbGF0aW9uIGl0ZXJhdGUgamF2YSBqb2luIGpzb24ganNvbl9leGlzdHMgayBrZWVwIGtlZXBfZHVwbGljYXRlcyBrZXkga2V5cyBraWxsIGwgbGFuZ3VhZ2UgbGFyZ2UgbGFzdCBsYXN0X2RheSBsYXN0X2luc2VydF9pZCBsYXN0X3ZhbHVlIGxheCBsY2FzZSBsZWFkIGxlYWRpbmcgbGVhc3QgbGVhdmVzIGxlZnQgbGVuIGxlbmdodCBsZW5ndGggbGVzcyBsZXZlbCBsZXZlbHMgbGlicmFyeSBsaWtlIGxpa2UyIGxpa2U0IGxpa2VjIGxpbWl0IGxpbmVzIGxpbmsgbGlzdCBsaXN0YWdnIGxpdHRsZSBsbiBsb2FkIGxvYWRfZmlsZSBsb2IgbG9icyBsb2NhbCBsb2NhbHRpbWUgbG9jYWx0aW1lc3RhbXAgbG9jYXRlIGxvY2F0b3IgbG9jayBsb2NrZWQgbG9nIGxvZzEwIGxvZzIgbG9nZmlsZSBsb2dmaWxlcyBsb2dnaW5nIGxvZ2ljYWwgbG9naWNhbF9yZWFkc19wZXJfY2FsbCBsb2dvZmYgbG9nb24gbG9ncyBsb25nIGxvb3AgbG93IGxvd19wcmlvcml0eSBsb3dlciBscGFkIGxydHJpbSBsdHJpbSBtIG1haW4gbWFrZV9zZXQgbWFrZWRhdGUgbWFrZXRpbWUgbWFuYWdlZCBtYW5hZ2VtZW50IG1hbnVhbCBtYXAgbWFwcGluZyBtYXNrIG1hc3RlciBtYXN0ZXJfcG9zX3dhaXQgbWF0Y2ggbWF0Y2hlZCBtYXRlcmlhbGl6ZWQgbWF4IG1heGV4dGVudHMgbWF4aW1pemUgbWF4aW5zdGFuY2VzIG1heGxlbiBtYXhsb2dmaWxlcyBtYXhsb2doaXN0b3J5IG1heGxvZ21lbWJlcnMgbWF4c2l6ZSBtYXh0cmFucyBtZDUgbWVhc3VyZXMgbWVkaWFuIG1lZGl1bSBtZW1iZXIgbWVtY29tcHJlc3MgbWVtb3J5IG1lcmdlIG1pY3Jvc2Vjb25kIG1pZCBtaWdyYXRpb24gbWluIG1pbmV4dGVudHMgbWluaW11bSBtaW5pbmcgbWludXMgbWludXRlIG1pbnZhbHVlIG1pc3NpbmcgbW9kIG1vZGUgbW9kZWwgbW9kaWZpY2F0aW9uIG1vZGlmeSBtb2R1bGUgbW9uaXRvcmluZyBtb250aCBtb250aHMgbW91bnQgbW92ZSBtb3ZlbWVudCBtdWx0aXNldCBtdXRleCBuIG5hbWUgbmFtZV9jb25zdCBuYW1lcyBuYW4gbmF0aW9uYWwgbmF0aXZlIG5hdHVyYWwgbmF2IG5jaGFyIG5jbG9iIG5lc3RlZCBuZXZlciBuZXcgbmV3bGluZSBuZXh0IG5leHR2YWwgbm8gbm9fd3JpdGVfdG9fYmlubG9nIG5vYXJjaGl2ZWxvZyBub2F1ZGl0IG5vYmFkZmlsZSBub2NoZWNrIG5vY29tcHJlc3Mgbm9jb3B5IG5vY3ljbGUgbm9kZWxheSBub2Rpc2NhcmRmaWxlIG5vZW50aXR5ZXNjYXBpbmcgbm9ndWFyYW50ZWUgbm9rZWVwIG5vbG9nZmlsZSBub21hcHBpbmcgbm9tYXh2YWx1ZSBub21pbmltaXplIG5vbWludmFsdWUgbm9tb25pdG9yaW5nIG5vbmUgbm9uZWRpdGlvbmFibGUgbm9uc2NoZW1hIG5vb3JkZXIgbm9wciBub3BybyBub3Byb20gbm9wcm9tcCBub3Byb21wdCBub3JlbHkgbm9yZXNldGxvZ3Mgbm9yZXZlcnNlIG5vcm1hbCBub3Jvd2RlcGVuZGVuY2llcyBub3NjaGVtYWNoZWNrIG5vc3dpdGNoIG5vdCBub3RoaW5nIG5vdGljZSBub3RyaW0gbm92YWxpZGF0ZSBub3cgbm93YWl0IG50aF92YWx1ZSBudWxsaWYgbnVsbHMgbnVtIG51bWIgbnVtYmUgbnZhcmNoYXIgbnZhcmNoYXIyIG9iamVjdCBvY2ljb2xsIG9jaWRhdGUgb2NpZGF0ZXRpbWUgb2NpZHVyYXRpb24gb2NpaW50ZXJ2YWwgb2NpbG9ibG9jYXRvciBvY2ludW1iZXIgb2NpcmVmIG9jaXJlZmN1cnNvciBvY2lyb3dpZCBvY2lzdHJpbmcgb2NpdHlwZSBvY3Qgb2N0ZXRfbGVuZ3RoIG9mIG9mZiBvZmZsaW5lIG9mZnNldCBvaWQgb2lkaW5kZXggb2xkIG9uIG9ubGluZSBvbmx5IG9wYXF1ZSBvcGVuIG9wZXJhdGlvbnMgb3BlcmF0b3Igb3B0aW1hbCBvcHRpbWl6ZSBvcHRpb24gb3B0aW9uYWxseSBvciBvcmFjbGUgb3JhY2xlX2RhdGUgb3JhZGF0YSBvcmQgb3JkYXVkaW8gb3JkZGljb20gb3JkZG9jIG9yZGVyIG9yZGltYWdlIG9yZGluYWxpdHkgb3JkdmlkZW8gb3JnYW5pemF0aW9uIG9ybGFueSBvcmx2YXJ5IG91dCBvdXRlciBvdXRmaWxlIG91dGxpbmUgb3V0cHV0IG92ZXIgb3ZlcmZsb3cgb3ZlcnJpZGluZyBwIHBhY2thZ2UgcGFkIHBhcmFsbGVsIHBhcmFsbGVsX2VuYWJsZSBwYXJhbWV0ZXJzIHBhcmVudCBwYXJzZSBwYXJ0aWFsIHBhcnRpdGlvbiBwYXJ0aXRpb25zIHBhc2NhbCBwYXNzaW5nIHBhc3N3b3JkIHBhc3N3b3JkX2dyYWNlX3RpbWUgcGFzc3dvcmRfbG9ja190aW1lIHBhc3N3b3JkX3JldXNlX21heCBwYXNzd29yZF9yZXVzZV90aW1lIHBhc3N3b3JkX3ZlcmlmeV9mdW5jdGlvbiBwYXRjaCBwYXRoIHBhdGluZGV4IHBjdGluY3JlYXNlIHBjdHRocmVzaG9sZCBwY3R1c2VkIHBjdHZlcnNpb24gcGVyY2VudCBwZXJjZW50X3JhbmsgcGVyY2VudGlsZV9jb250IHBlcmNlbnRpbGVfZGlzYyBwZXJmb3JtYW5jZSBwZXJpb2QgcGVyaW9kX2FkZCBwZXJpb2RfZGlmZiBwZXJtYW5lbnQgcGh5c2ljYWwgcGkgcGlwZSBwaXBlbGluZWQgcGl2b3QgcGx1Z2dhYmxlIHBsdWdpbiBwb2xpY3kgcG9zaXRpb24gcG9zdF90cmFuc2FjdGlvbiBwb3cgcG93ZXIgcHJhZ21hIHByZWJ1aWx0IHByZWNlZGVzIHByZWNlZGluZyBwcmVjaXNpb24gcHJlZGljdGlvbiBwcmVkaWN0aW9uX2Nvc3QgcHJlZGljdGlvbl9kZXRhaWxzIHByZWRpY3Rpb25fcHJvYmFiaWxpdHkgcHJlZGljdGlvbl9zZXQgcHJlcGFyZSBwcmVzZW50IHByZXNlcnZlIHByaW9yIHByaW9yaXR5IHByaXZhdGUgcHJpdmF0ZV9zZ2EgcHJpdmlsZWdlcyBwcm9jZWR1cmFsIHByb2NlZHVyZSBwcm9jZWR1cmVfYW5hbHl6ZSBwcm9jZXNzbGlzdCBwcm9maWxlcyBwcm9qZWN0IHByb21wdCBwcm90ZWN0aW9uIHB1YmxpYyBwdWJsaXNoaW5nc2VydmVybmFtZSBwdXJnZSBxdWFydGVyIHF1ZXJ5IHF1aWNrIHF1aWVzY2UgcXVvdGEgcXVvdGVuYW1lIHJhZGlhbnMgcmFpc2UgcmFuZCByYW5nZSByYW5rIHJhdyByZWFkIHJlYWRzIHJlYWRzaXplIHJlYnVpbGQgcmVjb3JkIHJlY29yZHMgcmVjb3ZlciByZWNvdmVyeSByZWN1cnNpdmUgcmVjeWNsZSByZWRvIHJlZHVjZWQgcmVmIHJlZmVyZW5jZSByZWZlcmVuY2VkIHJlZmVyZW5jZXMgcmVmZXJlbmNpbmcgcmVmcmVzaCByZWdleHBfbGlrZSByZWdpc3RlciByZWdyX2F2Z3ggcmVncl9hdmd5IHJlZ3JfY291bnQgcmVncl9pbnRlcmNlcHQgcmVncl9yMiByZWdyX3Nsb3BlIHJlZ3Jfc3h4IHJlZ3Jfc3h5IHJlamVjdCByZWtleSByZWxhdGlvbmFsIHJlbGF0aXZlIHJlbGF5bG9nIHJlbGVhc2UgcmVsZWFzZV9sb2NrIHJlbGllc19vbiByZWxvY2F0ZSByZWx5IHJlbSByZW1haW5kZXIgcmVuYW1lIHJlcGFpciByZXBlYXQgcmVwbGFjZSByZXBsaWNhdGUgcmVwbGljYXRpb24gcmVxdWlyZWQgcmVzZXQgcmVzZXRsb2dzIHJlc2l6ZSByZXNvdXJjZSByZXNwZWN0IHJlc3RvcmUgcmVzdHJpY3RlZCByZXN1bHQgcmVzdWx0X2NhY2hlIHJlc3VtYWJsZSByZXN1bWUgcmV0ZW50aW9uIHJldHVybiByZXR1cm5pbmcgcmV0dXJucyByZXVzZSByZXZlcnNlIHJldm9rZSByaWdodCBybGlrZSByb2xlIHJvbGVzIHJvbGxiYWNrIHJvbGxpbmcgcm9sbHVwIHJvdW5kIHJvdyByb3dfY291bnQgcm93ZGVwZW5kZW5jaWVzIHJvd2lkIHJvd251bSByb3dzIHJ0cmltIHJ1bGVzIHNhZmUgc2FsdCBzYW1wbGUgc2F2ZSBzYXZlcG9pbnQgc2IxIHNiMiBzYjQgc2NhbiBzY2hlbWEgc2NoZW1hY2hlY2sgc2NuIHNjb3BlIHNjcm9sbCBzZG9fZ2VvcmFzdGVyIHNkb190b3BvX2dlb21ldHJ5IHNlYXJjaCBzZWNfdG9fdGltZSBzZWNvbmQgc2VjdGlvbiBzZWN1cmVmaWxlIHNlY3VyaXR5IHNlZWQgc2VnbWVudCBzZWxlY3Qgc2VsZiBzZXF1ZW5jZSBzZXF1ZW50aWFsIHNlcmlhbGl6YWJsZSBzZXJ2ZXIgc2VydmVyZXJyb3Igc2Vzc2lvbiBzZXNzaW9uX3VzZXIgc2Vzc2lvbnNfcGVyX3VzZXIgc2V0IHNldHMgc2V0dGluZ3Mgc2hhIHNoYTEgc2hhMiBzaGFyZSBzaGFyZWQgc2hhcmVkX3Bvb2wgc2hvcnQgc2hvdyBzaHJpbmsgc2h1dGRvd24gc2lfYXZlcmFnZWNvbG9yIHNpX2NvbG9yaGlzdG9ncmFtIHNpX2ZlYXR1cmVsaXN0IHNpX3Bvc2l0aW9uYWxjb2xvciBzaV9zdGlsbGltYWdlIHNpX3RleHR1cmUgc2libGluZ3Mgc2lkIHNpZ24gc2luIHNpemUgc2l6ZV90IHNpemVzIHNraXAgc2xhdmUgc2xlZXAgc21hbGxkYXRldGltZWZyb21wYXJ0cyBzbWFsbGZpbGUgc25hcHNob3Qgc29tZSBzb25hbWUgc29ydCBzb3VuZGV4IHNvdXJjZSBzcGFjZSBzcGFyc2Ugc3BmaWxlIHNwbGl0IHNxbCBzcWxfYmlnX3Jlc3VsdCBzcWxfYnVmZmVyX3Jlc3VsdCBzcWxfY2FjaGUgc3FsX2NhbGNfZm91bmRfcm93cyBzcWxfc21hbGxfcmVzdWx0IHNxbF92YXJpYW50X3Byb3BlcnR5IHNxbGNvZGUgc3FsZGF0YSBzcWxlcnJvciBzcWxuYW1lIHNxbHN0YXRlIHNxcnQgc3F1YXJlIHN0YW5kYWxvbmUgc3RhbmRieSBzdGFydCBzdGFydGluZyBzdGFydHVwIHN0YXRlbWVudCBzdGF0aWMgc3RhdGlzdGljcyBzdGF0c19iaW5vbWlhbF90ZXN0IHN0YXRzX2Nyb3NzdGFiIHN0YXRzX2tzX3Rlc3Qgc3RhdHNfbW9kZSBzdGF0c19td190ZXN0IHN0YXRzX29uZV93YXlfYW5vdmEgc3RhdHNfdF90ZXN0XyBzdGF0c190X3Rlc3RfaW5kZXAgc3RhdHNfdF90ZXN0X29uZSBzdGF0c190X3Rlc3RfcGFpcmVkIHN0YXRzX3dzcl90ZXN0IHN0YXR1cyBzdGQgc3RkZGV2IHN0ZGRldl9wb3Agc3RkZGV2X3NhbXAgc3RkZXYgc3RvcCBzdG9yYWdlIHN0b3JlIHN0b3JlZCBzdHIgc3RyX3RvX2RhdGUgc3RyYWlnaHRfam9pbiBzdHJjbXAgc3RyaWN0IHN0cmluZyBzdHJ1Y3Qgc3R1ZmYgc3R5bGUgc3ViZGF0ZSBzdWJwYXJ0aXRpb24gc3VicGFydGl0aW9ucyBzdWJzdGl0dXRhYmxlIHN1YnN0ciBzdWJzdHJpbmcgc3VidGltZSBzdWJ0cmluZ19pbmRleCBzdWJ0eXBlIHN1Y2Nlc3Mgc3VtIHN1c3BlbmQgc3dpdGNoIHN3aXRjaG9mZnNldCBzd2l0Y2hvdmVyIHN5bmMgc3luY2hyb25vdXMgc3lub255bSBzeXMgc3lzX3htbGFnZyBzeXNhc20gc3lzYXV4IHN5c2RhdGUgc3lzZGF0ZXRpbWVvZmZzZXQgc3lzZGJhIHN5c29wZXIgc3lzdGVtIHN5c3RlbV91c2VyIHN5c3V0Y2RhdGV0aW1lIHQgdGFibGUgdGFibGVzIHRhYmxlc3BhY2UgdGFuIHRkbyB0ZW1wbGF0ZSB0ZW1wb3JhcnkgdGVybWluYXRlZCB0ZXJ0aWFyeV93ZWlnaHRzIHRlc3QgdGhhbiB0aGVuIHRocmVhZCB0aHJvdWdoIHRpZXIgdGllcyB0aW1lIHRpbWVfZm9ybWF0IHRpbWVfem9uZSB0aW1lZGlmZiB0aW1lZnJvbXBhcnRzIHRpbWVvdXQgdGltZXN0YW1wIHRpbWVzdGFtcGFkZCB0aW1lc3RhbXBkaWZmIHRpbWV6b25lX2FiYnIgdGltZXpvbmVfbWludXRlIHRpbWV6b25lX3JlZ2lvbiB0byB0b19iYXNlNjQgdG9fZGF0ZSB0b19kYXlzIHRvX3NlY29uZHMgdG9kYXRldGltZW9mZnNldCB0cmFjZSB0cmFja2luZyB0cmFuc2FjdGlvbiB0cmFuc2FjdGlvbmFsIHRyYW5zbGF0ZSB0cmFuc2xhdGlvbiB0cmVhdCB0cmlnZ2VyIHRyaWdnZXJfbmVzdGxldmVsIHRyaWdnZXJzIHRyaW0gdHJ1bmNhdGUgdHJ5X2Nhc3QgdHJ5X2NvbnZlcnQgdHJ5X3BhcnNlIHR5cGUgdWIxIHViMiB1YjQgdWNhc2UgdW5hcmNoaXZlZCB1bmJvdW5kZWQgdW5jb21wcmVzcyB1bmRlciB1bmRvIHVuaGV4IHVuaWNvZGUgdW5pZm9ybSB1bmluc3RhbGwgdW5pb24gdW5pcXVlIHVuaXhfdGltZXN0YW1wIHVua25vd24gdW5saW1pdGVkIHVubG9jayB1bnBpdm90IHVucmVjb3ZlcmFibGUgdW5zYWZlIHVuc2lnbmVkIHVudGlsIHVudHJ1c3RlZCB1bnVzYWJsZSB1bnVzZWQgdXBkYXRlIHVwZGF0ZWQgdXBncmFkZSB1cHBlZCB1cHBlciB1cHNlcnQgdXJsIHVyb3dpZCB1c2FibGUgdXNhZ2UgdXNlIHVzZV9zdG9yZWRfb3V0bGluZXMgdXNlciB1c2VyX2RhdGEgdXNlcl9yZXNvdXJjZXMgdXNlcnMgdXNpbmcgdXRjX2RhdGUgdXRjX3RpbWVzdGFtcCB1dWlkIHV1aWRfc2hvcnQgdmFsaWRhdGUgdmFsaWRhdGVfcGFzc3dvcmRfc3RyZW5ndGggdmFsaWRhdGlvbiB2YWxpc3QgdmFsdWUgdmFsdWVzIHZhciB2YXJfc2FtcCB2YXJjaGFyYyB2YXJpIHZhcmlhIHZhcmlhYiB2YXJpYWJsIHZhcmlhYmxlIHZhcmlhYmxlcyB2YXJpYW5jZSB2YXJwIHZhcnJhdyB2YXJyYXdjIHZhcnJheSB2ZXJpZnkgdmVyc2lvbiB2ZXJzaW9ucyB2aWV3IHZpcnR1YWwgdmlzaWJsZSB2b2lkIHdhaXQgd2FsbGV0IHdhcm5pbmcgd2FybmluZ3Mgd2VlayB3ZWVrZGF5IHdlZWtvZnllYXIgd2VsbGZvcm1lZCB3aGVuIHdoZW5lIHdoZW5ldiB3aGVuZXZlIHdoZW5ldmVyIHdoZXJlIHdoaWxlIHdoaXRlc3BhY2Ugd2l0aCB3aXRoaW4gd2l0aG91dCB3b3JrIHdyYXBwZWQgeGRiIHhtbCB4bWxhZ2cgeG1sYXR0cmlidXRlcyB4bWxjYXN0IHhtbGNvbGF0dHZhbCB4bWxlbGVtZW50IHhtbGV4aXN0cyB4bWxmb3Jlc3QgeG1saW5kZXggeG1sbmFtZXNwYWNlcyB4bWxwaSB4bWxxdWVyeSB4bWxyb290IHhtbHNjaGVtYSB4bWxzZXJpYWxpemUgeG1sdGFibGUgeG1sdHlwZSB4b3IgeWVhciB5ZWFyX3RvX21vbnRoIHllYXJzIHllYXJ3ZWVrIiwKbGl0ZXJhbDoidHJ1ZSBmYWxzZSBudWxsIixidWlsdF9pbjoiYXJyYXkgYmlnaW50IGJpbmFyeSBiaXQgYmxvYiBib29sZWFuIGNoYXIgY2hhcmFjdGVyIGRhdGUgZGVjIGRlY2ltYWwgZmxvYXQgaW50IGludDggaW50ZWdlciBpbnRlcnZhbCBudW1iZXIgbnVtZXJpYyByZWFsIHJlY29yZCBzZXJpYWwgc2VyaWFsOCBzbWFsbGludCB0ZXh0IHZhcmNoYXIgdmFyeWluZyB2b2lkIn0sYzpbe2NOOiJzdHJpbmciLGI6IiciLGU6IiciLGM6W2UuQkUse2I6IicnIn1dfSx7Y046InN0cmluZyIsYjonIicsZTonIicsYzpbZS5CRSx7YjonIiInfV19LHtjTjoic3RyaW5nIixiOiJgIixlOiJgIixjOltlLkJFXX0sZS5DTk0sZS5DQkNNLHRdfSxlLkNCQ00sdF19fSksZX0pOw=="></script>
<script src="data:application/x-javascript;base64,LyoqKgpUaGlzIGlzIHBhcnQgb2YganNkaWZmbGliIHYxLjAuIDxodHRwOi8vc25vd3RpZGUuY29tL2pzZGlmZmxpYj4KCkNvcHlyaWdodCAoYykgMjAwNywgU25vd3RpZGUgSW5mb3JtYXRpY3MgU3lzdGVtcywgSW5jLgpBbGwgcmlnaHRzIHJlc2VydmVkLgoKUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbiwKYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OgoKCSogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzCgkJbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuCgkqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwKCQl0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uCgkJYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uCgkqIE5laXRoZXIgdGhlIG5hbWUgb2YgdGhlIFNub3d0aWRlIEluZm9ybWF0aWNzIFN5c3RlbXMgbm9yIHRoZSBuYW1lcyBvZiBpdHMKCQljb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzCgkJc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uCgpUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTICJBUyBJUyIgQU5EIEFOWQpFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMKT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQKU0hBTEwgVEhFIENPUFlSSUdIVCBPV05FUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwKSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEClRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IKQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4KQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTgpBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSApEQU1BR0UuCioqKi8KLyogQXV0aG9yOiBDaGFzIEVtZXJpY2sgPGNlbWVyaWNrQHNub3d0aWRlLmNvbT4gKi8KdmFyIF9fd2hpdGVzcGFjZSA9IHsiICI6dHJ1ZSwgIlx0Ijp0cnVlLCAiXG4iOnRydWUsICJcZiI6dHJ1ZSwgIlxyIjp0cnVlfTsKCnZhciBkaWZmbGliID0gewoJZGVmYXVsdEp1bmtGdW5jdGlvbjogZnVuY3Rpb24gKGMpIHsKCQlyZXR1cm4gX193aGl0ZXNwYWNlLmhhc093blByb3BlcnR5KGMpOwoJfSwKCQoJc3RyaXBMaW5lYnJlYWtzOiBmdW5jdGlvbiAoc3RyKSB7IHJldHVybiBzdHIucmVwbGFjZSgvXltcblxyXSp8W1xuXHJdKiQvZywgIiIpOyB9LAoJCglzdHJpbmdBc0xpbmVzOiBmdW5jdGlvbiAoc3RyKSB7CgkJdmFyIGxmcG9zID0gc3RyLmluZGV4T2YoIlxuIik7CgkJdmFyIGNycG9zID0gc3RyLmluZGV4T2YoIlxyIik7CgkJdmFyIGxpbmVicmVhayA9ICgobGZwb3MgPiAtMSAmJiBjcnBvcyA+IC0xKSB8fCBjcnBvcyA8IDApID8gIlxuIiA6ICJcciI7CgkJCgkJdmFyIGxpbmVzID0gc3RyLnNwbGl0KGxpbmVicmVhayk7CgkJZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykgewoJCQlsaW5lc1tpXSA9IGRpZmZsaWIuc3RyaXBMaW5lYnJlYWtzKGxpbmVzW2ldKTsKCQl9CgkJCgkJcmV0dXJuIGxpbmVzOwoJfSwKCQoJLy8gaXRlcmF0aW9uLWJhc2VkIHJlZHVjZSBpbXBsZW1lbnRhdGlvbgoJX19yZWR1Y2U6IGZ1bmN0aW9uIChmdW5jLCBsaXN0LCBpbml0aWFsKSB7CgkJaWYgKGluaXRpYWwgIT0gbnVsbCkgewoJCQl2YXIgdmFsdWUgPSBpbml0aWFsOwoJCQl2YXIgaWR4ID0gMDsKCQl9IGVsc2UgaWYgKGxpc3QpIHsKCQkJdmFyIHZhbHVlID0gbGlzdFswXTsKCQkJdmFyIGlkeCA9IDE7CgkJfSBlbHNlIHsKCQkJcmV0dXJuIG51bGw7CgkJfQoJCQoJCWZvciAoOyBpZHggPCBsaXN0Lmxlbmd0aDsgaWR4KyspIHsKCQkJdmFsdWUgPSBmdW5jKHZhbHVlLCBsaXN0W2lkeF0pOwoJCX0KCQkKCQlyZXR1cm4gdmFsdWU7Cgl9LAoJCgkvLyBjb21wYXJpc29uIGZ1bmN0aW9uIGZvciBzb3J0aW5nIGxpc3RzIG9mIG51bWVyaWMgdHVwbGVzCglfX250dXBsZWNvbXA6IGZ1bmN0aW9uIChhLCBiKSB7CgkJdmFyIG1sZW4gPSBNYXRoLm1heChhLmxlbmd0aCwgYi5sZW5ndGgpOwoJCWZvciAodmFyIGkgPSAwOyBpIDwgbWxlbjsgaSsrKSB7CgkJCWlmIChhW2ldIDwgYltpXSkgcmV0dXJuIC0xOwoJCQlpZiAoYVtpXSA+IGJbaV0pIHJldHVybiAxOwoJCX0KCQkKCQlyZXR1cm4gYS5sZW5ndGggPT0gYi5sZW5ndGggPyAwIDogKGEubGVuZ3RoIDwgYi5sZW5ndGggPyAtMSA6IDEpOwoJfSwKCQoJX19jYWxjdWxhdGVfcmF0aW86IGZ1bmN0aW9uIChtYXRjaGVzLCBsZW5ndGgpIHsKCQlyZXR1cm4gbGVuZ3RoID8gMi4wICogbWF0Y2hlcyAvIGxlbmd0aCA6IDEuMDsKCX0sCgkKCS8vIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdHJ1ZSBpZiBhIGtleSBwYXNzZWQgdG8gdGhlIHJldHVybmVkIGZ1bmN0aW9uCgkvLyBpcyBpbiB0aGUgZGljdCAoanMgb2JqZWN0KSBwcm92aWRlZCB0byB0aGlzIGZ1bmN0aW9uOyByZXBsYWNlcyBiZWluZyBhYmxlIHRvCgkvLyBjYXJyeSBhcm91bmQgZGljdC5oYXNfa2V5IGluIHB5dGhvbi4uLgoJX19pc2luZGljdDogZnVuY3Rpb24gKGRpY3QpIHsKCQlyZXR1cm4gZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gZGljdC5oYXNPd25Qcm9wZXJ0eShrZXkpOyB9OwoJfSwKCQoJLy8gcmVwbGFjZW1lbnQgZm9yIHB5dGhvbidzIGRpY3QuZ2V0IGZ1bmN0aW9uIC0tIG5lZWQgZWFzeSBkZWZhdWx0IHZhbHVlcwoJX19kaWN0Z2V0OiBmdW5jdGlvbiAoZGljdCwga2V5LCBkZWZhdWx0VmFsdWUpIHsKCQlyZXR1cm4gZGljdC5oYXNPd25Qcm9wZXJ0eShrZXkpID8gZGljdFtrZXldIDogZGVmYXVsdFZhbHVlOwoJfSwJCgkKCVNlcXVlbmNlTWF0Y2hlcjogZnVuY3Rpb24gKGEsIGIsIGlzanVuaykgewoJCXRoaXMuc2V0X3NlcXMgPSBmdW5jdGlvbiAoYSwgYikgewoJCQl0aGlzLnNldF9zZXExKGEpOwoJCQl0aGlzLnNldF9zZXEyKGIpOwoJCX0KCQkKCQl0aGlzLnNldF9zZXExID0gZnVuY3Rpb24gKGEpIHsKCQkJaWYgKGEgPT0gdGhpcy5hKSByZXR1cm47CgkJCXRoaXMuYSA9IGE7CgkJCXRoaXMubWF0Y2hpbmdfYmxvY2tzID0gdGhpcy5vcGNvZGVzID0gbnVsbDsKCQl9CgkJCgkJdGhpcy5zZXRfc2VxMiA9IGZ1bmN0aW9uIChiKSB7CgkJCWlmIChiID09IHRoaXMuYikgcmV0dXJuOwoJCQl0aGlzLmIgPSBiOwoJCQl0aGlzLm1hdGNoaW5nX2Jsb2NrcyA9IHRoaXMub3Bjb2RlcyA9IHRoaXMuZnVsbGJjb3VudCA9IG51bGw7CgkJCXRoaXMuX19jaGFpbl9iKCk7CgkJfQoJCQoJCXRoaXMuX19jaGFpbl9iID0gZnVuY3Rpb24gKCkgewoJCQl2YXIgYiA9IHRoaXMuYjsKCQkJdmFyIG4gPSBiLmxlbmd0aDsKCQkJdmFyIGIyaiA9IHRoaXMuYjJqID0ge307CgkJCXZhciBwb3B1bGFyZGljdCA9IHt9OwoJCQlmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHsKCQkJCXZhciBlbHQgPSBiW2ldOwoJCQkJaWYgKGIyai5oYXNPd25Qcm9wZXJ0eShlbHQpKSB7CgkJCQkJdmFyIGluZGljZXMgPSBiMmpbZWx0XTsKCQkJCQlpZiAobiA+PSAyMDAgJiYgaW5kaWNlcy5sZW5ndGggKiAxMDAgPiBuKSB7CgkJCQkJCXBvcHVsYXJkaWN0W2VsdF0gPSAxOwoJCQkJCQlkZWxldGUgYjJqW2VsdF07CgkJCQkJfSBlbHNlIHsKCQkJCQkJaW5kaWNlcy5wdXNoKGkpOwoJCQkJCX0KCQkJCX0gZWxzZSB7CgkJCQkJYjJqW2VsdF0gPSBbaV07CgkJCQl9CgkJCX0KCQoJCQlmb3IgKHZhciBlbHQgaW4gcG9wdWxhcmRpY3QpIHsKCQkJCWlmIChwb3B1bGFyZGljdC5oYXNPd25Qcm9wZXJ0eShlbHQpKSB7CgkJCQkJZGVsZXRlIGIyaltlbHRdOwoJCQkJfQoJCQl9CgkJCQoJCQl2YXIgaXNqdW5rID0gdGhpcy5pc2p1bms7CgkJCXZhciBqdW5rZGljdCA9IHt9OwoJCQlpZiAoaXNqdW5rKSB7CgkJCQlmb3IgKHZhciBlbHQgaW4gcG9wdWxhcmRpY3QpIHsKCQkJCQlpZiAocG9wdWxhcmRpY3QuaGFzT3duUHJvcGVydHkoZWx0KSAmJiBpc2p1bmsoZWx0KSkgewoJCQkJCQlqdW5rZGljdFtlbHRdID0gMTsKCQkJCQkJZGVsZXRlIHBvcHVsYXJkaWN0W2VsdF07CgkJCQkJfQoJCQkJfQoJCQkJZm9yICh2YXIgZWx0IGluIGIyaikgewoJCQkJCWlmIChiMmouaGFzT3duUHJvcGVydHkoZWx0KSAmJiBpc2p1bmsoZWx0KSkgewoJCQkJCQlqdW5rZGljdFtlbHRdID0gMTsKCQkJCQkJZGVsZXRlIGIyaltlbHRdOwoJCQkJCX0KCQkJCX0KCQkJfQoJCgkJCXRoaXMuaXNianVuayA9IGRpZmZsaWIuX19pc2luZGljdChqdW5rZGljdCk7CgkJCXRoaXMuaXNicG9wdWxhciA9IGRpZmZsaWIuX19pc2luZGljdChwb3B1bGFyZGljdCk7CgkJfQoJCQoJCXRoaXMuZmluZF9sb25nZXN0X21hdGNoID0gZnVuY3Rpb24gKGFsbywgYWhpLCBibG8sIGJoaSkgewoJCQl2YXIgYSA9IHRoaXMuYTsKCQkJdmFyIGIgPSB0aGlzLmI7CgkJCXZhciBiMmogPSB0aGlzLmIyajsKCQkJdmFyIGlzYmp1bmsgPSB0aGlzLmlzYmp1bms7CgkJCXZhciBiZXN0aSA9IGFsbzsKCQkJdmFyIGJlc3RqID0gYmxvOwoJCQl2YXIgYmVzdHNpemUgPSAwOwoJCQl2YXIgaiA9IG51bGw7CgkJCXZhciBrOwoJCgkJCXZhciBqMmxlbiA9IHt9OwoJCQl2YXIgbm90aGluZyA9IFtdOwoJCQlmb3IgKHZhciBpID0gYWxvOyBpIDwgYWhpOyBpKyspIHsKCQkJCXZhciBuZXdqMmxlbiA9IHt9OwoJCQkJdmFyIGpkaWN0ID0gZGlmZmxpYi5fX2RpY3RnZXQoYjJqLCBhW2ldLCBub3RoaW5nKTsKCQkJCWZvciAodmFyIGprZXkgaW4gamRpY3QpIHsKCQkJCQlpZiAoamRpY3QuaGFzT3duUHJvcGVydHkoamtleSkpIHsKCQkJCQkJaiA9IGpkaWN0W2prZXldOwoJCQkJCQlpZiAoaiA8IGJsbykgY29udGludWU7CgkJCQkJCWlmIChqID49IGJoaSkgYnJlYWs7CgkJCQkJCW5ld2oybGVuW2pdID0gayA9IGRpZmZsaWIuX19kaWN0Z2V0KGoybGVuLCBqIC0gMSwgMCkgKyAxOwoJCQkJCQlpZiAoayA+IGJlc3RzaXplKSB7CgkJCQkJCQliZXN0aSA9IGkgLSBrICsgMTsKCQkJCQkJCWJlc3RqID0gaiAtIGsgKyAxOwoJCQkJCQkJYmVzdHNpemUgPSBrOwoJCQkJCQl9CgkJCQkJfQoJCQkJfQoJCQkJajJsZW4gPSBuZXdqMmxlbjsKCQkJfQoJCgkJCXdoaWxlIChiZXN0aSA+IGFsbyAmJiBiZXN0aiA+IGJsbyAmJiAhaXNianVuayhiW2Jlc3RqIC0gMV0pICYmIGFbYmVzdGkgLSAxXSA9PSBiW2Jlc3RqIC0gMV0pIHsKCQkJCWJlc3RpLS07CgkJCQliZXN0ai0tOwoJCQkJYmVzdHNpemUrKzsKCQkJfQoJCQkJCgkJCXdoaWxlIChiZXN0aSArIGJlc3RzaXplIDwgYWhpICYmIGJlc3RqICsgYmVzdHNpemUgPCBiaGkgJiYKCQkJCQkhaXNianVuayhiW2Jlc3RqICsgYmVzdHNpemVdKSAmJgoJCQkJCWFbYmVzdGkgKyBiZXN0c2l6ZV0gPT0gYltiZXN0aiArIGJlc3RzaXplXSkgewoJCQkJYmVzdHNpemUrKzsKCQkJfQoJCgkJCXdoaWxlIChiZXN0aSA+IGFsbyAmJiBiZXN0aiA+IGJsbyAmJiBpc2JqdW5rKGJbYmVzdGogLSAxXSkgJiYgYVtiZXN0aSAtIDFdID09IGJbYmVzdGogLSAxXSkgewoJCQkJYmVzdGktLTsKCQkJCWJlc3RqLS07CgkJCQliZXN0c2l6ZSsrOwoJCQl9CgkJCQoJCQl3aGlsZSAoYmVzdGkgKyBiZXN0c2l6ZSA8IGFoaSAmJiBiZXN0aiArIGJlc3RzaXplIDwgYmhpICYmIGlzYmp1bmsoYltiZXN0aiArIGJlc3RzaXplXSkgJiYKCQkJCQlhW2Jlc3RpICsgYmVzdHNpemVdID09IGJbYmVzdGogKyBiZXN0c2l6ZV0pIHsKCQkJCWJlc3RzaXplKys7CgkJCX0KCQoJCQlyZXR1cm4gW2Jlc3RpLCBiZXN0aiwgYmVzdHNpemVdOwoJCX0KCQkKCQl0aGlzLmdldF9tYXRjaGluZ19ibG9ja3MgPSBmdW5jdGlvbiAoKSB7CgkJCWlmICh0aGlzLm1hdGNoaW5nX2Jsb2NrcyAhPSBudWxsKSByZXR1cm4gdGhpcy5tYXRjaGluZ19ibG9ja3M7CgkJCXZhciBsYSA9IHRoaXMuYS5sZW5ndGg7CgkJCXZhciBsYiA9IHRoaXMuYi5sZW5ndGg7CgkKCQkJdmFyIHF1ZXVlID0gW1swLCBsYSwgMCwgbGJdXTsKCQkJdmFyIG1hdGNoaW5nX2Jsb2NrcyA9IFtdOwoJCQl2YXIgYWxvLCBhaGksIGJsbywgYmhpLCBxaSwgaSwgaiwgaywgeDsKCQkJd2hpbGUgKHF1ZXVlLmxlbmd0aCkgewoJCQkJcWkgPSBxdWV1ZS5wb3AoKTsKCQkJCWFsbyA9IHFpWzBdOwoJCQkJYWhpID0gcWlbMV07CgkJCQlibG8gPSBxaVsyXTsKCQkJCWJoaSA9IHFpWzNdOwoJCQkJeCA9IHRoaXMuZmluZF9sb25nZXN0X21hdGNoKGFsbywgYWhpLCBibG8sIGJoaSk7CgkJCQlpID0geFswXTsKCQkJCWogPSB4WzFdOwoJCQkJayA9IHhbMl07CgkKCQkJCWlmIChrKSB7CgkJCQkJbWF0Y2hpbmdfYmxvY2tzLnB1c2goeCk7CgkJCQkJaWYgKGFsbyA8IGkgJiYgYmxvIDwgaikKCQkJCQkJcXVldWUucHVzaChbYWxvLCBpLCBibG8sIGpdKTsKCQkJCQlpZiAoaStrIDwgYWhpICYmIGorayA8IGJoaSkKCQkJCQkJcXVldWUucHVzaChbaSArIGssIGFoaSwgaiArIGssIGJoaV0pOwoJCQkJfQoJCQl9CgkJCQoJCQltYXRjaGluZ19ibG9ja3Muc29ydChkaWZmbGliLl9fbnR1cGxlY29tcCk7CgkKCQkJdmFyIGkxID0gMCwgajEgPSAwLCBrMSA9IDAsIGJsb2NrID0gMDsKCQkJdmFyIGkyLCBqMiwgazI7CgkJCXZhciBub25fYWRqYWNlbnQgPSBbXTsKCQkJZm9yICh2YXIgaWR4IGluIG1hdGNoaW5nX2Jsb2NrcykgewoJCQkJaWYgKG1hdGNoaW5nX2Jsb2Nrcy5oYXNPd25Qcm9wZXJ0eShpZHgpKSB7CgkJCQkJYmxvY2sgPSBtYXRjaGluZ19ibG9ja3NbaWR4XTsKCQkJCQlpMiA9IGJsb2NrWzBdOwoJCQkJCWoyID0gYmxvY2tbMV07CgkJCQkJazIgPSBibG9ja1syXTsKCQkJCQlpZiAoaTEgKyBrMSA9PSBpMiAmJiBqMSArIGsxID09IGoyKSB7CgkJCQkJCWsxICs9IGsyOwoJCQkJCX0gZWxzZSB7CgkJCQkJCWlmIChrMSkgbm9uX2FkamFjZW50LnB1c2goW2kxLCBqMSwgazFdKTsKCQkJCQkJaTEgPSBpMjsKCQkJCQkJajEgPSBqMjsKCQkJCQkJazEgPSBrMjsKCQkJCQl9CgkJCQl9CgkJCX0KCQkJCgkJCWlmIChrMSkgbm9uX2FkamFjZW50LnB1c2goW2kxLCBqMSwgazFdKTsKCQoJCQlub25fYWRqYWNlbnQucHVzaChbbGEsIGxiLCAwXSk7CgkJCXRoaXMubWF0Y2hpbmdfYmxvY2tzID0gbm9uX2FkamFjZW50OwoJCQlyZXR1cm4gdGhpcy5tYXRjaGluZ19ibG9ja3M7CgkJfQoJCQoJCXRoaXMuZ2V0X29wY29kZXMgPSBmdW5jdGlvbiAoKSB7CgkJCWlmICh0aGlzLm9wY29kZXMgIT0gbnVsbCkgcmV0dXJuIHRoaXMub3Bjb2RlczsKCQkJdmFyIGkgPSAwOwoJCQl2YXIgaiA9IDA7CgkJCXZhciBhbnN3ZXIgPSBbXTsKCQkJdGhpcy5vcGNvZGVzID0gYW5zd2VyOwoJCQl2YXIgYmxvY2ssIGFpLCBiaiwgc2l6ZSwgdGFnOwoJCQl2YXIgYmxvY2tzID0gdGhpcy5nZXRfbWF0Y2hpbmdfYmxvY2tzKCk7CgkJCWZvciAodmFyIGlkeCBpbiBibG9ja3MpIHsKCQkJCWlmIChibG9ja3MuaGFzT3duUHJvcGVydHkoaWR4KSkgewoJCQkJCWJsb2NrID0gYmxvY2tzW2lkeF07CgkJCQkJYWkgPSBibG9ja1swXTsKCQkJCQliaiA9IGJsb2NrWzFdOwoJCQkJCXNpemUgPSBibG9ja1syXTsKCQkJCQl0YWcgPSAnJzsKCQkJCQlpZiAoaSA8IGFpICYmIGogPCBiaikgewoJCQkJCQl0YWcgPSAncmVwbGFjZSc7CgkJCQkJfSBlbHNlIGlmIChpIDwgYWkpIHsKCQkJCQkJdGFnID0gJ2RlbGV0ZSc7CgkJCQkJfSBlbHNlIGlmIChqIDwgYmopIHsKCQkJCQkJdGFnID0gJ2luc2VydCc7CgkJCQkJfQoJCQkJCWlmICh0YWcpIGFuc3dlci5wdXNoKFt0YWcsIGksIGFpLCBqLCBial0pOwoJCQkJCWkgPSBhaSArIHNpemU7CgkJCQkJaiA9IGJqICsgc2l6ZTsKCQkJCQkKCQkJCQlpZiAoc2l6ZSkgYW5zd2VyLnB1c2goWydlcXVhbCcsIGFpLCBpLCBiaiwgal0pOwoJCQkJfQoJCQl9CgkJCQoJCQlyZXR1cm4gYW5zd2VyOwoJCX0KCQkKCQkvLyB0aGlzIGlzIGEgZ2VuZXJhdG9yIGZ1bmN0aW9uIGluIHRoZSBweXRob24gbGliLCB3aGljaCBvZiBjb3Vyc2UgaXMgbm90IHN1cHBvcnRlZCBpbiBqYXZhc2NyaXB0CgkJLy8gdGhlIHJlaW1wbGVtZW50YXRpb24gYnVpbGRzIHVwIHRoZSBncm91cGVkIG9wY29kZXMgaW50byBhIGxpc3QgaW4gdGhlaXIgZW50aXJldHkgYW5kIHJldHVybnMgdGhhdC4KCQl0aGlzLmdldF9ncm91cGVkX29wY29kZXMgPSBmdW5jdGlvbiAobikgewoJCQlpZiAoIW4pIG4gPSAzOwoJCQl2YXIgY29kZXMgPSB0aGlzLmdldF9vcGNvZGVzKCk7CgkJCWlmICghY29kZXMpIGNvZGVzID0gW1siZXF1YWwiLCAwLCAxLCAwLCAxXV07CgkJCXZhciBjb2RlLCB0YWcsIGkxLCBpMiwgajEsIGoyOwoJCQlpZiAoY29kZXNbMF1bMF0gPT0gJ2VxdWFsJykgewoJCQkJY29kZSA9IGNvZGVzWzBdOwoJCQkJdGFnID0gY29kZVswXTsKCQkJCWkxID0gY29kZVsxXTsKCQkJCWkyID0gY29kZVsyXTsKCQkJCWoxID0gY29kZVszXTsKCQkJCWoyID0gY29kZVs0XTsKCQkJCWNvZGVzWzBdID0gW3RhZywgTWF0aC5tYXgoaTEsIGkyIC0gbiksIGkyLCBNYXRoLm1heChqMSwgajIgLSBuKSwgajJdOwoJCQl9CgkJCWlmIChjb2Rlc1tjb2Rlcy5sZW5ndGggLSAxXVswXSA9PSAnZXF1YWwnKSB7CgkJCQljb2RlID0gY29kZXNbY29kZXMubGVuZ3RoIC0gMV07CgkJCQl0YWcgPSBjb2RlWzBdOwoJCQkJaTEgPSBjb2RlWzFdOwoJCQkJaTIgPSBjb2RlWzJdOwoJCQkJajEgPSBjb2RlWzNdOwoJCQkJajIgPSBjb2RlWzRdOwoJCQkJY29kZXNbY29kZXMubGVuZ3RoIC0gMV0gPSBbdGFnLCBpMSwgTWF0aC5taW4oaTIsIGkxICsgbiksIGoxLCBNYXRoLm1pbihqMiwgajEgKyBuKV07CgkJCX0KCQoJCQl2YXIgbm4gPSBuICsgbjsKCQkJdmFyIGdyb3VwID0gW107CgkJCXZhciBncm91cHMgPSBbXTsKCQkJZm9yICh2YXIgaWR4IGluIGNvZGVzKSB7CgkJCQlpZiAoY29kZXMuaGFzT3duUHJvcGVydHkoaWR4KSkgewoJCQkJCWNvZGUgPSBjb2Rlc1tpZHhdOwoJCQkJCXRhZyA9IGNvZGVbMF07CgkJCQkJaTEgPSBjb2RlWzFdOwoJCQkJCWkyID0gY29kZVsyXTsKCQkJCQlqMSA9IGNvZGVbM107CgkJCQkJajIgPSBjb2RlWzRdOwoJCQkJCWlmICh0YWcgPT0gJ2VxdWFsJyAmJiBpMiAtIGkxID4gbm4pIHsKCQkJCQkJZ3JvdXAucHVzaChbdGFnLCBpMSwgTWF0aC5taW4oaTIsIGkxICsgbiksIGoxLCBNYXRoLm1pbihqMiwgajEgKyBuKV0pOwoJCQkJCQlncm91cHMucHVzaChncm91cCk7CgkJCQkJCWdyb3VwID0gW107CgkJCQkJCWkxID0gTWF0aC5tYXgoaTEsIGkyLW4pOwoJCQkJCQlqMSA9IE1hdGgubWF4KGoxLCBqMi1uKTsKCQkJCQl9CgkJCQkJCgkJCQkJZ3JvdXAucHVzaChbdGFnLCBpMSwgaTIsIGoxLCBqMl0pOwoJCQkJfQoJCQl9CgkJCQoJCQlpZiAoZ3JvdXAgJiYgIShncm91cC5sZW5ndGggPT0gMSAmJiBncm91cFswXVswXSA9PSAnZXF1YWwnKSkgZ3JvdXBzLnB1c2goZ3JvdXApCgkJCQoJCQlyZXR1cm4gZ3JvdXBzOwoJCX0KCQkKCQl0aGlzLnJhdGlvID0gZnVuY3Rpb24gKCkgewoJCQltYXRjaGVzID0gZGlmZmxpYi5fX3JlZHVjZSgKCQkJCQkJCWZ1bmN0aW9uIChzdW0sIHRyaXBsZSkgeyByZXR1cm4gc3VtICsgdHJpcGxlW3RyaXBsZS5sZW5ndGggLSAxXTsgfSwKCQkJCQkJCXRoaXMuZ2V0X21hdGNoaW5nX2Jsb2NrcygpLCAwKTsKCQkJcmV0dXJuIGRpZmZsaWIuX19jYWxjdWxhdGVfcmF0aW8obWF0Y2hlcywgdGhpcy5hLmxlbmd0aCArIHRoaXMuYi5sZW5ndGgpOwoJCX0KCQkKCQl0aGlzLnF1aWNrX3JhdGlvID0gZnVuY3Rpb24gKCkgewoJCQl2YXIgZnVsbGJjb3VudCwgZWx0OwoJCQlpZiAodGhpcy5mdWxsYmNvdW50ID09IG51bGwpIHsKCQkJCXRoaXMuZnVsbGJjb3VudCA9IGZ1bGxiY291bnQgPSB7fTsKCQkJCWZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5iLmxlbmd0aDsgaSsrKSB7CgkJCQkJZWx0ID0gdGhpcy5iW2ldOwoJCQkJCWZ1bGxiY291bnRbZWx0XSA9IGRpZmZsaWIuX19kaWN0Z2V0KGZ1bGxiY291bnQsIGVsdCwgMCkgKyAxOwoJCQkJfQoJCQl9CgkJCWZ1bGxiY291bnQgPSB0aGlzLmZ1bGxiY291bnQ7CgkKCQkJdmFyIGF2YWlsID0ge307CgkJCXZhciBhdmFpbGhhcyA9IGRpZmZsaWIuX19pc2luZGljdChhdmFpbCk7CgkJCXZhciBtYXRjaGVzID0gbnVtYiA9IDA7CgkJCWZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hLmxlbmd0aDsgaSsrKSB7CgkJCQllbHQgPSB0aGlzLmFbaV07CgkJCQlpZiAoYXZhaWxoYXMoZWx0KSkgewoJCQkJCW51bWIgPSBhdmFpbFtlbHRdOwoJCQkJfSBlbHNlIHsKCQkJCQludW1iID0gZGlmZmxpYi5fX2RpY3RnZXQoZnVsbGJjb3VudCwgZWx0LCAwKTsKCQkJCX0KCQkJCWF2YWlsW2VsdF0gPSBudW1iIC0gMTsKCQkJCWlmIChudW1iID4gMCkgbWF0Y2hlcysrOwoJCQl9CgkJCQoJCQlyZXR1cm4gZGlmZmxpYi5fX2NhbGN1bGF0ZV9yYXRpbyhtYXRjaGVzLCB0aGlzLmEubGVuZ3RoICsgdGhpcy5iLmxlbmd0aCk7CgkJfQoJCQoJCXRoaXMucmVhbF9xdWlja19yYXRpbyA9IGZ1bmN0aW9uICgpIHsKCQkJdmFyIGxhID0gdGhpcy5hLmxlbmd0aDsKCQkJdmFyIGxiID0gdGhpcy5iLmxlbmd0aDsKCQkJcmV0dXJuIF9jYWxjdWxhdGVfcmF0aW8oTWF0aC5taW4obGEsIGxiKSwgbGEgKyBsYik7CgkJfQoJCQoJCXRoaXMuaXNqdW5rID0gaXNqdW5rID8gaXNqdW5rIDogZGlmZmxpYi5kZWZhdWx0SnVua0Z1bmN0aW9uOwoJCXRoaXMuYSA9IHRoaXMuYiA9IG51bGw7CgkJdGhpcy5zZXRfc2VxcyhhLCBiKTsKCX0KfTsKCg=="></script>
<link href="data:text/css;charset=utf-8,%2Ediff%20%7B%0Abox%2Dsizing%3A%20border%2Dbox%3B%0A%7D%0Adiv%2Ediff%20%7B%0Amax%2Dwidth%3A%20100%25%3B%0Adisplay%3A%20table%3B%0A%7D%0Atable%2Ediff%20%7B%0Awidth%3A%20100%25%3B%0Aborder%2Dspacing%3A%200%3B%0A%7D%0Atd%2Ecode%20%7B%0A%0A%0Awidth%3A%2061ch%3B%0Awhite%2Dspace%3A%20pre%2Dwrap%3B%0Aword%2Dwrap%3A%20break%2Dword%3B%0A%7D%0Atable%2Ediff%20td%20%7B%0Avertical%2Dalign%3A%20top%3B%0A%7D%0A%0A%2Eline%2Dno%20%7B%0Acolor%3A%20%23999%3B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0A%2Eline%2Dno%3Afirst%2Dchild%20%7B%0Abackground%2Dimage%3A%0Alinear%2Dgradient%28to%20left%2C%20%23f7f7f7%2C%20%23f7f7f7%203px%2C%20transparent%2C%20transparent%206px%2C%20%23f7f7f7%206px%29%2C%0Alinear%2Dgradient%28%23f7f7f7%2C%20%23f7f7f7%201%2E4em%2C%20%23aaa%201%2E4em%29%3B%0A%7D%0A%2Eline%2Dno%3Alast%2Dchild%20%7B%0Abackground%2Dimage%3A%0Alinear%2Dgradient%28to%20right%2C%20%23f7f7f7%2C%20%23f7f7f7%203px%2C%20transparent%2C%20transparent%206px%2C%20%23f7f7f7%206px%29%2C%0Alinear%2Dgradient%28%23f7f7f7%2C%20%23f7f7f7%201%2E4em%2C%20%23aaa%201%2E4em%29%3B%0A%7D%0Atable%2Ediff%20%2Eline%2Dno%3Afirst%2Dchild%20%7B%0Aborder%2Dright%3A%201px%20solid%20%23ddd%3B%0Atext%2Dalign%3A%20right%3B%0A%7D%0Atable%2Ediff%20%2Eline%2Dno%3Alast%2Dchild%20%7B%0Aborder%2Dleft%3A%201px%20solid%20%23ddd%3B%0Atext%2Dalign%3A%20left%3B%0A%7D%0Atable%2Ediff%20td%3Anth%2Dchild%282%29%20%7B%0Aborder%2Dright%3A%201px%20solid%20%23ddd%3B%0A%7D%0A%2Eline%2Dno%2C%20%2Ecode%20%7B%0Apadding%3A%202px%3B%0Aheight%3A%201%2E11em%3B%0Afont%2Dfamily%3A%20monospace%3B%0A%7D%0A%2Ediff%20%2Eskip%20%7B%0Atext%2Dalign%3A%20center%3B%0Abackground%3A%20%23f7f7f7%3B%0A%7D%0A%2Ediff%20%2Edelete%20%7B%0Abackground%2Dcolor%3A%20%23fee%3B%0A%7D%0A%2Ediff%20%2Einsert%20%7B%0Abackground%2Dcolor%3A%20%23efe%3B%0A%7D%0A%2Ebefore%2Ereplace%20%7B%0Abackground%2Dcolor%3A%20%23fee%3B%0A%7D%0A%2Eafter%2Ereplace%20%7B%0Abackground%2Dcolor%3A%20%23efe%3B%0A%7D%0A%2Ebefore%20%2Echar%2Dreplace%2C%20%2Ebefore%20%2Echar%2Ddelete%20%7B%0Abackground%2Dcolor%3A%20%23fcc%3B%0A%7D%0A%2Eafter%20%2Echar%2Dreplace%2C%20%2Eafter%20%2Echar%2Dinsert%20%7B%0Abackground%2Dcolor%3A%20%23cfc%3B%0A%7D%0A%0A%2Eselecting%2Dleft%20td%2C%0A%2Eselecting%2Dleft%20td%20%2A%2C%0A%2Eselecting%2Dright%20td%2C%0A%2Eselecting%2Dright%20td%20%2A%0A%7B%0A%2Dmoz%2Duser%2Dselect%3A%20none%3B%0A%2Dwebkit%2Duser%2Dselect%3A%20none%3B%0A%2Dms%2Duser%2Dselect%3A%20none%3B%0Auser%2Dselect%3A%20none%3B%0A%7D%0A%2Eselecting%2Dleft%20td%2Eline%2Dno%3A%3Aselection%2C%0A%2Eselecting%2Dleft%20td%2Eline%2Dno%20%2A%3A%3Aselection%2C%0A%2Eselecting%2Dright%20td%2Eline%2Dno%3A%3Aselection%2C%0A%2Eselecting%2Dright%20td%2Eline%2Dno%20%2A%3A%3Aselection%2C%0A%2Eselecting%2Dleft%20td%2Eafter%3A%3Aselection%2C%0A%2Eselecting%2Dleft%20td%2Eafter%20%2A%3A%3Aselection%2C%0A%2Eselecting%2Dright%20td%2Ebefore%3A%3Aselection%2C%0A%2Eselecting%2Dright%20td%2Ebefore%20%2A%3A%3Aselection%0A%7B%0Abackground%3A%20transparent%3B%0A%7D%0A%2Eselecting%2Dleft%20td%2Eline%2Dno%3A%3A%2Dmoz%2Dselection%2C%0A%2Eselecting%2Dleft%20td%2Eline%2Dno%20%2A%3A%3A%2Dmoz%2Dselection%2C%0A%2Eselecting%2Dright%20td%2Eline%2Dno%3A%3A%2Dmoz%2Dselection%2C%0A%2Eselecting%2Dright%20td%2Eline%2Dno%20%2A%3A%3A%2Dmoz%2Dselection%2C%0A%2Eselecting%2Dleft%20td%2Eafter%3A%3A%2Dmoz%2Dselection%2C%0A%2Eselecting%2Dleft%20td%2Eafter%20%2A%3A%3A%2Dmoz%2Dselection%2C%0A%2Eselecting%2Dright%20td%2Ebefore%3A%3A%2Dmoz%2Dselection%2C%0A%2Eselecting%2Dright%20td%2Ebefore%20%2A%3A%3A%2Dmoz%2Dselection%0A%7B%0Abackground%3A%20transparent%3B%0A%7D%0A%2Eselecting%2Dleft%20td%2Ebefore%2C%0A%2Eselecting%2Dleft%20td%2Ebefore%20%2A%2C%0A%2Eselecting%2Dright%20td%2Eafter%2C%0A%2Eselecting%2Dright%20td%2Eafter%20%2A%20%7B%0A%2Dmoz%2Duser%2Dselect%3A%20text%3B%0A%2Dwebkit%2Duser%2Dselect%3A%20text%3B%0A%2Dms%2Duser%2Dselect%3A%20text%3B%0Auser%2Dselect%3A%20text%3B%0A%7D%0A" rel="stylesheet" />
<link href="data:text/css;charset=utf-8,%0A%2Ehljs%20%7B%0Adisplay%3A%20block%3B%20padding%3A%200%2E5em%3B%0Abackground%3A%20white%3B%20color%3A%20black%3B%0A%7D%0A%2Ehljs%2Dcomment%2C%0A%2Ehljs%2Dtemplate%5Fcomment%2C%0A%2Ehljs%2Djavadoc%2C%0A%2Ehljs%2Dcomment%20%2A%20%7B%0Acolor%3A%20%23800%3B%0A%7D%0A%2Ehljs%2Dkeyword%2C%0A%2Emethod%2C%0A%2Ehljs%2Dlist%20%2Ehljs%2Dtitle%2C%0A%2Eclojure%20%2Ehljs%2Dbuilt%5Fin%2C%0A%2Enginx%20%2Ehljs%2Dtitle%2C%0A%2Ehljs%2Dtag%20%2Ehljs%2Dtitle%2C%0A%2Esetting%20%2Ehljs%2Dvalue%2C%0A%2Ehljs%2Dwinutils%2C%0A%2Etex%20%2Ehljs%2Dcommand%2C%0A%2Ehttp%20%2Ehljs%2Dtitle%2C%0A%2Ehljs%2Drequest%2C%0A%2Ehljs%2Dstatus%20%7B%0Acolor%3A%20%23008%3B%0A%7D%0A%2Ehljs%2Denvvar%2C%0A%2Etex%20%2Ehljs%2Dspecial%20%7B%0Acolor%3A%20%23660%3B%0A%7D%0A%2Ehljs%2Dstring%2C%0A%2Ehljs%2Dtag%20%2Ehljs%2Dvalue%2C%0A%2Ehljs%2Dcdata%2C%0A%2Ehljs%2Dfilter%20%2Ehljs%2Dargument%2C%0A%2Ehljs%2Dattr%5Fselector%2C%0A%2Eapache%20%2Ehljs%2Dcbracket%2C%0A%2Ehljs%2Ddate%2C%0A%2Ehljs%2Dregexp%2C%0A%2Ecoffeescript%20%2Ehljs%2Dattribute%20%7B%0Acolor%3A%20%23080%3B%0A%7D%0A%2Ehljs%2Dsub%20%2Ehljs%2Didentifier%2C%0A%2Ehljs%2Dpi%2C%0A%2Ehljs%2Dtag%2C%0A%2Ehljs%2Dtag%20%2Ehljs%2Dkeyword%2C%0A%2Ehljs%2Ddecorator%2C%0A%2Eini%20%2Ehljs%2Dtitle%2C%0A%2Ehljs%2Dshebang%2C%0A%2Ehljs%2Dprompt%2C%0A%2Ehljs%2Dhexcolor%2C%0A%2Ehljs%2Drules%20%2Ehljs%2Dvalue%2C%0A%2Ecss%20%2Ehljs%2Dvalue%20%2Ehljs%2Dnumber%2C%0A%2Ehljs%2Dliteral%2C%0A%2Ehljs%2Dsymbol%2C%0A%2Eruby%20%2Ehljs%2Dsymbol%20%2Ehljs%2Dstring%2C%0A%2Ehljs%2Dnumber%2C%0A%2Ecss%20%2Ehljs%2Dfunction%2C%0A%2Eclojure%20%2Ehljs%2Dattribute%20%7B%0Acolor%3A%20%23066%3B%0A%7D%0A%2Ehljs%2Dclass%20%2Ehljs%2Dtitle%2C%0A%2Ehaskell%20%2Ehljs%2Dtype%2C%0A%2Esmalltalk%20%2Ehljs%2Dclass%2C%0A%2Ehljs%2Djavadoctag%2C%0A%2Ehljs%2Dyardoctag%2C%0A%2Ehljs%2Dphpdoc%2C%0A%2Ehljs%2Dtypename%2C%0A%2Ehljs%2Dtag%20%2Ehljs%2Dattribute%2C%0A%2Ehljs%2Ddoctype%2C%0A%2Ehljs%2Dclass%20%2Ehljs%2Did%2C%0A%2Ehljs%2Dbuilt%5Fin%2C%0A%2Esetting%2C%0A%2Ehljs%2Dparams%2C%0A%2Ehljs%2Dvariable%2C%0A%2Eclojure%20%2Ehljs%2Dtitle%20%7B%0Acolor%3A%20%23606%3B%0A%7D%0A%2Ecss%20%2Ehljs%2Dtag%2C%0A%2Ehljs%2Drules%20%2Ehljs%2Dproperty%2C%0A%2Ehljs%2Dpseudo%2C%0A%2Ehljs%2Dsubst%20%7B%0Acolor%3A%20%23000%3B%0A%7D%0A%2Ecss%20%2Ehljs%2Dclass%2C%0A%2Ecss%20%2Ehljs%2Did%20%7B%0Acolor%3A%20%239B703F%3B%0A%7D%0A%2Ehljs%2Dvalue%20%2Ehljs%2Dimportant%20%7B%0Acolor%3A%20%23ff7700%3B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0A%2Ehljs%2Drules%20%2Ehljs%2Dkeyword%20%7B%0Acolor%3A%20%23C5AF75%3B%0A%7D%0A%2Ehljs%2Dannotation%2C%0A%2Eapache%20%2Ehljs%2Dsqbracket%2C%0A%2Enginx%20%2Ehljs%2Dbuilt%5Fin%20%7B%0Acolor%3A%20%239B859D%3B%0A%7D%0A%2Ehljs%2Dpreprocessor%2C%0A%2Ehljs%2Dpreprocessor%20%2A%2C%0A%2Ehljs%2Dpragma%20%7B%0Acolor%3A%20%23444%3B%0A%7D%0A%2Etex%20%2Ehljs%2Dformula%20%7B%0Abackground%2Dcolor%3A%20%23EEE%3B%0Afont%2Dstyle%3A%20italic%3B%0A%7D%0A%2Ediff%20%2Ehljs%2Dheader%2C%0A%2Ehljs%2Dchunk%20%7B%0Acolor%3A%20%23808080%3B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0A%2Ediff%20%2Ehljs%2Dchange%20%7B%0Abackground%2Dcolor%3A%20%23BCCFF9%3B%0A%7D%0A%2Ehljs%2Daddition%20%7B%0Abackground%2Dcolor%3A%20%23BAEEBA%3B%0A%7D%0A%2Ehljs%2Ddeletion%20%7B%0Abackground%2Dcolor%3A%20%23FFC8BD%3B%0A%7D%0A%2Ehljs%2Dcomment%20%2Ehljs%2Dyardoctag%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0A" rel="stylesheet" />
<script src="data:application/x-javascript;base64,dmFyIGNvZGVkaWZmID0gKGZ1bmN0aW9uKCkgewoKdmFyIGRpZmZlciA9IGZ1bmN0aW9uKGJlZm9yZVRleHQsIGFmdGVyVGV4dCwgdXNlclBhcmFtcykgewogIHZhciBkZWZhdWx0UGFyYW1zID0gewogICAgY29udGV4dFNpemU6IDMsCiAgICBtaW5KdW1wU2l6ZTogMTAsCiAgICBsYW5ndWFnZTogbnVsbCwKICAgIGJlZm9yZU5hbWU6ICJCZWZvcmUiLAogICAgYWZ0ZXJOYW1lOiAiQWZ0ZXIiCiAgfTsKCiAgdGhpcy5wYXJhbXMgPSAkLmV4dGVuZCh7fSwgZGVmYXVsdFBhcmFtcywgdXNlclBhcmFtcyk7CgogIHRoaXMuYmVmb3JlTGluZXMgPSBiZWZvcmVUZXh0ID8gZGlmZmxpYi5zdHJpbmdBc0xpbmVzKGJlZm9yZVRleHQpIDogW107CiAgdGhpcy5hZnRlckxpbmVzID0gYWZ0ZXJUZXh0ID8gZGlmZmxpYi5zdHJpbmdBc0xpbmVzKGFmdGVyVGV4dCkgOiBbXTsKICB2YXIgc20gPSBuZXcgZGlmZmxpYi5TZXF1ZW5jZU1hdGNoZXIodGhpcy5iZWZvcmVMaW5lcywgdGhpcy5hZnRlckxpbmVzKTsKICB2YXIgb3Bjb2RlcyA9IHNtLmdldF9vcGNvZGVzKCk7CgogIC8vIFRPRE86IGRvbid0IHN0b3JlIHRoZSBkaWZmIHJhbmdlcyAtLSB0aGV5J3JlIG9ubHkgdXNlZCBvbmNlIGluIGJ1aWxkVmlldy4KICB0aGlzLmRpZmZSYW5nZXMgPSBkaWZmZXIub3Bjb2Rlc1RvRGlmZlJhbmdlcygKICAgICAgb3Bjb2RlcywgdGhpcy5wYXJhbXMuY29udGV4dFNpemUsIHRoaXMucGFyYW1zLm1pbkp1bXBTaXplKTsKCiAgaWYgKHRoaXMucGFyYW1zLmxhbmd1YWdlKSB7CiAgICB2YXIgbGFuZyA9IHRoaXMucGFyYW1zLmxhbmd1YWdlOwogICAgdGhpcy5iZWZvcmVMaW5lc0hpZ2hsaWdodGVkID0gZGlmZmVyLmhpZ2hsaWdodFRleHRfKGJlZm9yZVRleHQsIGxhbmcpOwogICAgdGhpcy5hZnRlckxpbmVzSGlnaGxpZ2h0ZWQgPSBkaWZmZXIuaGlnaGxpZ2h0VGV4dF8oYWZ0ZXJUZXh0LCBsYW5nKTsKICB9CiAgLy8gVE9ETzogZnJvbSB0aGlzIHBvaW50IG9uIGxhbmd1YWdlIHNob3VsZG4ndCBuZWVkIHRvIGJlIHVzZWQuCn07CgpkaWZmZXIucHJvdG90eXBlLm1heExpbmVOdW1iZXIgPSBmdW5jdGlvbigpIHsKICByZXR1cm4gTWF0aC5tYXgodGhpcy5iZWZvcmVMaW5lcy5sZW5ndGgsIHRoaXMuYWZ0ZXJMaW5lcy5sZW5ndGgpOwp9OwoKLyoqCiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFBvc3NpYmx5IG11bHRpbGluZSB0ZXh0IGNvbnRhaW5pbmcgc3BhbnMgdGhhdCBjcm9zcwogKiAgICAgbGluZSBicmVha3MuCiAqIEByZXR1cm4ge0FycmF5LjxzdHJpbmc+fSBBbiBhcnJheSBvZiBpbmRpdmlkdWFsIGxpbmVzLCBlYWNoIG9mIHdoaWNoIGhhcwogKiAgICAgZW50aXJlbHkgYmFsYW5jZWQgPHNwYW4+IHRhZ3MuCiAqLwpkaWZmZXIuZGlzdHJpYnV0ZVNwYW5zXyA9IGZ1bmN0aW9uKHRleHQpIHsKICB2YXIgbGluZXMgPSBkaWZmbGliLnN0cmluZ0FzTGluZXModGV4dCk7CiAgdmFyIHNwYW5SZSA9IC8oPHNwYW5bXj5dKj4pfCg8XC9zcGFuPikvOwoKICB2YXIgb3V0TGluZXMgPSBbXTsKICB2YXIgbGl2ZVNwYW5zID0gW107CiAgbGluZXMuZm9yRWFjaChmdW5jdGlvbihsaW5lKSB7CiAgICB2YXIgZ3JvdXBzID0gbGluZS5zcGxpdChzcGFuUmUpOwogICAgdmFyIGkgPSAwOwogICAgdmFyIG91dExpbmUgPSBsaXZlU3BhbnMuam9pbignJyk7CiAgICB3aGlsZSAoaSA8IGdyb3Vwcy5sZW5ndGgpIHsKICAgICAgdmFyIGcgPSBncm91cHNbaV07CiAgICAgIGlmIChnID09PSB1bmRlZmluZWQpIHsKICAgICAgICAvLyBjbG9zZSBzcGFuCiAgICAgICAgb3V0TGluZSArPSBncm91cHNbaSArIDFdOwogICAgICAgIGxpdmVTcGFucy5wb3AoKTsKICAgICAgICBpICs9IDI7CiAgICAgIH0gZWxzZSBpZiAoZy5zdWJzdHIoMCwgNSkgPT0gJzxzcGFuJykgewogICAgICAgIC8vIG9wZW4gc3BhbgogICAgICAgIGkgKz0gMjsKICAgICAgICBvdXRMaW5lICs9IGc7CiAgICAgICAgbGl2ZVNwYW5zLnB1c2goZyk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgLy8gcGxhaW4gdGV4dAogICAgICAgIG91dExpbmUgKz0gZzsKICAgICAgICBpKys7CiAgICAgIH0KICAgIH0KICAgIGxpdmVTcGFucy5mb3JFYWNoKGZ1bmN0aW9uKCkgeyBvdXRMaW5lICs9ICc8L3NwYW4+JzsgfSk7CiAgICBvdXRMaW5lcy5wdXNoKG91dExpbmUpOwogIH0pOwogIGlmIChsaXZlU3BhbnMubGVuZ3RoKSB0aHJvdyAiVW5iYWxhbmNlZCA8c3Bhbj5zIGluICIgKyB0ZXh0OwogIHJldHVybiBvdXRMaW5lczsKfTsKCi8qKgogKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUaGUgbGluZXMgdG8gaGlnaGxpZ2h0LgogKiBAcGFyYW0gez9zdHJpbmd9IG9wdF9sYW5ndWFnZSBMYW5ndWFnZSB0byBwYXNzIHRvIGhpZ2hsaWdodC5qcy4gSWYgbm90CiAqICAgICBzcGVjaWZpZWQsIHRoZW4gdGhlIGxhbmd1YWdlIHdpbGwgYmUgYXV0by1kZXRlY3RlZC4KICogQHJldHVybiB7QXJyYXkuPHN0cmluZz59IExpbmVzIG1hcmtlZCB1cCB3aXRoIHN5bnRheCA8c3Bhbj5zLiBUaGUgPHNwYW4+CiAqICAgICB0YWdzIHdpbGwgYmUgYmFsYW5jZWQgd2l0aGluIGVhY2ggbGluZS4KICovCmRpZmZlci5oaWdobGlnaHRUZXh0XyA9IGZ1bmN0aW9uKHRleHQsIG9wdF9sYW5ndWFnZSkgewogIGlmICh0ZXh0ID09PSBudWxsKSByZXR1cm4gW107CgogIC8vIFRPRE8oZGFudmspOiBsb29rIGludG8gc3VwcHJlc3NpbmcgaGlnaGxpZ2h0aW5nIGlmIC5yZWxldmFuY2UgaXMgbG93LgogIHZhciBodG1sOwogIGlmIChvcHRfbGFuZ3VhZ2UpIHsKICAgIGh0bWwgPSBobGpzLmhpZ2hsaWdodChvcHRfbGFuZ3VhZ2UsIHRleHQsIHRydWUpLnZhbHVlOwogIH0gZWxzZSB7CiAgICByZXR1cm4gbnVsbDsKICAgIC8vIFRoaXMgcHJvZHVjZXMgYSBsb3Qgb2YgZmFsc2UgcG9zaXRpdmVzOgogICAgLy8gaHRtbCA9IGhsanMuaGlnaGxpZ2h0QXV0byh0ZXh0KS52YWx1ZTsKICAgIC8vIFRoZXJlIGlzIGEgcmVsZXZhbmNlIG51bWJlciBidXQgaXQncyBoYXJkIHRvIHRocmVzaG9sZC4gVGhlIGZpbGUKICAgIC8vIGV4dGVuc2lvbiBpcyBwcm9iYWJseSBhIGdvb2QgZW5vdWdoIGhldXJpc3RpYy4KICB9CgogIC8vIFNvbWUgb2YgdGhlIDxzcGFuPnMgbWlnaHQgY3Jvc3MgbGluZXMsIHdoaWNoIHdvbid0IHdvcmsgZm9yIG91ciBkaWZmCiAgLy8gc3RydWN0dXJlLiBXZSBjb252ZXJ0IHRoZW0gdG8gc2luZ2xlLWxpbmUgb25seSA8c3BhbnM+IGhlcmUuCiAgcmV0dXJuIGRpZmZlci5kaXN0cmlidXRlU3BhbnNfKGh0bWwpOwp9CgovKioKICogQXR0YWNoIGV2ZW50IGxpc3RlbmVycywgbm90YWJseSBmb3IgdGhlICJzaG93IG1vcmUiIGxpbmtzLgogKi8KZGlmZmVyLnByb3RvdHlwZS5hdHRhY2hIYW5kbGVyc18gPSBmdW5jdGlvbihlbCkgewogIC8vIFRPRE86IGdyb3NzIGR1cGxpY2F0aW9uIHdpdGggYnVpbGRWaWV3XwogIHZhciBsYW5ndWFnZSA9IHRoaXMucGFyYW1zLmxhbmd1YWdlLAogICAgICBiZWZvcmVMaW5lcyA9IGxhbmd1YWdlID8gdGhpcy5iZWZvcmVMaW5lc0hpZ2hsaWdodGVkIDogdGhpcy5iZWZvcmVMaW5lcywKICAgICAgYWZ0ZXJMaW5lcyA9IGxhbmd1YWdlID8gdGhpcy5hZnRlckxpbmVzSGlnaGxpZ2h0ZWQgOiB0aGlzLmFmdGVyTGluZXM7CiAgJChlbCkub24oJ2NsaWNrJywgJy5za2lwIGEnLCBmdW5jdGlvbihlKSB7CiAgICBlLnByZXZlbnREZWZhdWx0KCk7CiAgICB2YXIgc2tpcERhdGEgPSAkKHRoaXMpLmNsb3Nlc3QoJy5za2lwJykuZGF0YSgpOwogICAgdmFyIGJlZm9yZUlkeCA9IHNraXBEYXRhLmJlZm9yZVN0YXJ0SW5kZXg7CiAgICB2YXIgYWZ0ZXJJZHggPSBza2lwRGF0YS5hZnRlclN0YXJ0SW5kZXg7CiAgICB2YXIganVtcCA9IHNraXBEYXRhLmp1bXBMZW5ndGg7CiAgICB2YXIgY2hhbmdlID0gImVxdWFsIjsKICAgIHZhciBuZXdUcnMgPSBbXTsKICAgIGZvciAodmFyIGkgPSAwOyBpIDwganVtcDsgaSsrKSB7CiAgICAgIG5ld1Rycy5wdXNoKGRpZmZlci5idWlsZFJvd1RyXygKICAgICAgICAnZXF1YWwnLAogICAgICAgIGJlZm9yZUlkeCArIGkgKyAxLAogICAgICAgIGJlZm9yZUxpbmVzW2JlZm9yZUlkeCArIGldLAogICAgICAgIGFmdGVySWR4ICsgaSArIDEsCiAgICAgICAgYWZ0ZXJMaW5lc1thZnRlcklkeCArIGldLAogICAgICAgIGxhbmd1YWdlKSk7CiAgICB9CgogICAgLy8gUmVwbGFjZSB0aGUgInNraXAiIHJvd3Mgd2l0aCByZWFsIGNvZGUuCiAgICB2YXIgJHNraXBUciA9ICQodGhpcykuY2xvc2VzdCgndHInKTsKICAgICRza2lwVHIucmVwbGFjZVdpdGgobmV3VHJzKTsKICB9KTsKCiAgLy8gSG9va3MgZm9yIHNpbmdsZS1jb2x1bW4gdGV4dCBzZWxlY3Rpb24uCiAgLy8gU2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI3NTMwNjI3LzM4ODk1MSBmb3IgZGV0YWlscy4KICAkKGVsKS5vbignbW91c2Vkb3duJywgZnVuY3Rpb24oZSkgewogICAgdmFyICR0ZCA9ICQoZS50YXJnZXQpLmNsb3Nlc3QoJ3RkJyksCiAgICAgICAgaXNMZWZ0ID0gJHRkLmlzKCcuYmVmb3JlJyksCiAgICAgICAgaXNSaWdodCA9ICR0ZC5pcygnLmFmdGVyJyk7CiAgICBpZiAoIWlzTGVmdCAmJiAhaXNSaWdodCkgcmV0dXJuOwoKICAgIGVsLnJlbW92ZUNsYXNzKCdzZWxlY3RpbmctbGVmdCBzZWxlY3RpbmctcmlnaHQnKQogICAgICAuYWRkQ2xhc3MoJ3NlbGVjdGluZy0nICsgKGlzTGVmdCA/ICdsZWZ0JyA6ICdyaWdodCcpKTsKICB9KS5vbignY29weScsIGZ1bmN0aW9uKGUpIHsKICAgIHZhciBpc0xlZnQgPSBlbC5pcygnLnNlbGVjdGluZy1sZWZ0JyksCiAgICAgICAgaWR4ID0gaXNMZWZ0ID8gMSA6IDI7ICAvLyBpbmRleCBvZiA8dGQ+IHdpdGhpbiA8dHI+CgogICAgdmFyIHNlbCA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKSwKICAgICAgICByYW5nZSA9IHNlbC5nZXRSYW5nZUF0KDApLAogICAgICAgIGRvYyA9IHJhbmdlLmNsb25lQ29udGVudHMoKSwKICAgICAgICBub2RlcyA9IGRvYy5xdWVyeVNlbGVjdG9yQWxsKCd0ZC4nICsgKGlzTGVmdCA/ICdiZWZvcmUnIDogJ2FmdGVyJykpLAogICAgICAgIHRleHQgPSAnJzsKCiAgICBpZiAobm9kZXMubGVuZ3RoID09PSAwKSB7CiAgICAgIHRleHQgPSBkb2MudGV4dENvbnRlbnQ7CiAgICB9IGVsc2UgewogICAgICBbXS5mb3JFYWNoLmNhbGwobm9kZXMsIGZ1bmN0aW9uKHRkLCBpKSB7CiAgICAgICAgdGV4dCArPSAoaSA/ICdcbicgOiAnJykgKyB0ZC50ZXh0Q29udGVudDsKICAgICAgfSk7CiAgICB9CiAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cdTIwMEIvZywgJycpOyAgLy8gcmVtb3ZlIHNvZnQgYnJlYWtzCgogICAgdmFyIGNsaXBib2FyZERhdGEgPSBlLm9yaWdpbmFsRXZlbnQuY2xpcGJvYXJkRGF0YTsKICAgIGNsaXBib2FyZERhdGEuc2V0RGF0YSgndGV4dCcsIHRleHQpOwogICAgZS5wcmV2ZW50RGVmYXVsdCgpOwogIH0pOwp9OwoKLyoqCiAqIENyZWF0ZSBhIHNpbmdsZSByb3cgaW4gdGhlIHRhYmxlLiBBZGRzIGNoYXJhY3RlciBkaWZmcyBpZiByZXF1aXJlZC4KICovCmRpZmZlci5idWlsZFJvd1RyXyA9IGZ1bmN0aW9uKHR5cGUsIGJlZm9yZUxpbmVOdW0sIGJlZm9yZVRleHRPckh0bWwsIGFmdGVyTGluZU51bSwgYWZ0ZXJUZXh0T3JIdG1sLCBsYW5ndWFnZSkgewogIHZhciAkbWFrZUNvZGVUZCA9IGZ1bmN0aW9uKHRleHRPckh0bWwpIHsKICAgIGlmICh0ZXh0T3JIdG1sID09IG51bGwpIHsKICAgICAgcmV0dXJuICQoJzx0ZCBjbGFzcz0iZW1wdHkgY29kZSI+Jyk7CiAgICB9CiAgICB0ZXh0T3JIdG1sID0gdGV4dE9ySHRtbC5yZXBsYWNlKC9cdC9nLCAiXHUwMGEwXHUwMGEwXHUwMGEwXHUwMGEwIik7CiAgICB2YXIgJHRkID0gJCgnPHRkIGNsYXNzPSJjb2RlIj4nKS5hZGRDbGFzcyh0eXBlKTsKICAgIGlmIChsYW5ndWFnZSkgewogICAgICAkdGQuaHRtbCh0ZXh0T3JIdG1sKTsKICAgIH0gZWxzZSB7CiAgICAgICR0ZC50ZXh0KHRleHRPckh0bWwpOwogICAgfQogICAgcmV0dXJuICR0ZDsKICB9OwoKICB2YXIgY2VsbHMgPSBbCiAgICAkKCc8dGQgY2xhc3M9bGluZS1ubz4nKS50ZXh0KGJlZm9yZUxpbmVOdW0gfHwgJycpLmdldCgwKSwKICAgICRtYWtlQ29kZVRkKGJlZm9yZVRleHRPckh0bWwpLmFkZENsYXNzKCdiZWZvcmUnKS5nZXQoMCksCiAgICAkbWFrZUNvZGVUZChhZnRlclRleHRPckh0bWwpLmFkZENsYXNzKCdhZnRlcicpLmdldCgwKSwKICAgICQoJzx0ZCBjbGFzcz1saW5lLW5vPicpLnRleHQoYWZ0ZXJMaW5lTnVtIHx8ICcnKS5nZXQoMCkKICBdOwogIGlmICh0eXBlID09ICdyZXBsYWNlJykgewogICAgZGlmZmVyLmFkZENoYXJhY3RlckRpZmZzXyhjZWxsc1sxXSwgY2VsbHNbMl0sIGxhbmd1YWdlKTsKICB9CgogIHJldHVybiAkKCc8dHI+JykuYXBwZW5kKGNlbGxzKS5nZXQoMCk7Cn07CgovKioKICogQ3JlYXRlIGEgInNraXAiIHJvdyB3aXRoIGEgbGluayB0byBleHBhbmQuCiAqIGJlZm9yZUlkeCBhbmQgYWZ0ZXJJZHggYXJlIHRoZSBpbmRpY2VzIG9mIHRoZSBmaXJzdCBsaW5lcyBza2lwcGVkLgogKi8KZGlmZmVyLmJ1aWxkU2tpcFRyXyA9IGZ1bmN0aW9uKGJlZm9yZUlkeCwgYWZ0ZXJJZHgsIG51bVJvd3NTa2lwcGVkKSB7CiAgdmFyICR0ciA9ICQoCiAgICAnPHRyPicgKwogICAgICAnPHRkIGNsYXNzPSJsaW5lLW5vIj4maGVsbGlwOzwvdGQ+JyArCiAgICAgICc8dGQgY29sc3Bhbj0iMiIgY2xhc3M9InNraXAgY29kZSI+JyArCiAgICAgICAgJzxhIGhyZWY9IiMiPlNob3cgJyArIG51bVJvd3NTa2lwcGVkICsgJyBtb3JlIGxpbmVzPC9hPicgKwogICAgICAnPC90ZD4nICsKICAgICAgJzx0ZCBjbGFzcz0ibGluZS1ubyI+JmhlbGxpcDs8L3RkPicgKwogICAgJzwvdHI+Jyk7CiAgJHRyLmZpbmQoJy5za2lwJykuZGF0YSh7CiAgICAnYmVmb3JlU3RhcnRJbmRleCc6IGJlZm9yZUlkeCwKICAgICdhZnRlclN0YXJ0SW5kZXgnOiBhZnRlcklkeCwKICAgICdqdW1wTGVuZ3RoJzogbnVtUm93c1NraXBwZWQKICB9KTsKICByZXR1cm4gJHRyLmdldCgwKTsKfTsKCmRpZmZlci5wcm90b3R5cGUuYnVpbGRWaWV3XyA9IGZ1bmN0aW9uKCkgewogIC8vIFRPRE86IGlzIHRoaXMgZGlzdGluY3Rpb24gbmVjZXNzYXJ5PwogIHZhciBsYW5ndWFnZSA9IHRoaXMucGFyYW1zLmxhbmd1YWdlLAogICAgICBiZWZvcmVMaW5lcyA9IGxhbmd1YWdlID8gdGhpcy5iZWZvcmVMaW5lc0hpZ2hsaWdodGVkIDogdGhpcy5iZWZvcmVMaW5lcywKICAgICAgYWZ0ZXJMaW5lcyA9IGxhbmd1YWdlID8gdGhpcy5hZnRlckxpbmVzSGlnaGxpZ2h0ZWQgOiB0aGlzLmFmdGVyTGluZXM7CgogIHZhciAkdGFibGUgPSAkKCc8dGFibGUgY2xhc3M9ImRpZmYiPicpOwogICR0YWJsZS5hcHBlbmQoJCgnPHRyPicpLmFwcGVuZCgKICAgICAgJCgnPHRoIGNsYXNzPSJkaWZmLWhlYWRlciIgY29sc3Bhbj0yPicpLnRleHQodGhpcy5wYXJhbXMuYmVmb3JlTmFtZSksCiAgICAgICQoJzx0aCBjbGFzcz0iZGlmZi1oZWFkZXIiIGNvbHNwYW49Mj4nKS50ZXh0KHRoaXMucGFyYW1zLmFmdGVyTmFtZSkpKTsKCiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRpZmZSYW5nZXMubGVuZ3RoOyBpKyspIHsKICAgIHZhciByYW5nZSA9IHRoaXMuZGlmZlJhbmdlc1tpXSwKICAgICAgICB0eXBlID0gcmFuZ2UudHlwZSwKICAgICAgICBudW1CZWZvcmVSb3dzID0gcmFuZ2UuYmVmb3JlWzFdIC0gcmFuZ2UuYmVmb3JlWzBdLAogICAgICAgIG51bUFmdGVyUm93cyA9IHJhbmdlLmFmdGVyWzFdIC0gcmFuZ2UuYWZ0ZXJbMF0sCiAgICAgICAgbnVtUm93cyA9IE1hdGgubWF4KG51bUJlZm9yZVJvd3MsIG51bUFmdGVyUm93cyk7CgogICAgaWYgKHR5cGUgPT0gJ3NraXAnKSB7CiAgICAgICR0YWJsZS5hcHBlbmQoCiAgICAgICAgICBkaWZmZXIuYnVpbGRTa2lwVHJfKHJhbmdlLmJlZm9yZVswXSwgcmFuZ2UuYWZ0ZXJbMF0sIG51bVJvd3MpKTsKICAgIH0gZWxzZSB7CiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbnVtUm93czsgaisrKSB7CiAgICAgICAgdmFyIGJlZm9yZUlkeCA9IChqIDwgbnVtQmVmb3JlUm93cykgPyByYW5nZS5iZWZvcmVbMF0gKyBqIDogbnVsbCwKICAgICAgICAgICAgYWZ0ZXJJZHggPSAoaiA8IG51bUFmdGVyUm93cykgPyByYW5nZS5hZnRlclswXSArIGogOiBudWxsOwogICAgICAgICR0YWJsZS5hcHBlbmQoZGlmZmVyLmJ1aWxkUm93VHJfKAogICAgICAgICAgICB0eXBlLAogICAgICAgICAgICAoYmVmb3JlSWR4ICE9IG51bGwpICYmIDEgKyBiZWZvcmVJZHgsCiAgICAgICAgICAgIGJlZm9yZUxpbmVzW2JlZm9yZUlkeF0sCiAgICAgICAgICAgIChhZnRlcklkeCAhPSBudWxsKSAmJiAxICsgYWZ0ZXJJZHgsCiAgICAgICAgICAgIGFmdGVyTGluZXNbYWZ0ZXJJZHhdLAogICAgICAgICAgICBsYW5ndWFnZSkpOwogICAgICB9CiAgICB9CiAgfQoKICAvLyBUT0RPOiBtb3ZlIGludG8gYnVpbGRSb3dUcl8/CiAgaWYgKCF0aGlzLnBhcmFtcy53b3JkV3JhcCkgewogICAgJHRhYmxlLmZpbmQoJy5jb2RlJykuZWFjaChmdW5jdGlvbihfLCBlbCkgewogICAgICBkaWZmZXIuYWRkU29mdEJyZWFrcyhlbCk7CiAgICB9KTsKICB9CgogIHZhciAkY29udGFpbmVyID0gJCgnPGRpdiBjbGFzcz0iZGlmZiI+Jyk7CiAgJGNvbnRhaW5lci5hcHBlbmQoJHRhYmxlKTsKICAvLyBBdHRhY2ggZXZlbnQgaGFuZGxlcnMgJiBhcHBseSBjaGFyIGRpZmZzLgogIHRoaXMuYXR0YWNoSGFuZGxlcnNfKCRjb250YWluZXIpOwogIHJldHVybiAkY29udGFpbmVyLmdldCgwKTsKfTsKCi8vIElucHV0IGlzIGEgbGlzdCBvZiBvcGNvZGVzLCBhcyBvdXRwdXQgYnkgZGlmZmxpYiAoZS5nLiAnZXF1YWwnLCAncmVwbGFjZScsCi8vICdkZWxldGUnLCAnaW5zZXJ0JykuCi8vIE91dHB1dCBpcyBhIGxpc3Qgb2YgZGlmZiByYW5nZXMgd2hpY2ggY29ycmVzcG9uZHMgcHJlY2lzZWx5IHRvIHRoZSB2aWV3LCBlLmcuCi8vICdza2lwJywgJ2luc2VydCcsICdyZXBsYWNlJywgJ2RlbGV0ZScgYW5kICdlcXVhbCcuCi8vIE91dHB1dHMgYXJlIHt0eXBlLCBiZWZvcmU6W3N0YXJ0LGxpbWl0XSwgYWZ0ZXI6W3N0YXJ0LGxpbWl0XX0gdHVwbGVzLgpkaWZmZXIub3Bjb2Rlc1RvRGlmZlJhbmdlcyA9IGZ1bmN0aW9uKG9wY29kZXMsIGNvbnRleHRTaXplLCBtaW5KdW1wU2l6ZSkgewogIHZhciByYW5nZXMgPSBbXTsKCiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcGNvZGVzLmxlbmd0aDsgaSsrKSB7CiAgICB2YXIgb3Bjb2RlID0gb3Bjb2Rlc1tpXTsKICAgIHZhciBjaGFuZ2UgPSBvcGNvZGVbMF07ICAvLyAiZXF1YWwiLCAicmVwbGFjZSIsICJkZWxldGUiLCAiaW5zZXJ0IgogICAgdmFyIGJlZm9yZUlkeCA9IG9wY29kZVsxXTsKICAgIHZhciBiZWZvcmVFbmQgPSBvcGNvZGVbMl07CiAgICB2YXIgYWZ0ZXJJZHggPSBvcGNvZGVbM107CiAgICB2YXIgYWZ0ZXJFbmQgPSBvcGNvZGVbNF07CiAgICB2YXIgcmFuZ2UgPSB7CiAgICAgICAgICB0eXBlOiBjaGFuZ2UsCiAgICAgICAgICBiZWZvcmU6IFtiZWZvcmVJZHgsIGJlZm9yZUVuZF0sCiAgICAgICAgICBhZnRlcjogW2FmdGVySWR4LCBhZnRlckVuZF0KICAgICAgICB9OwogICAgaWYgKGNoYW5nZSAhPSAnZXF1YWwnKSB7CiAgICAgIHJhbmdlcy5wdXNoKHJhbmdlKTsKICAgICAgY29udGludWU7CiAgICB9CgogICAgLy8gU2hvdWxkIHRoaXMgImVxdWFsIiByYW5nZSBoYXZlIGEganVtcCBpbnNlcnRlZD8KICAgIC8vIEZpcnN0IHJlbW92ZSBgY29udGV4dFNpemVgIGxpbmVzIGZyb20gZWl0aGVyIGVuZC4KICAgIC8vIElmIHRoaXMgbGVhdmVzIG1vcmUgdGhhbiBtaW5KdW1wU2l6ZSByb3dzLCB0aGVuIHNwbGljZSBpbiBhIGp1bXAuCiAgICB2YXIgcm93Q291bnQgPSBiZWZvcmVFbmQgLSBiZWZvcmVJZHgsICAvLyB3b3VsZCBiZSBzYW1lIGZvciBhZnRlcntFbmQsSWR4fQogICAgICAgIGlzU3RhcnQgPSAoaSA9PSAwKSwKICAgICAgICBpc0VuZCA9IChpID09IG9wY29kZXMubGVuZ3RoIC0gMSksCiAgICAgICAgZmlyc3RTa2lwT2Zmc2V0ID0gaXNTdGFydCA/IDAgOiBjb250ZXh0U2l6ZSwKICAgICAgICBsYXN0U2tpcE9mZnNldCA9IHJvd0NvdW50IC0gKGlzRW5kID8gMCA6IGNvbnRleHRTaXplKSwKICAgICAgICBza2lwTGVuZ3RoID0gbGFzdFNraXBPZmZzZXQgLSBmaXJzdFNraXBPZmZzZXQ7CgogICAgaWYgKHNraXBMZW5ndGggPT0gMCB8fCBza2lwTGVuZ3RoIDwgbWluSnVtcFNpemUpIHsKICAgICAgcmFuZ2VzLnB1c2gocmFuZ2UpOwogICAgICBjb250aW51ZTsKICAgIH0KCiAgICAvLyBDb252ZXJ0IHRoZSAnZXF1YWwnIGJsb2NrIHRvIGFuIGVxdWFsLXNraXAtZXF1YWwgc2VxdWVuY2UuCiAgICBpZiAoZmlyc3RTa2lwT2Zmc2V0ID4gMCkgewogICAgICByYW5nZXMucHVzaCh7CiAgICAgICAgdHlwZTogJ2VxdWFsJywKICAgICAgICBiZWZvcmU6IFtiZWZvcmVJZHgsIGJlZm9yZUlkeCArIGZpcnN0U2tpcE9mZnNldF0sCiAgICAgICAgYWZ0ZXI6IFthZnRlcklkeCwgYWZ0ZXJJZHggKyBmaXJzdFNraXBPZmZzZXRdCiAgICAgIH0pOwogICAgfQogICAgcmFuZ2VzLnB1c2goewogICAgICB0eXBlOiAnc2tpcCcsCiAgICAgIGJlZm9yZTogW2JlZm9yZUlkeCArIGZpcnN0U2tpcE9mZnNldCwgYmVmb3JlSWR4ICsgbGFzdFNraXBPZmZzZXRdLAogICAgICBhZnRlcjogW2FmdGVySWR4ICsgZmlyc3RTa2lwT2Zmc2V0LCBhZnRlcklkeCArIGxhc3RTa2lwT2Zmc2V0XQogICAgfSk7CiAgICBpZiAobGFzdFNraXBPZmZzZXQgPCByb3dDb3VudCkgewogICAgICByYW5nZXMucHVzaCh7CiAgICAgICAgdHlwZTogJ2VxdWFsJywKICAgICAgICBiZWZvcmU6IFtiZWZvcmVJZHggKyBsYXN0U2tpcE9mZnNldCwgYmVmb3JlRW5kXSwKICAgICAgICBhZnRlcjogW2FmdGVySWR4ICsgbGFzdFNraXBPZmZzZXQsIGFmdGVyRW5kXQogICAgICB9KTsKICAgIH0KICB9CgogIHJldHVybiByYW5nZXM7Cn0KCmZ1bmN0aW9uIHdhbGtUaGVET00obm9kZSwgZnVuYykgewogIGZ1bmMobm9kZSk7CiAgbm9kZSA9IG5vZGUuZmlyc3RDaGlsZDsKICB3aGlsZSAobm9kZSkgewogICAgd2Fsa1RoZURPTShub2RlLCBmdW5jKTsKICAgIG5vZGUgPSBub2RlLm5leHRTaWJsaW5nOwogIH0KfQoKLyoqCiAqIEFkZHMgc29mdCB3cmFwIG1hcmtlcnMgYmV0d2VlbiBhbGwgY2hhcmFjdGVycyBpbiBhIERPTSBlbGVtZW50LgogKi8KZGlmZmVyLmFkZFNvZnRCcmVha3MgPSBmdW5jdGlvbihlbCkgewogIHZhciBzb2Z0QnJlYWsgPSAnXHUyMDBCJzsKICB3YWxrVGhlRE9NKGVsLCBmdW5jdGlvbihub2RlKSB7CiAgICBpZiAobm9kZS5ub2RlVHlwZSAhPT0gMykgcmV0dXJuOwogICAgdmFyIHRleHQgPSBub2RlLmRhdGE7CiAgICB0ZXh0ID0gdGV4dC5zcGxpdCgnJykuam9pbihzb2Z0QnJlYWspOwogICAgbm9kZS5ub2RlVmFsdWUgPSB0ZXh0OwogIH0pOwp9OwoKZGlmZmVyLmh0bWxUZXh0TWFwcGVyID0gZnVuY3Rpb24odGV4dCwgaHRtbCkgewogIHRoaXMudGV4dF8gPSB0ZXh0OwogIHRoaXMuaHRtbF8gPSBodG1sOwp9OwoKLy8gR2V0IHRoZSBzdWJzdHJpbmcgb2YgSFRNTCBjb3JyZXNwb25kaW5nIHRvIHRleHQuc3Vic3RyKHN0YXJ0LCBsZW4pLgovLyBMZWFkaW5nIG1hcmt1cCBpcyBpbmNsdWRlZCB3aXRoIGluZGV4IDAsIHRyYWlsaW5nIHdpdGggdGhlIGxhc3QgY2hhci4KZGlmZmVyLmh0bWxUZXh0TWFwcGVyLnByb3RvdHlwZS5nZXRIdG1sU3Vic3RyaW5nID0gZnVuY3Rpb24oc3RhcnQsIGxpbWl0KSB7CiAgdmFyIGNvdW50ID0gbGltaXQgLSBzdGFydDsKICByZXR1cm4gaHRtbF9zdWJzdHIodGhpcy5odG1sXywgc3RhcnQsIGNvdW50KTsKfTsKCi8vIFJldHVybnMgdGhlIEhUTUwgY29ycmVzcG9uZGluZyB0byB0ZXh0IGluIHBvc2l0aW9ucyBbc3RhcnQsIHN0YXJ0K2NvdW50KS4KLy8gVGhpcyBpbmNsdWRlcyBhbnkgSFRNTCBpbiB0aGF0IGNoYXJhY3RlciByYW5nZSwgb3IgZW5jbG9zaW5nIGl0LgovLyBjb2JibGVkIHRvZ2V0aGVyIGZyb206Ci8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNjAwMzI3MS9zdWJzdHJpbmctdGV4dC13aXRoLWh0bWwtdGFncy1pbi1qYXZhc2NyaXB0P3JxPTEKLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xNjg1NjkyOC9zdWJzdHJpbmctdGV4dC13aXRoLWphdmFzY3JpcHQtaW5jbHVkaW5nLWh0bWwtdGFncwpmdW5jdGlvbiBodG1sX3N1YnN0cihodG1sLCBzdGFydCwgY291bnQpIHsKICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7CiAgZGl2LmlubmVySFRNTCA9IGh0bWw7CiAgdmFyIGNvbnN1bWVkID0gMDsKCiAgd2FsayhkaXYsIHRyYWNrKTsKCiAgZnVuY3Rpb24gdHJhY2soZWwpIHsKICAgIGlmIChjb3VudCA+IDApIHsKICAgICAgdmFyIGxlbiA9IGVsLmRhdGEubGVuZ3RoOwogICAgICBpZiAoc3RhcnQgPD0gbGVuKSB7CiAgICAgICAgZWwuZGF0YSA9IGVsLnN1YnN0cmluZ0RhdGEoc3RhcnQsIGxlbik7CiAgICAgICAgc3RhcnQgPSAwOwogICAgICB9IGVsc2UgewogICAgICAgIHN0YXJ0IC09IGxlbjsKICAgICAgICBlbC5kYXRhID0gJyc7CiAgICAgIH0KICAgICAgbGVuID0gZWwuZGF0YS5sZW5ndGg7CiAgICAgIGNvdW50IC09IGxlbjsKICAgICAgY29uc3VtZWQgKz0gbGVuOwogICAgICBpZiAoY291bnQgPD0gMCkgewogICAgICAgIGVsLmRhdGEgPSBlbC5zdWJzdHJpbmdEYXRhKDAsIGVsLmRhdGEubGVuZ3RoICsgY291bnQpOwogICAgICB9CiAgICB9IGVsc2UgewogICAgICBlbC5kYXRhID0gJyc7CiAgICB9CiAgfQoKICBmdW5jdGlvbiB3YWxrKGVsLCBmbikgewogICAgdmFyIG5vZGUgPSBlbC5maXJzdENoaWxkLCBvbGROb2RlOwogICAgdmFyIGVsc1RvUmVtb3ZlID0gW107CiAgICBkbyB7CiAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSAzKSB7CiAgICAgICAgZm4obm9kZSk7CiAgICAgIH0gZWxzZSBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBub2RlLmNoaWxkTm9kZXMgJiYgbm9kZS5jaGlsZE5vZGVzWzBdKSB7CiAgICAgICAgd2Fsayggbm9kZSwgZm4gKTsKICAgICAgfQogICAgICBpZiAoY29uc3VtZWQgPT0gMCAmJiBub2RlLm5vZGVUeXBlID09IDEpIHsKICAgICAgICBlbHNUb1JlbW92ZS5wdXNoKG5vZGUpOwogICAgICB9CiAgICB9IHdoaWxlICgobm9kZSA9IG5vZGUubmV4dFNpYmxpbmcpICYmIChjb3VudCA+IDApKTsKCiAgICAvLyByZW1vdmUgcmVtYWluaW5nIG5vZGVzCiAgICB3aGlsZSAobm9kZSl7CiAgICAgIG9sZE5vZGUgPSBub2RlOwogICAgICBub2RlID0gbm9kZS5uZXh0U2libGluZzsKICAgICAgZWwucmVtb3ZlQ2hpbGQob2xkTm9kZSk7CiAgICB9CgogICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbHNUb1JlbW92ZS5sZW5ndGg7IGkrKykgewogICAgICB2YXIgZWwgPSBlbHNUb1JlbW92ZVtpXTsKICAgICAgaWYgKGVsICYmIGVsLnBhcmVudE5vZGUpIHsKICAgICAgICBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTsKICAgICAgfQogICAgfQogIH0KCiAgcmV0dXJuIGRpdi5pbm5lckhUTUw7Cn0KCi8qKgogKiBAcGFyYW0ge3N0cmluZ30gbGluZSBUaGUgbGluZSB0byBiZSBzcGxpdAogKiBAcmV0dXJuIHtBcnJheS48c3RyaW5nPn0gQ29tcG9uZW50IHdvcmRzIGluIHRoZSBsaW5lLiBBbiBpbnZhcmlhbnQgaXMgdGhhdAogKiAgICAgc3BsaXRJbnRvV29yZHNfKGxpbmUpLmpvaW4oJycpID09IGxpbmUuCiAqLwpkaWZmZXIuc3BsaXRJbnRvV29yZHNfID0gZnVuY3Rpb24obGluZSkgewogIHZhciBMQyA9IDAsIFVDID0gMiwgTlVNID0gMywgV1MgPSA0LCBTWU0gPSA1OwogIHZhciBjaGFyVHlwZSA9IGZ1bmN0aW9uKGMpIHsKICAgIGlmIChjLm1hdGNoKC9bYS16XS8pKSByZXR1cm4gTEM7CiAgICBpZiAoYy5tYXRjaCgvW0EtWl0vKSkgcmV0dXJuIFVDOwogICAgaWYgKGMubWF0Y2goL1swLTldLykpIHJldHVybiBOVU07CiAgICBpZiAoYy5tYXRjaCgvXHMvKSkgcmV0dXJuIFdTOwogICAgcmV0dXJuIFNZTTsKICB9OwoKICAvLyBTaW5nbGUgd29yZHMgY2FuIGJlIFtBLVpdW2Etel0rLCBbQS1aXSssIFthLXpdKywgWzAtOV0rIG9yIFxzKy4KICB2YXIgd29yZHMgPSBbXTsKICB2YXIgbGFzdFR5cGUgPSAtMTsKICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmUubGVuZ3RoOyBpKyspIHsKICAgIHZhciBjID0gbGluZS5jaGFyQXQoaSk7CiAgICB2YXIgY3QgPSBjaGFyVHlwZShjKTsKICAgIGlmIChjdCA9PSBsYXN0VHlwZSAmJiBjdCAhPSBTWU0gJiYgY3QgIT0gV1MgfHwKICAgICAgICBjdCA9PSBMQyAmJiBsYXN0VHlwZSA9PSBVQyAmJiB3b3Jkc1t3b3Jkcy5sZW5ndGggLSAxXS5sZW5ndGggPT0gMSkgewogICAgICB3b3Jkc1t3b3Jkcy5sZW5ndGggLSAxXSArPSBjOwogICAgfSBlbHNlIHsKICAgICAgd29yZHMucHVzaChjKTsKICAgIH0KICAgIGxhc3RUeXBlID0gY3Q7CiAgfQogIHJldHVybiB3b3JkczsKfTsKCi8qKgogKiBDb21wdXRlIGFuIGludHJhLWxpbmUgZGlmZi4KICogQHBhcmFtIHtzdHJpbmd9IGJlZm9yZVRleHQKICogQHBhcmFtIHtzdHJpbmd9IGFmdGVyVGV4dAogKiBAcmV0dXJuIHs/QXJyYXkuPEFycmF5Pn0gW2JlZm9yZSBjb2RlcywgYWZ0ZXIgY29kZXNdLCB3aGVyZSBlYWNoIGVsZW1lbnQgaXMgYQogKiAgICAgbGlzdCBvZiAoJ2NoYW5nZSB0eXBlJywgc3RhcnQgaWR4LCBzdG9wIGlkeCkgdHJpcGxlcy4gUmV0dXJucyBudWxsIGlmCiAqICAgICBjaGFyYWN0ZXIgZGlmZmVyZW5jZXMgYXJlIG5vdCBhcHByb3ByaWF0ZSBmb3IgdGhpcyBsaW5lIHBhaXJpbmcuCiAqLwpkaWZmZXIuY29tcHV0ZUNoYXJhY3RlckRpZmZzXyA9IGZ1bmN0aW9uKGJlZm9yZVRleHQsIGFmdGVyVGV4dCkgewogIHZhciBiZWZvcmVXb3JkcyA9IGRpZmZlci5zcGxpdEludG9Xb3Jkc18oYmVmb3JlVGV4dCksCiAgICAgIGFmdGVyV29yZHMgPSBkaWZmZXIuc3BsaXRJbnRvV29yZHNfKGFmdGVyVGV4dCk7CgogIC8vIFRPRE86IHByZWNvbXB1dGUgdHdvIGFycmF5czsgdGhpcyBkb2VzIHRvbyBtdWNoIHdvcmsuCiAgdmFyIHdvcmRUb0lkeCA9IGZ1bmN0aW9uKGlzQmVmb3JlLCBpZHgpIHsKICAgIHZhciB3b3JkcyA9IGlzQmVmb3JlID8gYmVmb3JlV29yZHMgOiBhZnRlcldvcmRzOwogICAgdmFyIGNoYXJJZHggPSAwOwogICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZHg7IGkrKykgewogICAgICBjaGFySWR4ICs9IHdvcmRzW2ldLmxlbmd0aDsKICAgIH0KICAgIHJldHVybiBjaGFySWR4OwogIH07CgogIHZhciBzbSA9IG5ldyBkaWZmbGliLlNlcXVlbmNlTWF0Y2hlcihiZWZvcmVXb3JkcywgYWZ0ZXJXb3Jkcyk7CiAgdmFyIG9wY29kZXMgPSBzbS5nZXRfb3Bjb2RlcygpOwoKICAvLyBTdXBwcmVzcyBjaGFyLWJ5LWNoYXIgZGlmZnMgaWYgdGhlcmUncyBsZXNzIHRoYW4gNTAlIGNoYXJhY3RlciBvdmVybGFwLgogIC8vIFRoZSBvbmUgZXhjZXB0aW9uIGlzIHB1cmUgd2hpdGVzcGFjZSBkaWZmcywgd2hpY2ggc2hvdWxkIGFsd2F5cyBiZSBzaG93bi4KICB2YXIgbWluRXF1YWxGcmFjID0gMC41OwogIHZhciBlcXVhbENvdW50ID0gMCwgY2hhckNvdW50ID0gMDsKICB2YXIgYmVmb3JlRGlmZiA9ICcnLCBhZnRlckRpZmYgPSAnJzsKICBvcGNvZGVzLmZvckVhY2goZnVuY3Rpb24ob3Bjb2RlKSB7CiAgICB2YXIgY2hhbmdlID0gb3Bjb2RlWzBdOwogICAgdmFyIGJlZm9yZUlkeCA9IHdvcmRUb0lkeCh0cnVlLCBvcGNvZGVbMV0pOwogICAgdmFyIGJlZm9yZUVuZCA9IHdvcmRUb0lkeCh0cnVlLCBvcGNvZGVbMl0pOwogICAgdmFyIGFmdGVySWR4ID0gd29yZFRvSWR4KGZhbHNlLCBvcGNvZGVbM10pOwogICAgdmFyIGFmdGVyRW5kID0gd29yZFRvSWR4KGZhbHNlLCBvcGNvZGVbNF0pOwogICAgdmFyIGJlZm9yZUxlbiA9IGJlZm9yZUVuZCAtIGJlZm9yZUlkeDsKICAgIHZhciBhZnRlckxlbiA9IGFmdGVyRW5kIC0gYWZ0ZXJJZHg7CiAgICB2YXIgY291bnQgPSBiZWZvcmVMZW4gKyBhZnRlckxlbjsKICAgIGlmIChjaGFuZ2UgPT0gJ2VxdWFsJykgewogICAgICBlcXVhbENvdW50ICs9IGNvdW50OwogICAgfSBlbHNlIHsKICAgICAgYmVmb3JlRGlmZiArPSBiZWZvcmVUZXh0LnN1YnN0cmluZyhiZWZvcmVJZHgsIGJlZm9yZUVuZCk7CiAgICAgIGFmdGVyRGlmZiArPSBhZnRlclRleHQuc3Vic3RyaW5nKGFmdGVySWR4LCBhZnRlckVuZCk7CiAgICB9CiAgICBjaGFyQ291bnQgKz0gY291bnQ7CiAgfSk7CiAgaWYgKGVxdWFsQ291bnQgPCBtaW5FcXVhbEZyYWMgKiBjaGFyQ291bnQgJiYKICAgICAgIShiZWZvcmVEaWZmLm1hdGNoKC9eXHMqJC8pICYmIGFmdGVyRGlmZi5tYXRjaCgvXlxzKiQvKSkpIHsKICAgIHJldHVybiBudWxsOwogIH0KCiAgdmFyIGJlZm9yZU91dCA9IFtdLCBhZnRlck91dCA9IFtdOyAgLy8gKHNwYW4gY2xhc3MsIHN0YXJ0LCBlbmQpIHRyaXBsZXMKICBvcGNvZGVzLmZvckVhY2goZnVuY3Rpb24ob3Bjb2RlKSB7CiAgICB2YXIgY2hhbmdlID0gb3Bjb2RlWzBdOwogICAgdmFyIGJlZm9yZUlkeCA9IHdvcmRUb0lkeCh0cnVlLCBvcGNvZGVbMV0pOwogICAgdmFyIGJlZm9yZUVuZCA9IHdvcmRUb0lkeCh0cnVlLCBvcGNvZGVbMl0pOwogICAgdmFyIGFmdGVySWR4ID0gd29yZFRvSWR4KGZhbHNlLCBvcGNvZGVbM10pOwogICAgdmFyIGFmdGVyRW5kID0gd29yZFRvSWR4KGZhbHNlLCBvcGNvZGVbNF0pOwogICAgaWYgKGNoYW5nZSA9PSAnZXF1YWwnKSB7CiAgICAgIGJlZm9yZU91dC5wdXNoKFtudWxsLCBiZWZvcmVJZHgsIGJlZm9yZUVuZF0pOwogICAgICBhZnRlck91dC5wdXNoKFtudWxsLCBhZnRlcklkeCwgYWZ0ZXJFbmRdKTsKICAgIH0gZWxzZSBpZiAoY2hhbmdlID09ICdkZWxldGUnKSB7CiAgICAgIGJlZm9yZU91dC5wdXNoKFsnZGVsZXRlJywgYmVmb3JlSWR4LCBiZWZvcmVFbmRdKTsKICAgIH0gZWxzZSBpZiAoY2hhbmdlID09ICdpbnNlcnQnKSB7CiAgICAgIGFmdGVyT3V0LnB1c2goWydpbnNlcnQnLCBhZnRlcklkeCwgYWZ0ZXJFbmRdKTsKICAgIH0gZWxzZSBpZiAoY2hhbmdlID09ICdyZXBsYWNlJykgewogICAgICBiZWZvcmVPdXQucHVzaChbJ2RlbGV0ZScsIGJlZm9yZUlkeCwgYmVmb3JlRW5kXSk7CiAgICAgIGFmdGVyT3V0LnB1c2goWydpbnNlcnQnLCBhZnRlcklkeCwgYWZ0ZXJFbmRdKTsKICAgIH0gZWxzZSB7CiAgICAgIHRocm93ICJJbnZhbGlkIG9wY29kZTogIiArIG9wY29kZVswXTsKICAgIH0KICB9KTsKICBiZWZvcmVPdXQgPSBkaWZmZXIuc2ltcGxpZnlDb2Rlc18oYmVmb3JlT3V0KTsKICBhZnRlck91dCA9IGRpZmZlci5zaW1wbGlmeUNvZGVzXyhhZnRlck91dCk7CgogIHJldHVybiBbYmVmb3JlT3V0LCBhZnRlck91dF07Cn07CgoKLy8gQWRkIGNoYXJhY3Rlci1ieS1jaGFyYWN0ZXIgZGlmZnMgdG8gYSByb3cgKGlmIGFwcHJvcHJpYXRlKS4KZGlmZmVyLmFkZENoYXJhY3RlckRpZmZzXyA9IGZ1bmN0aW9uKGJlZm9yZUNlbGwsIGFmdGVyQ2VsbCkgewogIHZhciBiZWZvcmVUZXh0ID0gJChiZWZvcmVDZWxsKS50ZXh0KCksCiAgICAgIGFmdGVyVGV4dCA9ICQoYWZ0ZXJDZWxsKS50ZXh0KCk7CiAgdmFyIGNvZGVzID0gZGlmZmVyLmNvbXB1dGVDaGFyYWN0ZXJEaWZmc18oYmVmb3JlVGV4dCwgYWZ0ZXJUZXh0KTsKICBpZiAoY29kZXMgPT0gbnVsbCkgcmV0dXJuOwogIGJlZm9yZU91dCA9IGNvZGVzWzBdOwogIGFmdGVyT3V0ID0gY29kZXNbMV07CgogIC8vIFNwbGljZSBpbiAiaW5zZXJ0IiwgImRlbGV0ZSIgYW5kICJyZXBsYWNlIiB0YWdzLgogIC8vIFRoaXMgaXMgbWFkZSBtb3JlIGRpZmZpY3VsdCBieSB0aGUgcHJlc2VuY2Ugb2Ygc3ludGF4IGhpZ2hsaWdodGluZywgd2hpY2gKICAvLyBoYXMgaXRzIG93biBzZXQgb2YgdGFncy4gVGhlIHR3byBjYW4gY28tZXhpc3RzIGlmIHdlJ3JlIGNhcmVmdWwgdG8gb25seQogIC8vIHdyYXAgY29tcGxldGUgKGJhbGFuY2VkKSBET00gdHJlZXMuCiAgdmFyIGJlZm9yZUh0bWwgPSAkKGJlZm9yZUNlbGwpLmh0bWwoKSwKICAgICAgYWZ0ZXJIdG1sID0gJChhZnRlckNlbGwpLmh0bWwoKTsKICB2YXIgYmVmb3JlTWFwcGVyID0gbmV3IGRpZmZlci5odG1sVGV4dE1hcHBlcihiZWZvcmVUZXh0LCBiZWZvcmVIdG1sKTsKICB2YXIgYWZ0ZXJNYXBwZXIgPSBuZXcgZGlmZmVyLmh0bWxUZXh0TWFwcGVyKGFmdGVyVGV4dCwgYWZ0ZXJIdG1sKTsKCiAgJChiZWZvcmVDZWxsKS5lbXB0eSgpLmh0bWwoZGlmZmVyLmNvZGVzVG9IdG1sXyhiZWZvcmVNYXBwZXIsIGJlZm9yZU91dCkpOwogICQoYWZ0ZXJDZWxsKS5lbXB0eSgpLmh0bWwoZGlmZmVyLmNvZGVzVG9IdG1sXyhhZnRlck1hcHBlciwgYWZ0ZXJPdXQpKTsKfTsKCi8vIGNvZGVzIGFyZSAoc3BhbiBjbGFzcywgc3RhcnQsIGVuZCkgdHJpcGxlcy4KLy8gVGhpcyBtZXJnZXMgY29uc2VjdXRpdmUgcnVucyB3aXRoIHRoZSBzYW1lIGNsYXNzLCB3aGljaCBzaW1wbGlmaWVzIHRoZSBIVE1MLgpkaWZmZXIuc2ltcGxpZnlDb2Rlc18gPSBmdW5jdGlvbihjb2RlcykgewogIHZhciBuZXdDb2RlcyA9IFtdOwogIGZvciAodmFyIGkgPSAwOyBpIDwgY29kZXMubGVuZ3RoOyBpKyspIHsKICAgIHZhciBjb2RlID0gY29kZXNbaV07CiAgICBpZiAoaSA9PSAwKSB7CiAgICAgIG5ld0NvZGVzLnB1c2goY29kZSk7CiAgICAgIGNvbnRpbnVlOwogICAgfQoKICAgIHZhciBsYXN0SW5kZXggPSBuZXdDb2Rlcy5sZW5ndGggLSAxOwogICAgdmFyIGxhc3RDb2RlQ2xhc3MgPSBuZXdDb2Rlc1tsYXN0SW5kZXhdWzBdOwogICAgaWYgKGxhc3RDb2RlQ2xhc3MgPT0gY29kZVswXSkgewogICAgICBuZXdDb2Rlc1tsYXN0SW5kZXhdWzJdID0gY29kZVsyXTsgIC8vIGV4dGVuZCBsYXN0IHJ1bi4KICAgIH0gZWxzZSB7CiAgICAgIG5ld0NvZGVzLnB1c2goY29kZSk7CiAgICB9CiAgfQoKICByZXR1cm4gbmV3Q29kZXM7Cn07CgovLyBjb2RlcyBhcmUgKHNwYW4gY2xhc3MsIHN0YXJ0LCBlbmQpIHRyaXBsZXMuCi8vIFRoaXMgd3JhcHMgaHRtbFtzdGFydC4uZW5kXSBpbiBhcHByb3ByaWF0ZSA8c3Bhbj4uLjwvc3Bhbj5zLgpkaWZmZXIuY29kZXNUb0h0bWxfID0gZnVuY3Rpb24obWFwcGVyLCBjb2RlcykgewogIHZhciBodG1sID0gJyc7CiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2Rlcy5sZW5ndGg7IGkrKykgewogICAgdmFyIGNvZGUgPSBjb2Rlc1tpXSwKICAgICAgICB0eXBlID0gY29kZVswXSwKICAgICAgICBzdGFydCA9IGNvZGVbMV0sCiAgICAgICAgbGltaXQgPSBjb2RlWzJdOwogICAgdmFyIHRoaXNIdG1sID0gbWFwcGVyLmdldEh0bWxTdWJzdHJpbmcoc3RhcnQsIGxpbWl0KTsKICAgIGlmICh0eXBlID09IG51bGwpIHsKICAgICAgaHRtbCArPSB0aGlzSHRtbDsKICAgIH0gZWxzZSB7CiAgICAgIGh0bWwgKz0gJzxzcGFuIGNsYXNzPSJjaGFyLScgKyB0eXBlICsgJyI+JyArIHRoaXNIdG1sICsgJzwvc3Bhbj4nOwogICAgfQogIH0KICByZXR1cm4gaHRtbDsKfQoKCmRpZmZlci5idWlsZFZpZXcgPSBmdW5jdGlvbihiZWZvcmVUZXh0LCBhZnRlclRleHQsIHVzZXJQYXJhbXMpIHsKICB2YXIgZCA9IG5ldyBkaWZmZXIoYmVmb3JlVGV4dCwgYWZ0ZXJUZXh0LCB1c2VyUGFyYW1zKTsKICByZXR1cm4gZC5idWlsZFZpZXdfKCk7Cn07CgovKioKICogUmV0dXJucyBhIHZhbGlkIEhpZ2hsaWdodEpTIGxhbmd1YWdlIGJhc2VkIG9uIGEgZmlsZSBuYW1lL3BhdGguCiAqIElmIGl0IGNhbid0IGd1ZXNzIGEgbGFuZ3VhZ2UsIHJldHVybnMgbnVsbC4KICovCmRpZmZlci5ndWVzc0xhbmd1YWdlVXNpbmdGaWxlTmFtZSA9IGZ1bmN0aW9uKG5hbWUpIHsKICB2YXIgbGFuZyA9IChmdW5jdGlvbigpIHsKICAgIHZhciBtID0gL1wuKFteLl0rKSQvLmV4ZWMobmFtZSk7CiAgICBpZiAobSkgewogICAgICB2YXIgZXh0ID0gbVsxXTsKICAgICAgaWYgKGV4dCA9PSAncHknKSByZXR1cm4gJ3B5dGhvbic7CiAgICAgIGlmIChleHQgPT0gJ3NoJykgcmV0dXJuICdiYXNoJzsKICAgICAgaWYgKGV4dCA9PSAnbWQnKSByZXR1cm4gJ21hcmtkb3duJzsKICAgICAgcmV0dXJuIG1bMV0udG9Mb3dlckNhc2UoKTsKICAgIH07CgogICAgLy8gSGlnaGxpZ2h0aW5nIGJhc2VkIHB1cmVseSBvbiBmaWxlIG5hbWUsIGUuZy4gIk1ha2VmaWxlIi4KICAgIG0gPSAvKD86LipcLyk/KFteXC9dKikkLy5leGVjKG5hbWUpOwogICAgaWYgKG0gJiYgbVsxXSA9PSAnTWFrZWZpbGUnKSB7CiAgICAgIHJldHVybiAnbWFrZWZpbGUnOwogICAgfQogICAgcmV0dXJuIG51bGw7CiAgfSkoKTsKICBpZiAoIWxhbmcgfHwgIWhsanMuZ2V0TGFuZ3VhZ2UobGFuZykpIHsKICAgIHJldHVybiBudWxsOwogIH0gZWxzZSB7CiAgICByZXR1cm4gbGFuZzsKICB9Cn07CgovKioKICogR3Vlc3MgYSBsYW5ndWFnZSBiYXNlZCBvbiBhIGZpbGUncyBjb250ZW50cy4KICogVGhpcyBhbHdheXMgcmV0dXJucyBhIHZhbGlkIEhpZ2hsaWdodEpTIGxhbmd1YWdlLiBJdCBjb25zaWRlcnMgdGhlIHNoZWJhbmcKICogbGluZSAoaWYgcHJlc2VudCkgYW5kIHRoZW4gZmFsbHMgYmFjayB0byBIaWdobGlnaHRKUydzIGtleXdvcmQtYmFzZWQKICogZ3Vlc3NpbmcuCiAqLwpkaWZmZXIuZ3Vlc3NMYW5ndWFnZVVzaW5nQ29udGVudHMgPSBmdW5jdGlvbihjb250ZW50cykgewogIC8vIEZpcnN0IGNoZWNrIGZvciBhIHNoZWJhbmcgbGluZS4KICB2YXIgZmlyc3RMaW5lID0gY29udGVudHMuc3Vic3RyaW5nKDAsIGNvbnRlbnRzLmluZGV4T2YoJ1xuJykpOwogIGlmIChmaXJzdExpbmUuc3Vic3RyaW5nKDAsIDIpID09ICcjIScpIHsKICAgIHZhciBwcm9jZXNzb3IgPSBmaXJzdExpbmUuc3Vic3RyaW5nKDIpOwogICAgaWYgKHByb2Nlc3NvciA9PSAnL2Jpbi9iYXNoJykgcmV0dXJuICdiYXNoJzsKICAgIGlmIChwcm9jZXNzb3IgPT0gJy9iaW4vc2gnKSByZXR1cm4gJ2Jhc2gnOwoKICAgIHZhciBvcHRpb25zID0gewogICAgICAgICdweXRob24nOiAncHl0aG9uJywKICAgICAgICAncGVybCc6ICdwZXJsJywKICAgICAgICAncnVieSc6ICdydWJ5JywKICAgICAgICAnbm9kZSc6ICdqYXZhc2NyaXB0JwogICAgfTsKICAgIGZvciAodmFyIGludGVycHJldGVyIGluIG9wdGlvbnMpIHsKICAgICAgdmFyIGxhbmcgPSBvcHRpb25zW2ludGVycHJldGVyXTsKICAgICAgaWYgKHByb2Nlc3Nvci5pbmRleE9mKGludGVycHJldGVyKSA+PSAwKSB7CiAgICAgICAgcmV0dXJuIGxhbmc7CiAgICAgIH0KICAgIH0KICB9CgogIC8vIE5vdyBsZXQgSGlnaGxpZ2h0SlMgZ3Vlc3MuCiAgdmFyIGd1ZXNzID0gaGxqcy5oaWdobGlnaHRBdXRvKGNvbnRlbnRzKTsKICB2YXIgbGFuZyA9IGd1ZXNzLmxhbmd1YWdlOwogIHJldHVybiBsYW5nOwp9OwoKcmV0dXJuIGRpZmZlcjsKCn0pKCk7Cg=="></script>
<script src="data:application/x-javascript;base64,SFRNTFdpZGdldHMud2lkZ2V0KHsKCiAgbmFtZTogJ2RpZmZyJywKCiAgdHlwZTogJ291dHB1dCcsCgogIGluaXRpYWxpemU6IGZ1bmN0aW9uKGVsLCB3aWR0aCwgaGVpZ2h0KSB7CgogICAgcmV0dXJuIHsKICAgICAgLy8gVE9ETzogYWRkIGluc3RhbmNlIGZpZWxkcyBhcyByZXF1aXJlZAogICAgfQoKICB9LAoKICByZW5kZXJWYWx1ZTogZnVuY3Rpb24oZWwsIHgsIGluc3RhbmNlKSB7CiAgICBkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93ID0gImF1dG8iOwogICAgLyoKICAgIGVsLmlubmVyVGV4dCA9IHgubWVzc2FnZTsKICAgIGVsLmlubmVyVGV4dCA9IHguZmlsZTE7CiAgICBlbC5vdXRlclRleHQgPSB4LmZpbGUyOwogICAgKi8KICAgIGNvbnNvbGUubG9nKGVsLmlkKTsKICAgIHZhciBteWlkID0gJyMnICsgZWwuaWQ7CiAgICBjb25zb2xlLmxvZyhteWlkKTsKICAgIGNvbnNvbGUubG9nKHgpOwogICAgY29uc29sZS5sb2coeC53b3JkV3JhcCk7CiAgICAvL2VsLmh0bWwoCiAgICAgICQobXlpZCkuaHRtbCgKICAgICAgICBjb2RlZGlmZi5idWlsZFZpZXcoeC5mMSwgeC5mMiwgewogICAgICAgICAgYmVmb3JlTmFtZTogeC5maWxlMSwKICAgICAgICAgIGFmdGVyTmFtZTogeC5maWxlMiwKICAgICAgICAgIGNvbnRleHRTaXplOiB4LmNvbnRleHRTaXplLAogICAgICAgICAgbWluSnVtcFNpemU6IHgubWluSnVtcFNpemUsCiAgICAgICAgICB3b3JkV3JhcDogeC53b3JkV3JhcAogICAgICAgIH0pCiAgICAgICkKICAgIC8vKQogICAgOwovKgokKGVsKS5hcHBlbmQoCiAgICAgICAgY29kZWRpZmYuYnVpbGRWaWV3KHguZjEsIHguZjIsIHsKICAgICAgICBiZWZvcmVOYW1lOiB4LmZpbGUxLAogICAgICAgIGFmdGVyTmFtZTogeC5maWxlMiwKICAgICAgICBjb250ZXh0U2l6ZTogOCwKICAgICAgICBtaW5KdW1wU2l6ZTogNSwKICAgICAgICB3b3JkV3JhcDogdHJ1ZQogICAgfSkpOwogICAgKi8KCiAgfSwKCiAgcmVzaXplOiBmdW5jdGlvbihlbCwgd2lkdGgsIGhlaWdodCwgaW5zdGFuY2UpIHsKCiAgfQoKfSk7Cg=="></script>

</head>
<body>
<div id="htmlwidget_container">
  <div id="htmlwidget-157d6f182872bd098853" style="width:960px;height:500px;" class="diffr html-widget"></div>
</div>
<script type="application/json" data-for="htmlwidget-157d6f182872bd098853">{"x":{"message":["function (..., domain = NULL, appendLF = TRUE) ","{","    args <- list(...)","    cond <- if (length(args) == 1L && inherits(args[[1L]], \"condition\")) {","        if (nargs() > 1L) ","            warning(\"additional arguments ignored in message()\")","        args[[1L]]","    }","    else {","        msg <- .makeMessage(..., domain = domain, appendLF = appendLF)","        call <- sys.call()","        simpleMessage(msg, call)","    }","    defaultHandler <- function(c) {","        cat(conditionMessage(c), file = stderr(), sep = \"\")","    }","    withRestarts({","        signalCondition(cond)","        defaultHandler(cond)","    }, muffleMessage = function() NULL)","    invisible()","}"],"contextSize":3,"minJumpSize":10,"wordWrap":true,"file1":"./amak1.tpl","file2":"./amak2.tpl","f1":"//////////////////////////////////////////////////////////////////\n// AMAK--              \n// Naming Conventions:\n//\n//  GENERAL:\n//    styr, endyr begining year and ending year of model (catch data available)\n//    nages       number of age groups considered\n//    nyrs_        number of observations available to specific data set\n//\n//  DATA SPECIFIC:\n\n//    catch_bio   Observed catch biomass\n//    fsh        fishery data\n//\n//  Define indices\n//    nind        number of indices\n//  Index values\n//    nyrs_ind      Number of years of index value (annual)\n//    yrs_ind        Years of index value (annual)\n//    obs_ind        Observed index value (annual)\n//    obs_se_ind    Observed index standard errors (annual)\n//  Age-comp values\n//    nyrs_ind_age  Number of years index age data available\n//    yrs_ind_age   Years of index age value (annual)\n//    oac_ind       Observed age comp from index\n//    n_sample_ind_age    Observed age comp sample sizes from index\n//\n//    eac_ind       Expected age comp from index\n//\n//    sel_ind       selectivity for egg production index\n//\n//    pred_ind ...\n//\n//    oac_fsh      Observed age comp from index\n//    obs_ind_size  Observed size comp from index\n//\n//    pred_fsh_age    Predicted age comp from fishery data\n//    eac_fsh            Expected age comp for fishery data (only years where data available)\n//    eac_ ...\n//\n//    pred_tmp_ind   Predicted index value for trawl index\n//\n//    sel_fsh    selectivity for fishery                \n//  \n//     sel_ch indicates time-varying selectivity change\n//  \n//    Add bit for historical F\n//    Added length part for selectivity\n//\n//////////////////////////////////////////////////////////////////////////////\n // To ADD/FIX:\n //   parameterization of steepness to work the same (wrt prior) for ricker and bholt\n //   splines for selectivity\n //   two projection outputs need consolidation\n//////////////////////////////////////////////////////////////////////////////\n\nDATA_SECTION\n  !!version_info+=\"AMAK;Jan 2020\";\n  int iseed \n  !! iseed=1313;\n  int cmp_no // candidate management procedure\n  int nnodes_tmp;\n  !!CLASS ofstream mceval(\"mceval.dat\")\n  !!CLASS ofstream mceval_sr(\"mceval_sr.dat\")\n  !!CLASS ofstream mceval_R(\"mceval_R.dat\")\n  !!CLASS ofstream mceval_srv(\"mceval_srv.dat\")\n  !!CLASS ofstream mceval_M(\"mceval_M.dat\")\n  !!CLASS ofstream mceval_proj(\"mceval_proj.dat\")\n  !!long int lseed=iseed;\n  !!CLASS random_number_generator rng(iseed);\n  \n  int oper_mod\n  int mcmcmode\n  int mcflag\n\n  !! oper_mod = 0;\n  !! mcmcmode = 0;\n  !! mcflag   = 1;\n LOCAL_CALCS\n  write_input_log<<version_info<<endl;\n  tmpstring=adprogram_name + adstring(\".dat\");\n  int on=0;\n  if ( (on=option_match(argc,argv,\"-ind\"))>-1)\n  {\n    if (on>argc-2 | argv[on+1][0] == '-') \n    { \n      cerr << \"Invalid input data command line option\"\n         \" -- ignored\" << endl;  \n    }\n    else\n    {\n      cntrlfile_name = adstring(argv[on+1]);\n    }\n  }\n  else\n  {\n      cntrlfile_name =   tmpstring;\n  }\n  if ( (on=option_match(argc,argv,\"-om\"))>-1)\n  {\n    oper_mod  = 1;\n    cmp_no = atoi(argv[on+1]);\n    cout<<\"Got to operating model option \"<<oper_mod<<endl;\n  }\n  if ( (on=option_match(argc,argv,\"-mcmc\"))>-1)\n  {\n    mcmcmode = 1;\n  }\n  global_datafile= new cifstream(cntrlfile_name);\n  if (!global_datafile)\n  {\n  }\n  else\n  {\n    if (!(*global_datafile))\n    {\n      delete global_datafile;\n      global_datafile=NULL;\n    }\n  }\n END_CALCS\n // Read in \"name\" of this model...\n  !! *(ad_comm::global_datafile) >>  datafile_name; // First line is datafile (not used by this executable)\n  !! *(ad_comm::global_datafile) >>  model_name; \n  !! ad_comm::change_datafile_name(datafile_name);\n  init_int styr\n  init_int endyr\n  init_int rec_age\n  init_int oldest_age\n  !! log_input(styr);\n  !! log_input(endyr);\n  !! log_input(rec_age);\n  !! log_input(oldest_age);\n//------------LENGTH INTERVALS\n  init_int nlength\n  init_vector len_bins(1,nlength)\n  !! log_input(nlength);\n  !! log_input(len_bins);\n\n  int nages\n  !!  nages = oldest_age - rec_age + 1;\n  int styr_rec\n  int styr_sp\n  int endyr_sp\n  int nyrs\n  !! nyrs          = endyr - styr + 1;\n  int mc_count;\n  !!  mc_count=0;\n  !! styr_rec = (styr - nages) ;     // First year of recruitment\n  !! styr_sp  = styr_rec - rec_age - 1 ;    // First year of spawning biomass  \n  vector yy(styr,endyr);\n  !! yy.fill_seqadd(styr,1) ;\n  vector aa(1,nages);\n  !! aa.fill_seqadd(rec_age,1) ;\n  int junk;\n// Fishery specifics\n  init_int nfsh                                   //Number of fisheries\n  imatrix pfshname(1,nfsh,1,2)\n  init_adstring fshnameread;\n LOCAL_CALCS\n  for(k=1;k<=nfsh;k++) \n  {\n    pfshname(k,1)=1; \n    pfshname(k,2)=1;\n  }    // set whole array to equal 1 in case not enough names are read\n  adstring_array CRLF;   // blank to terminate lines\n  CRLF+=\"\";\n  k=1;\n  for(i=1;i<=strlen(fshnameread);i++)\n  if(adstring(fshnameread(i))==adstring(\"%\")) {\n    pfshname(k,2)=i-1; \n    k++;  \n    pfshname(k,1)=i+1;\n  }\n  pfshname(nfsh,2)=strlen(fshnameread);\n  for(k=1;k<=nfsh;k++)\n  {\n    fshname += fshnameread(pfshname(k,1),pfshname(k,2))+CRLF(1);\n  }\n  log_input(datafile_name);\n  log_input(model_name);\n  log_input(styr);\n  log_input(endyr);\n  log_input(rec_age);\n  log_input(oldest_age);\n  log_input(nfsh);\n  log_input(fshname);\n END_CALCS\n  init_matrix catch_bio_in(1,nfsh,styr,endyr)\n  init_matrix catch_bio_sd_in(1,nfsh,styr,endyr)   // Specify catch-estimation precision\n  // !! for (i=1;i<=nfsh;i++) catch_bio(i) += .01; \n  !! log_input(catch_bio_in);\n  !! log_input(catch_bio_sd_in);\n\n\n//  Define fishery age compositions\n  init_ivector nyrs_fsh_age(1,nfsh)\n  !! log_input(nyrs_fsh_age);\n  init_ivector nyrs_fsh_length(1,nfsh)\n  !! log_input(nyrs_fsh_length);\n  init_imatrix yrs_fsh_age_in(1,nfsh,1,nyrs_fsh_age)\n  !! log_input(yrs_fsh_age_in);\n  init_imatrix yrs_fsh_length_in(1,nfsh,1,nyrs_fsh_length)\n  !! log_input(yrs_fsh_length_in);\n  init_matrix n_sample_fsh_age_in(1,nfsh,1,nyrs_fsh_age)    //Years of index index value (annual)\n  init_matrix n_sample_fsh_length_in(1,nfsh,1,nyrs_fsh_length)    //Years of index index value (annual)\n  !! log_input(n_sample_fsh_length_in);\n  init_3darray oac_fsh_in(1,nfsh,1,nyrs_fsh_age,1,nages)\n  init_3darray olc_fsh_in(1,nfsh,1,nyrs_fsh_length,1,nlength)\n  !! log_input(olc_fsh_in);\n  init_3darray wt_fsh(1,nfsh,styr,endyr,1,nages)  //values of weights at age\n\n//  Define indices\n  init_int nind                                   //number of indices\n  !! log_input(nind);\n  int nfsh_and_ind\n  !! nfsh_and_ind = nfsh+nind;\n  imatrix pindname(1,nind,1,2)\n  init_adstring indnameread;\n LOCAL_CALCS\n  for(int k=1;k<=nind;k++) \n  {\n    pindname(k,1)=1; \n    pindname(k,2)=1;\n  }    // set whole array to equal 1 in case not enough names are read\n  int k=1;\n  for(i=1;i<=strlen(indnameread);i++)\n  if(adstring(indnameread(i))==adstring(\"%\")) {\n    pindname(k,2)=i-1; \n    k++;  \n    pindname(k,1)=i+1;\n  }\n  pindname(nind,2)=strlen(indnameread);\n  for(k=1;k<=nind;k++)\n  {\n    indname += indnameread(pindname(k,1),pindname(k,2))+CRLF(1);\n  }\n  log_input(indname);\n END_CALCS\n\n//  Index values\n  init_ivector nyrs_ind(1,nind)                   //Number of years of index value (annual)\n  init_imatrix yrs_ind_in(1,nind,1,nyrs_ind)         //Years of index value (annual)\n  init_vector mo_ind(1,nind)                      //Month occur \n  init_matrix obs_ind_in(1,nind,1,nyrs_ind)          //values of index value (annual)\n  init_matrix obs_se_ind_in(1,nind,1,nyrs_ind)       //values of indices serrs\n\n  vector ind_month_frac(1,nind)\n  !! log_input(nyrs_ind);\n  !! log_input(yrs_ind_in);\n  !! log_input(mo_ind);\n  !! ind_month_frac = (mo_ind-1.)/12.;\n  !! log_input(obs_ind_in);\n  !! log_input(obs_se_ind_in);\n  matrix        corr_dev(1,nind,1,nyrs_ind) //Index standard errors (for lognormal)\n  matrix        corr_eff(1,nfsh,styr,endyr) //Index standard errors (for lognormal)\n  matrix         act_eff(1,nfsh,styr,endyr) //Index standard errors (for lognormal)\n  vector              ac(1,nind);\n\n  init_ivector nyrs_ind_age(1,nind)               //Number of years of index value (annual)\n  !! log_input(nyrs_ind_age);\n\n  init_ivector nyrs_ind_length(1,nind)\n  !! log_input(nyrs_ind_length);\n\n  init_imatrix yrs_ind_age_in(1,nind,1,nyrs_ind_age)  //Years of index value (annual)\n  !! log_input(yrs_ind_age_in);\n\n  init_imatrix yrs_ind_length_in(1,nind,1,nyrs_ind_length)\n  !! log_input(yrs_ind_length_in);\n\n  init_matrix n_sample_ind_age_in(1,nind,1,nyrs_ind_age)         //Years of index value (annual)\n  !! log_input(yrs_ind_age_in);\n\n  init_matrix n_sample_ind_length_in(1,nind,1,nyrs_ind_length)         //Years of index lengths (annual)\n  !! log_input(n_sample_ind_length_in);\n\n  init_3darray oac_ind_in(1,nind,1,nyrs_ind_age,1,nages);  //values of Index proportions at age\n  init_3darray olc_ind_in(1,nind,1,nyrs_ind_length,1,nlength);\n  !! log_input(olc_ind_in);\n\n  !! log_input(oac_ind_in);\n  init_3darray  wt_ind(1,nind,styr,endyr,1,nages)      //values of Index proportions at age\n  !! log_input(wt_ind);\n\n  vector age_vector(1,nages);\n  !! for (j=1;j<=nages;j++)\n  !!  age_vector(j) = double(j+rec_age-1);\n  init_vector wt_pop(1,nages)\n  !! log_input(wt_pop);\n  init_vector maturity(1,nages)\n  !! log_input(maturity);\n  !! if (max(maturity)>.9) maturity /=2.;\n  vector wt_mature(1,nages);\n  !! wt_mature = elem_prod(wt_pop,maturity) ;\n\n  //Spawning month-----\n  init_number spawnmo\n  !! log_input(spawnmo);\n  number spmo_frac\n  !! spmo_frac = (spawnmo-1)/12.;\n\n  init_matrix age_err(1,nages,1,nages)\n  !! log_input(age_err);\n\n  int k // Index for fishery or index\n  int i // Index for year\n  int j // Index for age\n LOCAL_CALCS\n  // Rename data file to the control data section... \n  ad_comm::change_datafile_name(cntrlfile_name);\n  *(ad_comm::global_datafile) >>  datafile_name; \n  *(ad_comm::global_datafile) >>  model_name; \n  log_input(cntrlfile_name);\n END_CALCS\n  // Matrix of selectivity mappings--row 1 is type (1=fishery, 2=index) and row 2 is index within that type\n  //  e.g., the following for 2 fisheries and 4 indices means that index 3 uses fishery 1 selectivities,\n  //         the other fisheries and indices use their own parameterization\n  //  1 1 2 2 1 2 \n  //  1 2 1 2 1 4\n  init_imatrix sel_map(1,2,1,nfsh_and_ind) \n  // maps fisheries and indices into sequential sel_map for sharing purposes\n  !! write_input_log<< \"# Map shared selectivity: \"<< endl;log_input(sel_map);\n  !! log_input(datafile_name);\n  !! log_input(model_name);\n  !! projfile_name = cntrlfile_name(1,length(cntrlfile_name)-4) + \".prj\";\n\n  \n  init_int    SrType        // 2 Bholt, 1 Ricker\n  !! log_input(SrType);\n  init_int use_age_err      // nonzero value means use...\n  !! log_input(use_age_err);\n  init_int retro            // Retro years to peel off (0 means full dataset)\n  !! log_input(retro);\n  init_number steepnessprior\n  init_number cvsteepnessprior\n  init_int    phase_srec\n\n  init_number sigmarprior\n  number log_sigmarprior\n  init_number cvsigmarprior\n  init_int    phase_sigmar\n  !! log_input(sigmarprior);\n  !! log_input(cvsigmarprior);\n  !! log_input(phase_sigmar);\n  init_int    styr_rec_est\n  init_int    endyr_rec_est\n  !! log_input(styr_rec_est);\n  !! log_input(endyr_rec_est);\n  int nrecs_est;\n\n//-----GROWTH PARAMETERS--------------------------------------------------\n  init_number Linfprior\n  init_number cvLinfprior\n  init_int    phase_Linf\n  number log_Linfprior\n  !! log_Linfprior = log(Linfprior);\n  !! log_input(Linfprior)\n  !! log_input(cvLinfprior)\n\n  init_number kprior\n  init_number cvkprior\n  init_int    phase_k\n  number log_kprior\n  !! log_kprior = log(kprior);\n  !! log_input(kprior)\n  !! log_input(cvkprior)\n\n  init_number Loprior\n  init_number cvLoprior\n  init_int    phase_Lo\n  number log_Loprior\n  !! log_Loprior = log(Loprior);\n  !! log_input(Loprior)\n  !! log_input(cvLoprior)\n\n  init_number sdageprior\n  init_number cvsdageprior\n  init_int    phase_sdage\n  number log_sdageprior\n  !! log_sdageprior = log(sdageprior);\n  !! log_input(sdageprior)\n  !! log_input(cvsdageprior)\n\n//---------------------------------------------------------------------------\n  // Basic M\n  init_number natmortprior\n  init_number cvnatmortprior\n  init_int    phase_M\n  !! log_input(natmortprior);\n  !! log_input(cvnatmortprior);\n  !! log_input(phase_M);\n\n  // age-specific M\n  init_int     npars_Mage\n  init_ivector ages_M_changes(1,npars_Mage)\n  init_vector  Mage_in(1,npars_Mage)\n  init_int     phase_Mage\n  vector       Mage_offset_in(1,npars_Mage)\n  // convert inputs to offsets from prior for initialization purposes\n  !! if (npars_Mage>0) Mage_offset_in = log(Mage_in / natmortprior);\n  !! log_input(npars_Mage);\n  !! log_input(ages_M_changes);\n  !! log_input(Mage_in);\n  !! log_input(Mage_offset_in);\n  !! log_input(phase_Mage);\n\n  // time-varying M\n  init_int    phase_rw_M\n  init_int npars_rw_M\n  init_ivector  yrs_rw_M(1,npars_rw_M);\n  init_vector sigma_rw_M(1,npars_rw_M)\n LOCAL_CALCS\n  log_input(phase_rw_M);\n  log_input(npars_rw_M);\n  log_input(yrs_rw_M);\n  log_input(sigma_rw_M);\n END_CALCS\n\n  init_vector qprior(1,nind)      \n  vector log_qprior(1,nind)      \n  init_vector cvqprior(1,nind)     \n  init_ivector phase_q(1,nind)\n  init_vector q_power_prior(1,nind)      \n  vector log_q_power_prior(1,nind)      \n  init_vector cvq_power_prior(1,nind)     \n  init_ivector phase_q_power(1,nind)\n  // Random walk definition for indices\n  init_ivector phase_rw_q(1,nind)\n  init_ivector npars_rw_q(1,nind)\n  init_imatrix  yrs_rw_q(1,nind,1,npars_rw_q); // Ragged array\n  init_matrix sigma_rw_q(1,nind,1,npars_rw_q); // Ragged array\n LOCAL_CALCS\n  log_input(qprior);\n  log_input(cvqprior);\n  log_input(phase_q);\n  log_input(q_power_prior);\n  log_input(cvq_power_prior);\n  log_input(phase_q_power);\n\n  log_input(phase_rw_q);\n  log_input(npars_rw_q);\n  log_input(yrs_rw_q);\n  log_input(sigma_rw_q);\n END_CALCS\n\n  init_ivector    q_age_min(1,nind)     // Age that q relates to...\n  init_ivector    q_age_max(1,nind)     // Age that q relates to...\n  !! log_input(q_age_min);\n  !! log_input(q_age_max);\n  // Need to map to age index range...\n  !! for (k=1;k<=nind;k++) {q_age_min(k) =  q_age_min(k) - rec_age + 1; q_age_max(k) = q_age_max(k) - rec_age + 1;}\n  !! log_input(q_age_min);\n  !! log_input(q_age_max);\n\n  init_number cv_catchbiomass\n  number catchbiomass_pen\n  !!catchbiomass_pen= 1./(2*cv_catchbiomass*cv_catchbiomass);\n  init_int nproj_yrs\n\n  int styr_fut\n  int endyr_fut            // LAst year for projections\n  int phase_Rzero\n  int phase_nosr\n  number Steepness_UB\n  !! phase_Rzero =  4;\n  !! phase_nosr  = -3;\n\n  // Selectivity controls\n  // read in options for each fishery\n  // Loop over fisheries and indices to read in data (conditional on sel_options)\n  ivector   fsh_sel_opt(1,nfsh)\n  ivector phase_sel_fsh(1,nfsh)\n  vector   curv_pen_fsh(1,nfsh)\n  matrix   sel_slp_in_fsh(1,nfsh,1,nyrs)\n  matrix   logsel_slp_in_fsh(1,nfsh,1,nyrs)\n  matrix   sel_inf_in_fsh(1,nfsh,1,nyrs)\n  vector   logsel_slp_in_fshv(1,nfsh)\n  vector   sel_inf_in_fshv(1,nfsh)\n\n  matrix   logsel_p1_in_fsh(1,nfsh,1,nyrs)\n  vector   logsel_p1_in_fshv(1,nfsh)\n  matrix   sel_p1_in_fsh(1,nfsh,1,nyrs)\n\n  matrix   sel_p2_in_fsh(1,nfsh,1,nyrs)\n  vector   sel_p2_in_fshv(1,nfsh)\n\n  matrix   logsel_p3_in_fsh(1,nfsh,1,nyrs)\n  vector   logsel_p3_in_fshv(1,nfsh)\n  matrix   sel_p3_in_fsh(1,nfsh,1,nyrs)\n\n  matrix   logsel_dslp_in_fsh(1,nfsh,1,nyrs)\n  matrix   sel_dinf_in_fsh(1,nfsh,1,nyrs)\n\n  vector seldec_pen_fsh(1,nfsh) ;\n  vector nnodes_fsh(1,nfsh) ;\n  int seldecage ;\n  !! seldecage = int(nages/2);\n  ivector nselages_in_fsh(1,nfsh)\n\n  ivector n_sel_ch_fsh(1,nfsh);\n  ivector n_sel_ch_ind(1,nind);\n  imatrix yrs_sel_ch_tmp(1,nind,1,endyr-styr+1);\n  imatrix yrs_sel_ch_tmp_ind(1,nind,1,endyr-styr+1);\n  !! yrs_sel_ch_tmp_ind.initialize();\n\n  ivector   ind_sel_opt(1,nind)\n  ivector phase_sel_ind(1,nind)\n\n  vector   curv_pen_ind(1,nind)\n\n  matrix   logsel_slp_in_ind(1,nind,1,nyrs)\n  matrix   sel_inf_in_ind(1,nind,1,nyrs)\n  matrix   sel_dslp_in_ind(1,nind,1,nyrs)\n  matrix   logsel_dslp_in_ind(1,nind,1,nyrs)\n  matrix   sel_dinf_in_ind(1,nind,1,nyrs)\n  matrix   sel_slp_in_ind(1,nind,1,nyrs)\n\n  vector   logsel_slp_in_indv(1,nind)\n  vector   sel_inf_in_indv(1,nind)\n  vector   logsel_dslp_in_indv(1,nind)\n  vector   sel_dinf_in_indv(1,nind)\n\n\n  vector seldec_pen_ind(1,nind) ;\n  matrix sel_change_in_ind(1,nind,styr,endyr);\n  ivector nselages_in_ind(1,nind)\n  matrix sel_change_in_fsh(1,nfsh,styr,endyr);\n  imatrix yrs_sel_ch_fsh(1,nfsh,1,endyr-styr);\n  matrix sel_sigma_fsh(1,nfsh,1,endyr-styr);\n  imatrix yrs_sel_ch_ind(1,nind,1,endyr-styr);\n  matrix sel_sigma_ind(1,nind,1,endyr-styr);\n  !! yrs_sel_ch_fsh.initialize();\n  !! yrs_sel_ch_ind.initialize();\n  !! sel_sigma_fsh.initialize();\n  !! sel_sigma_ind.initialize();\n\n  // Phase of estimation\n  ivector phase_selcoff_fsh(1,nfsh)\n  ivector phase_logist_fsh(1,nfsh)\n  ivector phase_dlogist_fsh(1,nfsh)\n  ivector phase_sel_spl_fsh(1,nfsh)\n\n  ivector phase_selcoff_ind(1,nind)\n  ivector phase_logist_ind(1,nind)\n  ivector phase_dlogist_ind(1,nind)\n  vector  sel_fsh_tmp(1,nages); \n  vector  sel_ind_tmp(1,nages); \n  3darray log_selcoffs_fsh_in(1,nfsh,1,nyrs,1,nages)\n  3darray log_selcoffs_ind_in(1,nind,1,nyrs,1,nages)\n  3darray  log_sel_spl_fsh_in(1,nfsh,1,nyrs,1,nages) // use nages for input to start\n  // 3darray log_selcoffs_ind_in(1,nind,1,nyrs,1,nages)\n\n LOCAL_CALCS\n  logsel_slp_in_fshv.initialize();\n  sel_inf_in_fshv.initialize();\n  logsel_p1_in_fshv.initialize();\n  sel_p2_in_fshv.initialize();\n  logsel_p3_in_fshv.initialize();\n\n  sel_inf_in_indv.initialize();\n  logsel_dslp_in_indv.initialize();\n  sel_inf_in_indv.initialize();\n  sel_dinf_in_indv.initialize();\n\n  phase_selcoff_ind.initialize();\n  phase_logist_ind.initialize();\n  phase_dlogist_ind.initialize();\n  sel_fsh_tmp.initialize() ;\n  sel_ind_tmp.initialize() ;\n  log_selcoffs_fsh_in.initialize();\n  log_selcoffs_ind_in.initialize();\n\n  // nselages_in_fsh.initialize()   ;  \n  // nselages_in_ind.initialize()   ;  \n  nselages_in_fsh = nages-1;\n  nselages_in_ind = nages-1;\n  sel_change_in_ind.initialize()   ;  \n  sel_slp_in_fsh.initialize()   ;  // ji\n  sel_slp_in_ind.initialize()   ;  // ji\n  sel_inf_in_fsh.initialize()   ;  // ji\n  sel_inf_in_ind.initialize()   ;  // ji\n  logsel_slp_in_fsh.initialize();  // ji\n  logsel_slp_in_fshv.initialize(); // ji\n  logsel_dslp_in_fsh.initialize(); // ji\n  logsel_slp_in_ind.initialize();  // ji\n  logsel_slp_in_indv.initialize(); // ji\n  logsel_dslp_in_ind.initialize(); // ji\n  sel_change_in_fsh.initialize()   ;  \n  for (k=1;k<=nfsh;k++)\n  {\n    *(ad_comm::global_datafile) >> fsh_sel_opt(k)  ;  \n    log_input(fsh_sel_opt(k));\n    switch (fsh_sel_opt(k))\n    {\n      case 1 : // Selectivity coefficients \n      {\n        *(ad_comm::global_datafile) >> nselages_in_fsh(k)   ;  \n        *(ad_comm::global_datafile) >> phase_sel_fsh(k);  \n        *(ad_comm::global_datafile) >> curv_pen_fsh(k) ;\n        *(ad_comm::global_datafile) >> seldec_pen_fsh(k) ;\n        seldec_pen_fsh(k) *= seldec_pen_fsh(k) ;\n        *(ad_comm::global_datafile) >>  n_sel_ch_fsh(k) ;  \n        n_sel_ch_fsh(k) +=1;\n        yrs_sel_ch_fsh(k,1) = styr; // first year always estimated\n        for (int i=2;i<=n_sel_ch_fsh(k);i++)\n          *(ad_comm::global_datafile) >>  yrs_sel_ch_fsh(k,i) ;  \n        for (int i=2;i<=n_sel_ch_fsh(k);i++)\n          *(ad_comm::global_datafile) >>  sel_sigma_fsh(k,i) ;  \n        log_input(nselages_in_fsh(k)) ;  \n        log_input(phase_sel_fsh(k)) ;  \n        log_input(curv_pen_fsh(k)) ;  \n        log_input(seldec_pen_fsh(k)) ;  \n        log_input(n_sel_ch_fsh(k)) ;  \n        log_input(yrs_sel_ch_fsh(k)) ;  \n        log_input(sel_sigma_fsh(k)) ;  \n        // for (int i=styr;i<=endyr;i++) *(ad_comm::global_datafile) >> sel_change_in_fsh(k,i) ;\n        sel_change_in_fsh(k,styr)=1.; \n       // Number of selectivity changes is equal to the number of vectors (yr 1 is baseline)\n        // This to read in pre-specified selectivity values...\n        sel_fsh_tmp.initialize();\n        log_selcoffs_fsh_in.initialize();\n        for (int j=1;j<=nages;j++) \n          *(ad_comm::global_datafile) >> sel_fsh_tmp(j);  \n        for (int jj=2;jj<=n_sel_ch_fsh(k);jj++) \n        {\n          // Set the selectivity for the oldest group\n          for (int j=nselages_in_fsh(k)+1;j<=nages;j++) \n          {\n            sel_fsh_tmp(j)  = sel_fsh_tmp(nselages_in_fsh(k));  \n          }\n          // Set tmp to actual initial vectors...\n          log_selcoffs_fsh_in(k,jj)(1,nselages_in_fsh(k)) = log((sel_fsh_tmp(1,nselages_in_fsh(k))+1e-7)/mean(sel_fsh_tmp(1,nselages_in_fsh(k))+1e-7) );\n          write_input_log<<\"Sel_in_fsh \"<< mfexp(log_selcoffs_fsh_in(k,jj))<<endl;\n        }\n        // exit(1);\n        phase_selcoff_fsh(k) = phase_sel_fsh(k);\n        phase_logist_fsh(k)  = -1;\n        phase_dlogist_fsh(k) = -1;\n        phase_sel_spl_fsh(k) = -1;\n      }\n        break;\n      case 2 : // Single logistic\n      {\n        *(ad_comm::global_datafile) >> phase_sel_fsh(k);  \n        *(ad_comm::global_datafile) >>  n_sel_ch_fsh(k) ;  \n        n_sel_ch_fsh(k) +=1;\n        yrs_sel_ch_fsh(k,1) = styr;\n        for (int i=2;i<=n_sel_ch_fsh(k);i++)\n          *(ad_comm::global_datafile) >>  yrs_sel_ch_fsh(k,i) ;  \n        for (int i=2;i<=n_sel_ch_fsh(k);i++)\n          *(ad_comm::global_datafile) >>  sel_sigma_fsh(k,i) ;  \n        // This to read in pre-specified selectivity values...\n        *(ad_comm::global_datafile) >> sel_slp_in_fsh(k,1) ;\n        *(ad_comm::global_datafile) >> sel_inf_in_fsh(k,1) ;\n        logsel_slp_in_fsh(k,1)   = log(sel_slp_in_fsh(k,1)) ;\n        for (int jj=2;jj<=n_sel_ch_fsh(k);jj++) \n        {\n          sel_inf_in_fsh(k,jj)    =     sel_inf_in_fsh(k,1) ;\n          logsel_slp_in_fsh(k,jj) = log(sel_slp_in_fsh(k,1)) ;\n        }\n        log_input(phase_sel_fsh(k));\n        log_input(n_sel_ch_fsh(k));\n        log_input(sel_slp_in_fsh(k)(1,n_sel_ch_fsh(k)));\n        log_input(sel_inf_in_fsh(k)(1,n_sel_ch_fsh(k)));\n        log_input(logsel_slp_in_fsh(k)(1,n_sel_ch_fsh(k)));\n        log_input(yrs_sel_ch_fsh(k)(1,n_sel_ch_fsh(k)));\n\n        phase_selcoff_fsh(k) = -1;\n        phase_logist_fsh(k) = phase_sel_fsh(k);\n        phase_dlogist_fsh(k) = -1;\n        phase_sel_spl_fsh(k) = -1;\n\n        logsel_slp_in_fshv(k) = logsel_slp_in_fsh(k,1);\n           sel_inf_in_fshv(k) =    sel_inf_in_fsh(k,1);\n        break;\n      }\n      case 3 : // Double logistic \n      {\n        *(ad_comm::global_datafile) >> nselages_in_fsh(k)   ;  \n        *(ad_comm::global_datafile) >> phase_sel_fsh(k);  \n        *(ad_comm::global_datafile) >>  n_sel_ch_fsh(k) ;  \n        n_sel_ch_fsh(k) +=1;\n        yrs_sel_ch_fsh(k,1) = styr;\n        for (int i=2;i<=n_sel_ch_fsh(k);i++)\n          *(ad_comm::global_datafile) >>  yrs_sel_ch_fsh(k,i) ;  \n        for (int i=2;i<=n_sel_ch_fsh(k);i++)\n          *(ad_comm::global_datafile) >>  sel_sigma_fsh(k,i) ;  \n        // This to read in pre-specified selectivity values...\n        *(ad_comm::global_datafile) >> sel_p1_in_fsh(k,1) ; // asc inflection\n        *(ad_comm::global_datafile) >> sel_p2_in_fsh(k,1) ; // ages to 95% selected (added to p1\n        *(ad_comm::global_datafile) >> sel_p3_in_fsh(k,1) ; // ages to desc infl\n\n        // Put initial param scale here logsel_slp_in_fsh(k,1)   = log(sel_slp_in_fsh(k,1)) ;\n        for (int jj=2;jj<=n_sel_ch_fsh(k);jj++) \n        {\n          sel_p1_in_fsh(k,jj)    =     sel_p1_in_fsh(k,1) ;\n          sel_p2_in_fsh(k,jj)    =     sel_p2_in_fsh(k,1) ;\n          sel_p3_in_fsh(k,jj)    =     sel_p3_in_fsh(k,1) ;\n        }\n        logsel_p1_in_fsh(k) =  log(sel_p1_in_fsh(k)) ;\n        logsel_p3_in_fsh(k) =  log(sel_p3_in_fsh(k)) ;\n\n        log_input(phase_sel_fsh(k));\n        log_input(n_sel_ch_fsh(k));\n        log_input(sel_p1_in_fsh(k)(1,n_sel_ch_fsh(k)));\n        log_input(sel_p2_in_fsh(k)(1,n_sel_ch_fsh(k)));\n        log_input(sel_p3_in_fsh(k)(1,n_sel_ch_fsh(k)));\n        log_input(yrs_sel_ch_fsh(k)(1,n_sel_ch_fsh(k)));\n\n        phase_selcoff_fsh(k) = -1;\n        phase_logist_fsh(k)  = -1;\n        phase_dlogist_fsh(k) = phase_sel_fsh(k);\n        phase_sel_spl_fsh(k) = -1;\n\n        logsel_p1_in_fshv(k) = logsel_p1_in_fsh(k,1);\n           sel_p2_in_fshv(k) =    sel_p2_in_fsh(k,1);\n        logsel_p3_in_fshv(k) = logsel_p3_in_fsh(k,1);\n\n        logsel_slp_in_fshv(k) = logsel_slp_in_fsh(k,1);\n           sel_inf_in_fshv(k) =    sel_inf_in_fsh(k,1);\n        write_input_log << \"Double logistic read in...\"<<endl;\n        break;\n      }\n      case 4 : // Splines         \n      {\n      }\n      break;\n      write_input_log << fshname(k)<<\" fish sel opt \"<<endl<<fsh_sel_opt(k)<<\" \"<<endl<<\"Sel_change\"<<endl<<sel_change_in_fsh(k)<<endl;\n    }\n  }\n  // Indices here..............\n  yrs_sel_ch_ind.initialize() ;  \n  sel_sigma_ind.initialize();\n  for(k=1;k<=nind;k++)\n  {\n    *(ad_comm::global_datafile) >> ind_sel_opt(k)  ;  \n    write_input_log << endl<<\"Survey \"<<indname(k)<<endl;\n    log_input(ind_sel_opt(k));\n    switch (ind_sel_opt(k))\n    {\n      case 1 : // Selectivity coefficients  indices\n      {\n        *(ad_comm::global_datafile) >> nselages_in_ind(k)   ;  \n        *(ad_comm::global_datafile) >> phase_sel_ind(k);  \n        *(ad_comm::global_datafile) >> curv_pen_ind(k) ;\n        *(ad_comm::global_datafile) >> seldec_pen_ind(k) ;\n        seldec_pen_ind(k) *= seldec_pen_ind(k);\n        *(ad_comm::global_datafile) >>  n_sel_ch_ind(k) ;  \n        n_sel_ch_ind(k)+=1;\n        yrs_sel_ch_ind(k,1) = styr;\n        yrs_sel_ch_tmp_ind(k,1) = styr;\n        for (int i=2;i<=n_sel_ch_ind(k);i++)\n          *(ad_comm::global_datafile) >>  yrs_sel_ch_ind(k,i) ;  \n        for (int i=2;i<=n_sel_ch_ind(k);i++)\n          *(ad_comm::global_datafile) >>  sel_sigma_ind(k,i) ;  \n        sel_change_in_ind(k,styr)=1.; \n       // Number of selectivity changes is equal to the number of vectors (yr 1 is baseline)\n        log_input(indname(k));\n        log_input(nselages_in_ind(k));\n        log_input(phase_sel_ind(k));\n        log_input(seldec_pen_ind(k));\n        log_input(n_sel_ch_ind(k));\n        log_input(sel_change_in_ind(k));\n        log_input(n_sel_ch_ind(k));\n        // log_input(yrs_sel_ch_ind(k)(1,n_sel_ch_ind(k)));\n        log_input(yrs_sel_ch_ind(k));\n        // This to read in pre-specified selectivity values...\n        for (j=1;j<=nages;j++) \n          *(ad_comm::global_datafile) >> sel_ind_tmp(j);  \n        log_input(sel_ind_tmp);\n        log_selcoffs_ind_in(k,1)(1,nselages_in_ind(k)) = log((sel_ind_tmp(1,nselages_in_ind(k))+1e-7)/mean(sel_fsh_tmp(1,nselages_in_ind(k))+1e-7) );\n        // set all change selectivity to initial values\n        for (int jj=2;jj<=n_sel_ch_ind(k);jj++) \n        {\n          for (int j=nselages_in_ind(k)+1;j<=nages;j++) // This might be going out of nages=nselages\n          {\n            sel_ind_tmp(j)  = sel_ind_tmp(nselages_in_ind(k));  \n          }\n          // Set tmp to actual initial vectors...\n          log_selcoffs_ind_in(k,jj)(1,nselages_in_ind(k)) = log((sel_ind_tmp(1,nselages_in_ind(k))+1e-7)/mean(sel_fsh_tmp(1,nselages_in_ind(k))+1e-7) );\n          write_input_log<<\"Sel_in_ind \"<< mfexp(log_selcoffs_ind_in(k,jj))<<endl;\n        }\n        phase_selcoff_ind(k) = phase_sel_ind(k);\n        phase_logist_ind(k)  = -2;\n        phase_dlogist_ind(k) = -1;\n      }\n      break;\n      case 2 : // Single logistic\n      {\n        *(ad_comm::global_datafile) >> phase_sel_ind(k);  \n        *(ad_comm::global_datafile) >>  n_sel_ch_ind(k) ;  \n        n_sel_ch_ind(k) +=1;\n        yrs_sel_ch_ind(k,1) = styr; // first year always estimated\n        yrs_sel_ch_tmp_ind(k,1) = styr;\n        for (int i=2;i<=n_sel_ch_ind(k);i++)\n          *(ad_comm::global_datafile) >>  yrs_sel_ch_ind(k,i) ;  \n        for (int i=2;i<=n_sel_ch_ind(k);i++)\n          *(ad_comm::global_datafile) >>  sel_sigma_ind(k,i) ;  \n        sel_change_in_ind(k,styr)=1.; \n\n        log_input(indname(k));\n        log_input(nselages_in_ind(k));\n        log_input(phase_sel_ind(k));\n        log_input(sel_change_in_ind(k));\n        log_input(n_sel_ch_ind(k));\n        log_input(yrs_sel_ch_ind(k)(1,n_sel_ch_ind(k)));\n        // This to read in pre-specified selectivity values...\n       // Number of selectivity changes is equal to the number of vectors (yr 1 is baseline)\n        for (int i=styr+1;i<=endyr;i++) { if(sel_change_in_ind(k,i)>0) { j++; yrs_sel_ch_tmp_ind(k,j) = i; } }\n        // This to read in pre-specified selectivity values...\n        *(ad_comm::global_datafile) >> sel_slp_in_ind(k,1) ;\n        *(ad_comm::global_datafile) >> sel_inf_in_ind(k,1) ;\n        logsel_slp_in_ind(k,1) =   log(sel_slp_in_ind(k,1)) ;\n        for (int jj=2;jj<=n_sel_ch_ind(k);jj++) \n        {\n          sel_inf_in_ind(k,jj)    =     sel_inf_in_ind(k,1) ;\n          logsel_slp_in_ind(k,jj) = log(sel_slp_in_ind(k,1)) ;\n        }\n        log_input(sel_slp_in_ind(k,1));\n        log_input(sel_inf_in_ind(k,1));\n        log_input(logsel_slp_in_ind(k,1));\n\n        phase_selcoff_ind(k) = -1;\n        phase_logist_ind(k) = phase_sel_ind(k);\n        phase_dlogist_ind(k)  = -1;\n\n        logsel_slp_in_indv(k) = logsel_slp_in_ind(k,1);\n           sel_inf_in_indv(k) =    sel_inf_in_ind(k,1);\n        log_input(logsel_slp_in_indv(k));\n      }\n      break;\n      case 3 : // Double logistic \n      {\n        write_input_log << \"Double logistic abandoned...\"<<endl;exit(1);\n      }\n        break;\n      case 4 : // spline for indices\n      {\n      }\n      break;\n    }\n    write_input_log << indname(k)<<\" ind sel opt \"<<ind_sel_opt(k)<<\" \"<<sel_change_in_ind(k)<<endl;\n  }\n  write_input_log<<\"Phase indices Sel_Coffs: \"<<phase_selcoff_ind<<endl; \n END_CALCS\n  init_number test;\n  !! write_input_log<<\" Test: \"<<test<<endl;\n !! if (test!=123456789) {cerr<<\"Control file not read in correctly... \"<<endl;exit(1);}\n\n\n  ivector nopt_fsh(1,2) // number of options...\n  !! nopt_fsh.initialize();\n  !! for (k=1;k<=nfsh;k++) if(fsh_sel_opt(k)==1) nopt_fsh(1)++;else nopt_fsh(2)++;\n\n  // Fishery selectivity description:\n  // type 1\n  \n  // Number of ages\n\n  !! write_input_log << \"# Fshry Selages: \" << nselages_in_fsh  <<endl;\n  !! write_input_log << \"# Srvy  Selages: \" << nselages_in_ind <<endl;\n\n\n\n  !! write_input_log << \"# Phase for age-spec fishery \"<<phase_selcoff_fsh<<endl;\n  !! write_input_log << \"# Phase for logistic fishery \"<<phase_logist_fsh<<endl;\n  !! write_input_log << \"# Phase for dble logistic fishery \"<<phase_dlogist_fsh<<endl;\n\n  !! write_input_log << \"# Phase for age-spec indices  \"<<phase_selcoff_ind<<endl;\n  !! write_input_log << \"# Phase for logistic indices  \"<<phase_logist_ind<<endl;\n  !! write_input_log << \"# Phase for dble logistic ind \"<<phase_dlogist_ind<<endl;\n\n  !! for (k=1;k<=nfsh;k++) if (phase_selcoff_fsh(k)>0) curv_pen_fsh(k) = 1./ (square(curv_pen_fsh(k))*2.);\n  !! write_input_log<<\"# Curv_pen_fsh: \"<<endl<<curv_pen_fsh<<endl;\n  !! for (k=1;k<=nind;k++) if (phase_selcoff_ind(k)>0) curv_pen_ind(k) = 1./ (square(curv_pen_ind(k))*2.);\n  !! write_input_log<<\"# Curv_pen_ind: \"<<endl<<curv_pen_ind<<endl;\n\n  int  phase_fmort;\n  int  phase_proj;\n  ivector   nselages_fsh(1,nfsh);\n  matrix xnodes_fsh(1,nfsh,1,nnodes_fsh)\n  matrix xages_fsh(1,nfsh,1,nages)\n\n  ivector   nselages_ind(1,nind);\n  //Resetting data here for retrospectives////////////////////////////////////////////\n LOCAL_CALCS\n  for (int k=1;k<=nfsh;k++) \n  {\n    if ((endyr-retro)<=yrs_sel_ch_fsh(k,n_sel_ch_fsh(k))) \n\t\t{\n\t\t\tint itmp=1;\n\t\t\twhile ((endyr-retro) > yrs_sel_ch_fsh(k,itmp))\n\t\t\t{\n\t\t\t  n_sel_ch_fsh(k) = itmp ;  \n      cout<<\"yrs_ch \"<<yrs_sel_ch_fsh(k)(1,n_sel_ch_fsh(k))<<endl;\n\t\t\t  itmp++;\n\t\t\t}\n\t\t}\n    for (int i=1;i<=retro;i++) \n    {\n      cout<<\"here\"<<max(yrs_fsh_age_in(k)(1,nyrs_fsh_age(k)))<<endl;\n      if (max(yrs_fsh_age_in(k)(1,nyrs_fsh_age(k)))>=(endyr-retro)) \n      {\n         nyrs_fsh_age(k) -= 1;\n          if (max(yrs_fsh_age_in(k)(1,nyrs_fsh_age(k)))>=(endyr-retro)) \n             nyrs_fsh_age(k) -= 1;\n      }\n    }\n    if (nyrs_fsh_length(k) >0)\n    {\n      for (int i=1;i<=retro;i++) \n      {\n       //  cout<<\"Here \"<<max(yrs_fsh_length_in(k)(1,nyrs_fsh_length(k)))<<endl;\n        if (nyrs_fsh_length(k) >0)\n          if (max(yrs_fsh_length_in(k)(1,nyrs_fsh_length(k)))>=(endyr-retro)) \n           nyrs_fsh_length(k) -= 1;\n      }\n    }\n  }\n  // now for indices\n  for (int k=1;k<=nind;k++) \n  {\n    if ((endyr-retro)<=yrs_sel_ch_ind(k,n_sel_ch_ind(k))) n_sel_ch_ind(k)-=retro ;  \n    for (int i=1;i<=retro;i++) \n    {\n      // index values\n      if (max(yrs_ind_in(k)(1,nyrs_ind(k)))>(endyr-retro)) \n        nyrs_ind(k) -= 1;\n      // Ages (since they can be different than actual index years)\n      if (max(yrs_ind_age_in(k)(1,nyrs_ind_age(k)))>=(endyr-retro)) \n         nyrs_ind_age(k) -= 1;\n    }\n  }\n  endyr_rec_est = endyr_rec_est - retro;\n  endyr         = endyr - retro;\n  styr_fut      = endyr+1;\n  endyr_fut     = endyr + nproj_yrs; \n  endyr_sp      = endyr   - rec_age - 1;// endyr year of (main) spawning biomass\n  log_input(styr_fut);\n  log_input(endyr_fut);\n  log_input(nyrs_fsh_age);\n END_CALCS\n // now use redimensioned data for retro\n  matrix catch_bio(1,nfsh,styr,endyr)         //Catch biomass \n  matrix catch_bio_sd(1,nfsh,styr,endyr)      //Catch biomass standard errors \n  matrix catch_bio_lsd(1,nfsh,styr,endyr)     //Catch biomass standard errors (for lognormal)\n  matrix catch_bio_lva(1,nfsh,styr,endyr)     //Catch biomass variance (for lognormal)\n  matrix catch_bioT(styr,endyr,1,nfsh)\n  vector catch_lastyr(1,nfsh);\n  imatrix yrs_fsh_age(1,nfsh,1,nyrs_fsh_age)\n  imatrix yrs_fsh_length(1,nfsh,1,nyrs_fsh_length)\n  matrix  n_sample_fsh_age(1,nfsh,1,nyrs_fsh_age)    //Years of index index value (annual)\n  matrix n_sample_fsh_length(1,nfsh,1,nyrs_fsh_length)    //Years of index index value (annual)\n  3darray oac_fsh(1,nfsh,1,nyrs_fsh_age,1,nages)\n  3darray olc_fsh(1,nfsh,1,nyrs_fsh_length,1,nlength)\n\n  imatrix yrs_ind(1,nind,1,nyrs_ind)         //Years of index value (annual)\n  matrix obs_ind(1,nind,1,nyrs_ind)          //values of index value (annual)\n  matrix obs_se_ind(1,nind,1,nyrs_ind)       //values of indices serrs\n\n  imatrix yrs_ind_age(1,nind,1,nyrs_ind_age)  //Years of index value (annual)\n  imatrix yrs_ind_length(1,nind,1,nyrs_ind_length)\n  matrix n_sample_ind_age(1,nind,1,nyrs_ind_age)         //Years of index value (annual)\n  matrix n_sample_ind_length(1,nind,1,nyrs_ind_length)    //Years of index index value (annual)\n  3darray oac_ind(1,nind,1,nyrs_ind_age,1,nages)  //values of Index proportions at age\n  3darray olc_ind(1,nind,1,nyrs_ind_length,1,nlength)\n\n  matrix     obs_lse_ind(1,nind,1,nyrs_ind) //Index standard errors (for lognormal)\n  matrix     obs_lva_ind(1,nind,1,nyrs_ind) //Index standard errors (for lognormal)\n LOCAL_CALCS\n  for (int k=1;k<=nfsh;k++)\n  {\n    catch_bio(k) = catch_bio_in(k)(styr,endyr);\n    catch_bio_sd(k) = catch_bio_sd_in(k)(styr,endyr);\n    if (nyrs_fsh_age(k))\n    {\n      yrs_fsh_age(k) = yrs_fsh_age_in(k)(1,nyrs_fsh_age(k));\n      n_sample_fsh_age(k) = n_sample_fsh_age_in(k)(1,nyrs_fsh_age(k));\n    }\n    if (nyrs_fsh_length(k))\n    {\n      yrs_fsh_length(k) = yrs_fsh_length_in(k)(1,nyrs_fsh_length(k));\n      n_sample_fsh_length(k) = n_sample_fsh_length_in(k)(1,nyrs_fsh_length(k));\n    }\n    for (int i=1;i<=nyrs_fsh_age(k);i++)\n      oac_fsh(k,i) = oac_fsh_in(k,i) ;\n    for (int i=1;i<=nyrs_fsh_length(k);i++)\n      olc_fsh(k,i) = olc_fsh_in(k,i) ;\n  }\n  catch_bio_lsd = sqrt(log(square(catch_bio_sd) + 1.));\n  catch_bio_lva = log(square(catch_bio_sd) + 1.);\n  catch_bioT    = trans(catch_bio);\n  catch_lastyr  = catch_bioT(endyr);\n  for (int k=1;k<=nind;k++)\n  {\n    yrs_ind(k)  = yrs_ind_in(k)(1,nyrs_ind(k));\n    obs_ind(k)  = obs_ind_in(k)(1,nyrs_ind(k));\n    obs_se_ind(k)  = obs_se_ind_in(k)(1,nyrs_ind(k));\n\n    if (nyrs_ind_age(k)>0)\n    {\n      yrs_ind_age(k) = yrs_ind_age_in(k)(1,nyrs_ind_age(k));\n      n_sample_ind_age(k) = n_sample_ind_age_in(k)(1,nyrs_ind_age(k));\n    }\n    if (nyrs_ind_length(k)>0)\n    {\n      yrs_ind_length(k) = yrs_ind_length_in(k)(1,nyrs_ind_length(k));\n      n_sample_ind_length(k) = n_sample_ind_length_in(k)(1,nyrs_ind_length(k));\n  }\n    for (int i=1;i<=nyrs_ind_age(k);i++)\n      oac_ind(k,i) = oac_ind_in(k,i) ;\n    for (int i=1;i<=nyrs_ind_length(k);i++)\n      olc_ind(k,i) = olc_ind_in(k,i) ;\n  }\n  log_input(nyrs_fsh_age);\n  log_input(yrs_fsh_age);\n  log_input(n_sample_fsh_age);\n  log_input(oac_fsh);\n  log_input(olc_fsh);\n  log_input(wt_fsh);\n\n  log_input(nyrs_ind_age);\n  log_input(yrs_ind_age);\n  log_input(n_sample_ind_age);\n  log_input(oac_ind);\n  log_input(olc_ind);\n  obs_lse_ind = elem_div(obs_se_ind,obs_ind);\n  obs_lse_ind = sqrt(log(square(obs_lse_ind) + 1.));\n  log_input(obs_lse_ind);\n  obs_lva_ind = square(obs_lse_ind);\n END_CALCS\n\n  ////////////////////////////////////////////////////////////////////////////////////\n LOCAL_CALCS\n  for (k=1; k<=nfsh;k++)\n  {\n    // xages_fsh increments from 0-1 by number of ages, say\n    xages_fsh.initialize();\n    log_input(xages_fsh);\n    xages_fsh(k).fill_seqadd(0.,1.0/(nages-1));\n    log_input(xages_fsh);\n    //  xnodes increments from 0-1 by number of nodes\n    xnodes_fsh.initialize();\n    xnodes_fsh(k).fill_seqadd(0.,1.0/(nnodes_fsh(k)-1));\n    log_input(xnodes_fsh);\n    // xages_fsh(k).fill_seqadd(0,1.0/(nselages_in_fsh(k)-1)); //prefer to use nselages but need 3d version to work\n  }\n  write_input_log<<\"Yrs fsh_sel change: \"<<yrs_sel_ch_fsh<<endl;\n  // for (k=1; k<=nind;k++) yrs_sel_ch_ind(k) = yrs_sel_ch_tmp_ind(k)(1,n_sel_ch_ind(k));\n  write_input_log<<\"Yrs ind_sel change: \"<<yrs_sel_ch_ind<<endl;\n    log_sigmarprior = log(sigmarprior);\n    log_input(steepnessprior);\n    log_input(sigmarprior);\n    nrecs_est = endyr_rec_est-styr_rec_est+1;\n    nrecs_est = endyr_rec_est-styr_rec_est+1;\n    write_input_log<<\"#  SSB estimated in styr endyr: \" <<styr_sp    <<\" \"<<endyr_sp      <<\" \"<<endl;\n    write_input_log<<\"#  Rec estimated in styr endyr: \" <<styr_rec    <<\" \"<<endyr        <<\" \"<<endl;\n    write_input_log<<\"#  SR Curve fit  in styr endyr: \" <<styr_rec_est<<\" \"<<endyr_rec_est<<\" \"<<endl;\n    write_input_log<<\"#             Model styr endyr: \" <<styr        <<\" \"<<endyr        <<\" \"<<endl;\n    log_qprior = log(qprior);\n    log_input(qprior);\n    log_q_power_prior = log(q_power_prior);\n    write_input_log<<\"# q_power_prior \" <<endl<<q_power_prior<<\" \"<<endl;\n    write_input_log<<\"# cv_catchbiomass \" <<endl<<cv_catchbiomass<<\" \"<<endl;\n    write_input_log<<\"# CatchbiomassPen \" <<endl<<catchbiomass_pen<<\" \"<<endl;\n    write_input_log<<\"# Number of projection years \" <<endl<<nproj_yrs<<\" \"<<endl;// cin>>junk;\n\n END_CALCS\n  number R_guess;\n\n  vector offset_ind(1,nind)\n  vector offset_fsh(1,nfsh)\n  vector offset_lfsh(1,nfsh)\n  vector offset_lind(1,nind)\n\n  int do_fmort;\n  !! do_fmort=0;\n  int Popes;\n LOCAL_CALCS\n  Popes=0; // option to do Pope's approximation (not presently flagged outside of code)\n  if (Popes) \n    phase_fmort = -2;\n  else\n    phase_fmort = 1;\n\n  phase_proj  =  5;\n\n  Steepness_UB = .9999; // upper bound of steepness\n  offset_ind.initialize();\n  offset_fsh.initialize();\n  offset_lfsh.initialize();\n  offset_lind.initialize();\n  double sumtmp;\n  for (k=1;k<=nfsh;k++)\n    for (i=1;i<=nyrs_fsh_age(k);i++)\n    {\n      oac_fsh(k,i) /= sum(oac_fsh(k,i)); // Normalize to sum to one\n      offset_fsh(k) -= n_sample_fsh_age(k,i)*(oac_fsh(k,i) + 0.001) * log(oac_fsh(k,i) + 0.001 ) ;\n    }\n  for (k=1;k<=nfsh;k++)\n    for (i=1;i<=nyrs_fsh_length(k);i++)\n    {\n      olc_fsh(k,i) /= sum(olc_fsh(k,i)); // Normalize to sum to one\n      offset_lfsh(k) -= n_sample_fsh_length(k,i)*(olc_fsh(k,i) + 0.001) * log(olc_fsh(k,i) + 0.001 ) ;\n    }\n\n  for (k=1;k<=nind;k++)\n  {\n    for (i=1;i<=nyrs_ind_age(k);i++)\n    {\n      oac_ind(k,i) /= sum(oac_ind(k,i)); // Normalize to sum to one\n      offset_ind(k) -= n_sample_ind_age(k,i)*(oac_ind(k,i) + 0.001) * log(oac_ind(k,i) + 0.001 ) ;\n    }\n    for (i=1;i<=nyrs_ind_length(k);i++)\n    {\n      olc_ind(k,i) /= sum(olc_ind(k,i)); // Normalize to sum to one\n      offset_lind(k) -= n_sample_ind_length(k,i)*(olc_ind(k,i) + 0.001) * log(olc_ind(k,i) + 0.001 ) ;\n    }\n  }\n  log_input(offset_fsh); \n  log_input(offset_ind); \n\n  if (ad_comm::argc > 1) // Command line argument to profile Fishing mortality rates...\n  {\n    int on=0;\n    if ( (on=option_match(ad_comm::argc,ad_comm::argv,\"-uFmort\"))>-1)\n      do_fmort=1;\n  }\n\n  // Compute an initial Rzero value based on exploitation \n   double btmp=0.;\n   double ctmp=0.;\n   dvector ntmp(1,nages);\n   ntmp(1) = 1.;\n   for (int a=2;a<=nages;a++)\n     ntmp(a) = ntmp(a-1)*exp(-natmortprior-.05);\n   btmp = wt_pop * ntmp;\n   write_input_log << \"Mean Catch\"<<endl;\n   ctmp = mean(catch_bio);\n   write_input_log << ctmp <<endl;\n   R_guess = log((ctmp/.02 )/btmp) ;\n   write_input_log << \"R_guess \"<<endl;\n   write_input_log << R_guess <<endl;\n END_CALCS\n // vector len_bins(1,nlength)\n // !! len_bins.fill_seqadd(stlength,binlength);\n\nPARAMETER_SECTION\n // Biological Parameters\n  init_bounded_number tau(0.01,3.,-3)\n  init_bounded_number Mest(.02,4.8,phase_M)\n  init_bounded_vector Mage_offset(1,npars_Mage,-3,3,phase_Mage)\n  vector Mage(1,nages)\n  init_bounded_vector  M_rw(1,npars_rw_M,-10,10,phase_rw_M)\n  vector natmort(styr,endyr)\n  matrix  natage(styr,endyr+1,1,nages)\n  matrix N_NoFsh(styr,endyr_fut,1,nages);\n  // vector Sp_Biom(styr_sp,endyr)\n  vector pred_rec(styr_rec,endyr)\n  vector mod_rec(styr_rec,endyr) // As estimated by model\n  matrix  M(styr,endyr,1,nages)\n  matrix  Z(styr,endyr,1,nages)\n  matrix  S(styr,endyr,1,nages)\n\n\n //-----GROWTH PARAMETERS--------------------------------------------------\n  init_number log_Linf(phase_Linf);\n  init_number log_k(phase_k);\n  init_number log_Lo(phase_Lo);\n  init_number log_sdage(phase_sdage);\n//---------------------------------------------------------------------------\n\n\n // Stock rectuitment params\n  init_number mean_log_rec(1); \n  init_bounded_number steepness(0.21,Steepness_UB,phase_srec)\n  init_number log_Rzero(phase_Rzero)  \n  // OjO\n  // init_bounded_vector initage_dev(2,nages,-15,15,4)\n  init_bounded_vector rec_dev(styr_rec,endyr,-15,15,2)\n  // init_vector rec_dev(styr_rec,endyr,2)\n  init_number log_sigmar(phase_sigmar);\n  number m_sigmarsq  \n  number m_sigmar\n  number sigmarsq  \n  number sigmar\n  number alpha   \n  number beta   \n  number Bzero   \n  number Rzero   \n  number phizero\n  number avg_rec_dev   \n\n // Fishing mortality parameters\n  // init_vector         log_avg_fmort(1,nfsh,phase_fmort)\n  // init_bounded_matrix fmort_dev(1,nfsh,styr,endyr,-15,15.,phase_fmort)\n  init_bounded_matrix fmort(1,nfsh,styr,endyr,0.00,15.,phase_fmort)\n  vector Fmort(styr,endyr);  // Annual total Fmort\n  number hrate\n  number catch_tmp\n  number Fnew \n\n  !! for (k=1;k<=nfsh;k++) nselages_fsh(k)=nselages_in_fsh(k); // Sets all elements of a vector to one scalar value...\n  !! for (k=1;k<=nind;k++) nselages_ind(k)=nselages_in_ind(k); // Sets all elements of a vector to one scalar value...\n\n //  init_3darray log_selcoffs_fsh(1,nfsh,1,n_sel_ch_fsh,1,nselages_fsh,phase_selcoff_fsh)\n  init_matrix_vector log_selcoffs_fsh(1,nfsh,1,n_sel_ch_fsh,1,nselages_fsh,phase_selcoff_fsh) // 3rd dimension out...\n  // option to estimate smoother for selectivity penalty\n  // init_number_vector logSdsmu_fsh(1,nfsh,1,phase_selcoff_fsh) \n  !! if (fsh_sel_opt(1)==4) nnodes_tmp=nnodes_fsh(1);  // NOTE THIS won't work in general\n  //init_matrix_vector  log_sel_spl_fsh(1,nfsh,1,n_sel_ch_fsh,1,nnodes_tmp,phase_sel_spl_fsh)\n  init_matrix_vector  log_sel_spl_fsh(1,nfsh,1,n_sel_ch_fsh,1,4,phase_sel_spl_fsh)\n\n  !! log_input(nfsh);\n  !! log_input(n_sel_ch_fsh);\n  !! log_input(nselages_fsh);\n  !! log_input(phase_selcoff_fsh);\n  init_vector_vector logsel_slope_fsh(1,nfsh,1,n_sel_ch_fsh,phase_logist_fsh)\n  matrix                sel_slope_fsh(1,nfsh,1,n_sel_ch_fsh)\n  init_vector_vector     sel50_fsh(1,nfsh,1,n_sel_ch_fsh,phase_logist_fsh)\n\t// Case 3 double logistic, 3 parameter\n  init_vector_vector logsel_p1_fsh(1,nfsh,1,n_sel_ch_fsh,phase_dlogist_fsh)\n  matrix                sel_p1_fsh(1,nfsh,1,n_sel_ch_fsh)\n  init_vector_vector    sel_p2_fsh(1,nfsh,1,n_sel_ch_fsh,phase_dlogist_fsh)\n  init_vector_vector logsel_p3_fsh(1,nfsh,1,n_sel_ch_fsh,phase_dlogist_fsh)\n  matrix                sel_p3_fsh(1,nfsh,1,n_sel_ch_fsh)\n  // init_vector_vector logsel_dslope_fsh(1,nfsh,1,n_sel_ch_fsh,phase_dlogist_fsh)\n  // matrix                sel_dslope_fsh(1,nfsh,1,n_sel_ch_fsh)\n   !! int lb_d50=nages/2;\n  // init_bounded_vector_vector     seld50_fsh(1,nfsh,1,n_sel_ch_fsh,lb_d50,nages,phase_dlogist_fsh)\n\n  // !!exit(1);\n  3darray log_sel_fsh(1,nfsh,styr,endyr,1,nages)\n  3darray sel_fsh(1,nfsh,styr,endyr,1,nages)\n  matrix avgsel_fsh(1,nfsh,1,n_sel_ch_fsh);\n\n  matrix  Ftot(styr,endyr,1,nages)\n  3darray F(1,nfsh,styr,endyr,1,nages)\n  3darray eac_fsh(1,nfsh,1,nyrs_fsh_age,1,nages)\n//-----------------------------------------------NEW--------\n  3darray elc_fsh(1,nfsh,1,nyrs_fsh_length,1,nlength)\n  3darray elc_ind(1,nind,1,nyrs_ind_length,1,nlength)\n//----------------------------------------------------------\n  matrix  pred_catch(1,nfsh,styr,endyr)\n  3darray catage(1,nfsh,styr,endyr,1,nages)\n  matrix catage_tot(styr,endyr,1,nages)\n  matrix expl_biom(1,nfsh,styr,endyr)\n\n // Parameters for computing SPR rates \n  vector F50(1,nfsh)\n  vector F40(1,nfsh)\n  vector F35(1,nfsh)\n\n // Stuff for SPR and yield projections\n  number sigmar_fut\n  vector f_tmp(1,nfsh)\n  number SB0\n  number SBF50\n  number SBF40\n  number SBF35\n  vector Fratio(1,nfsh)\n  !! Fratio = 1;\n  !! Fratio /= sum(Fratio);\n\n  matrix Nspr(1,4,1,nages)\n \n  matrix nage_future(styr_fut,endyr_fut,1,nages)\n\n  init_vector rec_dev_future(styr_fut,endyr_fut,phase_proj);\n  vector Sp_Biom_future(styr_fut-rec_age,endyr_fut);\n  3darray F_future(1,nfsh,styr_fut,endyr_fut,1,nages);\n  matrix Z_future(styr_fut,endyr_fut,1,nages);\n  matrix S_future(styr_fut,endyr_fut,1,nages);\n  matrix catage_future(styr_fut,endyr_fut,1,nages);\n  number avg_rec_dev_future\n  vector avg_F_future(1,5)\n\n // Survey Observation parameters\n  init_number_vector log_q_ind(1,nind,phase_q) \n  init_number_vector log_q_power_ind(1,nind,phase_q_power) \n  init_vector_vector log_rw_q_ind(1,nind,1,npars_rw_q,phase_rw_q) \n  init_matrix_vector log_selcoffs_ind(1,nind,1,n_sel_ch_ind,1,nselages_ind,phase_selcoff_ind)\n\n  // init_vector_vector logsel_slope_ind(1,nind,1,n_sel_ch_ind,phase_logist_ind) // Need to make positive or reparameterize\n  init_vector_vector logsel_slope_ind(1,nind,1,n_sel_ch_ind,phase_logist_ind+1) // Need to make positive or reparameterize\n  init_bounded_vector_vector        sel50_ind(1,nind,1,n_sel_ch_ind,0,nages,phase_logist_ind)\n\n  init_vector_vector  logsel_dslope_ind(1,nind,1,n_sel_ch_ind,phase_dlogist_ind) // Need to make positive or reparameterize\n  init_bounded_vector_vector seld50_ind(1,nind,1,n_sel_ch_ind,lb_d50,nages,phase_dlogist_ind)\n\n  matrix                sel_slope_ind(1,nind,1,n_sel_ch_ind)\n  matrix                sel_dslope_ind(1,nind,1,n_sel_ch_ind)\n\n  3darray log_sel_ind(1,nind,styr,endyr,1,nages)\n  3darray sel_ind(1,nind,styr,endyr,1,nages)\n  matrix avgsel_ind(1,nind,1,n_sel_ch_ind);\n\n  matrix pred_ind(1,nind,1,nyrs_ind)\n  3darray eac_ind(1,nind,1,nyrs_ind_age,1,nages)\n\n // Likelihood value names         \n  number sigma\n  vector rec_like(1,4)\n  vector catch_like(1,nfsh)\n  vector age_like_fsh(1,nfsh)\n//---------------------------------NEW\n  vector length_like_fsh(1,nfsh)\n  vector length_like_ind(1,nind)\n//---------------------------------NEW\n\n  vector age_like_ind(1,nind)\n  matrix sel_like_fsh(1,nfsh,1,4)       \n  matrix sel_like_ind(1,nind,1,4)       \n  vector ind_like(1,nind)\n  vector fpen(1,6)    \n  vector post_priors(1,8)\n  vector post_priors_indq(1,nind)\n  objective_function_value obj_fun\n  vector obj_comps(1,14)\n  init_number repl_F(5)\n\n  sdreport_number repl_yld\n  sdreport_number repl_SSB\n  sdreport_number B100\n  number F50_est\n  number F40_est\n  number F35_est\n  matrix q_ind(1,nind,1,nyrs_ind)\n  vector q_power_ind(1,nind)\n  // sdreport_vector q_ind(1,nind)\n  sdreport_vector totbiom(styr,endyr+1)\n  sdreport_vector totbiom_NoFish(styr,endyr)\n  sdreport_vector Sp_Biom(styr_sp,endyr+1)\n  sdreport_vector Sp_Biom_NoFish(styr_sp,endyr)\n  sdreport_vector Sp_Biom_NoFishRatio(styr+1,endyr)\n  sdreport_number ABCBiom;\n  sdreport_vector recruits(styr_rec,endyr+1)\n  // vector recruits(styr,endyr+1)\n  sdreport_number depletion\n  sdreport_number depletion_dyn\n  sdreport_number MSY;\n  sdreport_number MSYL;\n  sdreport_number Fmsy;\n  sdreport_number lnFmsy;\n  sdreport_number Fcur_Fmsy;\n  sdreport_number Rmsy;\n  sdreport_number Bmsy;\n  sdreport_number Bcur_Bmsy;\n  sdreport_vector pred_ind_nextyr(1,nind);\n  sdreport_number OFL;\n  // NOTE TO DAVE: Need to have a phase switch for sdreport variables(\n  matrix catch_future(1,4,styr_fut,endyr_fut); // Note, don't project for F=0 (it will bomb)\n  sdreport_matrix SSB_fut(1,5,styr_fut,endyr_fut)\n  !! write_input_log <<\"logRzero \"<<log_Rzero<<endl;\n  !! write_input_log <<\"logmeanrec \"<<mean_log_rec<<endl;\n  !! write_input_log<< \"exp(log_sigmarprior \"<<exp(log_sigmarprior)<<endl;\n  sdreport_vector sumBiom(styr,endyr+1)\n\n\n\n\n//-----GROWTH PARAMETERS--------------------------------------------------\n number Linf;\n number k_coeff;\n number Lo;\n number sdage;\n vector mu_age(1,nages);\n vector sigma_age(1,nages);\n matrix P1(1,nages,1,nlength);\n matrix P2(1,nages,1,nlength);\n matrix P3(1,nages,1,nlength);\n vector Ones_length(1,nlength);\n matrix P_age2len(1,nages,1,nlength);\n\n//-----------------------------------------------------------------------\n // Initialize coefficients (if needed)\n LOCAL_CALCS\n  for (k=1;k<=nfsh;k++) \n  {\n    write_input_log<<\"Fish sel phase: \"<<phase_selcoff_fsh(k)<<\" \"<<fshname(k)<<endl;\n    switch (fsh_sel_opt(k))\n    {\n      case 1 : // Selectivity coefficients \n      {\n        if(phase_selcoff_fsh(k)<0)\n        {\n          write_input_log<<\"Initial fixing fishery sel to\"<<endl<<n_sel_ch_fsh(k)<<endl;\n          for (int jj=1;jj<=n_sel_ch_fsh(k);jj++) \n          {\n            log_selcoffs_fsh(k,jj)(1,nselages_in_fsh(k)) = log_selcoffs_fsh_in(k,jj)(1,nselages_in_fsh(k));\n            write_input_log <<\"Init coef:\"<<endl<<exp(log_selcoffs_fsh(k,jj)(1,nselages_in_fsh(k))) <<endl;\n          }\n        }\n      }\n        break;\n      case 2 : // Single logistic\n      {\n        if(phase_logist_fsh(k)<0)\n        {\n          logsel_slope_fsh(k,1) = logsel_slp_in_fsh(k,1)  ;\n          write_input_log<<\"Fixing fishery sel to\"<<endl<<n_sel_ch_fsh(k)<<endl;\n          for (int jj=1;jj<=n_sel_ch_fsh(k);jj++) \n          {\n            logsel_slope_fsh(k,jj) = logsel_slp_in_fsh(k,jj)  ;\n            sel50_fsh(k,jj)        =    sel_inf_in_fsh(k,jj)  ;\n          }\n        }\n      }\n      case 3 : // Double logistic \n      {\n        if(phase_dlogist_fsh(k)<0)\n        {\n          write_input_log<<\"Fixing fishery sel to\"<<endl<<n_sel_ch_fsh(k)<<endl;\n          for (int jj=1;jj<=n_sel_ch_fsh(k);jj++) \n          {\n            logsel_slope_fsh(k,jj) = logsel_slp_in_fsh(k,jj)  ;\n            sel50_fsh(k,jj)        =    sel_inf_in_fsh(k,jj)  ;\n            \n            \n          }\n        }\n      }\n      case 4 : // Selectivity spline initialize \n      /* {\n        if(phase_sel_spl_fsh(k)<0)\n        {\n          write_input_log<<\"Initial fishery spline to\"<<endl<<n_sel_ch_fsh(k)<<endl;\n          for (int jj=1;jj<=n_sel_ch_fsh(k);jj++) \n          {\n            log_sel_spl_fsh(k,jj)(1,nnodes_tmp) = log_sel_spl_fsh_in(k,jj)(1,nnodes_tmp);\n            // write_input_log <<\"Init coef:\"<<endl<<exp(log_sel_spl_fsh(k,jj)(1,nselages_in_fsh(k))) <<endl;\n          }\n          log_input(log_sel_spl_fsh);\n        }\n       }*/\n     break;\n    }\n  }\n  for (k=1;k<=nind;k++) \n  {\n    write_input_log<<\"Srvy sel phase: \"<<phase_selcoff_ind(k)<<endl;\n    if(phase_selcoff_ind(k)<0)\n    {\n      write_input_log<<\"Fixing \"<<indname(k)<<\" indices sel to\"<<endl<<n_sel_ch_ind(k)<<endl;\n      for (int jj=1;jj<=n_sel_ch_ind(k);jj++) \n      {\n        log_selcoffs_ind(k,jj)(1,nselages_in_ind(k)) = log_selcoffs_ind_in(k,jj)(1,nselages_in_ind(k));\n        // write_input_log <<\"Init coef:\"<<endl<<exp(log_selcoffs_ind(k,jj)(1,nselages_in_ind(k))) <<endl;\n      }\n    }\n    if(phase_logist_ind(k)<0)\n    {\n      write_input_log<<\"Fixing index sel to\"<<endl<<n_sel_ch_ind(k)<<endl;\n      for (int jj=1;jj<=n_sel_ch_ind(k);jj++) \n      {\n        logsel_slope_ind(k,jj) = logsel_slp_in_ind(k,jj)  ;\n        // logsel_slope_ind(k,jj)    = 0.   ;\n        sel50_ind(k,jj)           = sel_inf_in_ind(k,jj)  ;\n      }\n    }\n  }\n  log_input( logsel_slp_in_indv);\n  write_input_log <<\"Leaving parameter init secton\"<<endl;\n END_CALCS\n\nPRELIMINARY_CALCS_SECTION\n  tau=0.2;\n  // Initialize age-specific changes in M if they are specified\n  M(styr) = Mest;\n  if (npars_Mage>0)\n  {\n    Mage_offset = Mage_offset_in;\n    int jj=1;\n    for (j=1;j<=nages;j++)\n    {\n     if (j==ages_M_changes(jj))\n      {\n        // M(styr,j) = M(styr,1)*mfexp(Mage_offset(jj));\n        M(styr,j) = Mest*mfexp(Mage_offset(jj));\n        jj++;\n        if (npars_Mage < jj) jj=npars_Mage;\n      }\n      else\n        if(j>1) \n          M(styr,j) = M(styr,j-1);\n    }\n  }\n  //Initialize matrix of M\n  for (i=styr+1;i<=endyr;i++)\n    M(i) = M(i-1);\n  log_input(M);\n  Get_Age2length();\n\nINITIALIZATION_SECTION\n  Mest natmortprior; \n  steepness steepnessprior\n  log_sigmar log_sigmarprior;\n\n  log_Rzero    R_guess;\n  mean_log_rec R_guess;\n  \n  log_Linf    log_Linfprior\n  log_k       log_kprior\n  log_Lo      log_Loprior\n  log_sdage   log_sdageprior\n\n  // log_avg_fmort -2.065\n  log_q_ind log_qprior; \n  log_q_power_ind log_q_power_prior; \n  repl_F .1;\n\n  sel50_fsh sel_inf_in_fshv \n\n  // logsel_dslope_fsh logsel_dslp_in_fshv ;\n  // seld50_fsh sel_dinf_in_fshv \n  logsel_p1_fsh   logsel_p1_in_fshv ;\n  sel_p2_fsh         sel_p2_in_fshv ;\n  logsel_p3_fsh   logsel_p3_in_fshv ;\n\n  logsel_slope_ind logsel_slp_in_indv ;\n  sel50_ind sel_inf_in_indv ;\n\n  logsel_dslope_ind logsel_dslp_in_indv ;\n  seld50_ind sel_dinf_in_indv ;\n\n //+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+=+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==\nPROCEDURE_SECTION\n  fpen.initialize();\n  for (k=1;k<=nind;k++) \n  {\n    q_ind(k) = mfexp(log_q_ind(k) );\n    q_power_ind(k) = mfexp(log_q_power_ind(k) );\n  }\n\n  // Main model calcs---------------------\n  if(active(log_Linf)||active(log_k)||active(log_sdage))\n    Get_Age2length();\n  Get_Selectivity();\n  Get_Mortality();\n  Get_Bzero();\n  Get_Numbers_at_Age();\n\n  Get_Survey_Predictions();\n  Get_Fishery_Predictions();\n  // Objective function calcs------------\n  evaluate_the_objective_function();\n  if (last_phase())\n    Get_Replacement_Yield();\n\n  // Output calcs-------------------------\n  if (sd_phase())\n  {\n    compute_spr_rates();\n    Calc_Dependent_Vars();\n    if (mcmcmode)\n    {\n      // Calc_Dependent_Vars();\n      mcflag   = 0;\n      mcmcmode = 0;\n    }\n    else\n    {\n      // if (mcflag)\n      //   Calc_Dependent_Vars();\n    }\n  }\n  // Other calcs-------------------------\n  if (mceval_phase())\n  {\n    Calc_Dependent_Vars();\n    if (oper_mod)\n      Oper_Model();\n    else\n    {\n      compute_spr_rates();\n      write_mceval();\n    }\n  }\n  if (do_fmort) Profile_F();\n //+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==\n\nFUNCTION write_mceval\n  if (mcmcmode != 3)\n    write_mceval_hdr();\n  mcmcmode = 3;\n  mc_count++;\n    mceval_sr <<\"curve 0 0\"<<endl;\n    dvariable stock;\n    for (i=1;i<=30;i++)\n    {\n      stock = double (i) * Bzero /25.;\n      if (active(log_Rzero))\n        mceval_sr << \"curve \"<<stock <<\" \"<< SRecruit(stock)<<endl;\n      else\n        mceval_sr << \"curve \"<<stock <<\" 99 \"<<endl;\n    }\n    for (k=1;k<=5;k+=4)\n\t\t{\n      for (i=styr_fut;i<=endyr_fut;i++)\n\t\t  {\n\t\t   if (int(i-rec_age)<styr_fut)\n        mceval_R<<k<<\" \"<< i <<\" \"<< natage(i-rec_age,1) <<endl;     \n\t\t   else\n        mceval_R<<k<<\" \"<< i <<\" \"<< SRecruit( SSB_fut(k,i-rec_age) ) * mfexp(rec_dev_future(i)) <<endl;     \n      }\n    }\n    for (i=1;i<=nyrs_ind(1);i++)\n    {\n      // iyr = int(yrs_ind(k,i));\n      mceval_srv<<yrs_ind(1,i)<<\" \"<<obs_ind(1,i)<<\" \"<< pred_ind(1,i) <<\" \"<< mc_count<<endl;\n\t\t}\n    for (k=1;k<=5;k++)\n    for (i=styr;i<=endyr;i++)\n\t\t{\n      // mceval_srv  <<i<<\" \"<< (i-rec_age-1)<<\" \"<<natage(i,1)<< endl;\n      // ind_like(k) += square(log(obs_ind(k,i)) - log(pred_ind(k,i)) ) / \n      mceval_sr   <<\"est \"<< Sp_Biom(i-rec_age-1)<<\" \"<<natage(i,1)<< endl;\n      mceval_M<<i <<\" \"<< M(i,2) <<\" \"<<M(i,4)<<endl;\n    }\n\t\tdvariable Rtmp;\n    for (k=1;k<=5;k++)\n\t\t{\n      for (i=styr_fut;i<=endyr_fut;i++)\n\t\t  {\n\t\t   if (int(i-rec_age)<styr_fut)\n        Rtmp = natage(i-rec_age,1) ;     \n\t\t   else\n        Rtmp = SRecruit( SSB_fut(k,i-rec_age) ) * mfexp(rec_dev_future(i)) ;     \n\t\t\t\tif (k!=5)\n          mceval_proj<<mc_count<<\" \"<<k<<\" \"<<i <<\" \"<<SSB_fut(k,i)<<\" \"<<catch_future(k,i)<<\" \"<< Rtmp <<endl;\n\t\t\t\telse\n          mceval_proj<<mc_count<<\" \"<<k<<\" \"<<i <<\" \"<<SSB_fut(k,i)<<\" 0 \"<< Rtmp <<endl;\n      }\n    }\n    \n  // styr_sp  = styr_rec - rec_age - 1 ;    // First year of spawning biomass  \n  //sdreport_vector recruits(styr,endyr+1)\n  //sdreport_vector Sp_Biom(styr_sp,endyr+1)\n\n  mceval<< model_name         << \" \"  ;\n  mceval<< obj_fun            << \" \"  ;\n\n  // mceval<< rec_dev_future << \" \"  ;\n  // mceval<<endl;\n  get_msy();\n  Future_projections();\n  // Calc_Dependent_Vars();\n  mceval<<\n  B100        << \" \"<< \n  q_ind(1,1)  << \" \"<< \n  M(endyr)    << \" \"<< \n  steepness << \" \"<< \n  depletion << \" \"<< \n  MSY       << \" \"<< \n  MSYL      << \" \"<< \n  Fmsy      << \" \"<< \n  Fcur_Fmsy << \" \"<< \n  Bcur_Bmsy << \" \"<< \n  Bmsy      << \" \"<< \n  ABCBiom   << \" \"<< \n  F35       << \" \"<<\n  F40       << \" \"<<\n  F50       << \" \"<<\n  SSB_fut(1,endyr_fut) << \" \"<< \n  SSB_fut(2,endyr_fut) << \" \"<< \n  SSB_fut(3,endyr_fut) << \" \"<< \n  SSB_fut(4,endyr_fut) << \" \"<< \n  SSB_fut(5,endyr_fut) << \" \"<< \n  catch_future(1,styr_fut)    << \" \"<<  \n  catch_future(2,styr_fut)    << \" \"<<  \n  catch_future(3,styr_fut)    << \" \"<<  \n  catch_future(4,styr_fut)    << \" \"<<  endl;\n\n\n//-----TRANSFORMATION FUNCION AGE->LENGTH--------------------------------------------------\nFUNCTION Get_Age2length\n // This subroutine allows convert an age composition to length composition. For example: if there is a matrix C(1,nyears,1,nages), \n // the vectorial operation: Cl=C*Prob_length,  returns a matrix Cl(1,nyears,1,nlength) whose sum over all the lengths is the same \n // the sum over all age groups..\n // (Cristian Canales)\n // by default values\n  // Linf=Linfprior;// Asymptotic length\n  // k_coeff=kprior;\n  // Lo=Loprior;// first length (corresponds to first age-group)\n  // sdage=sdageprior;// coefficient of variation of length-at-age\n // if some of these are estimated.\n  Linf    = mfexp(log_Linf);\n  k_coeff = mfexp(log_k);\n  Lo      = mfexp(log_Lo);\n  sdage   = mfexp(log_sdage);\n  int i, j;\n  mu_age(1)=Lo; // first length (modal)\n  for (i=2;i<=nages;i++)\n    mu_age(i) = Linf*(1.-exp(-k_coeff))+exp(-k_coeff)*mu_age(i-1); // the mean length by age group\n  sigma_age=sdage*mu_age; // standard deviation of length-at-age\n  P_age2len = ALK( mu_age, sigma_age, len_bins);\n\nFUNCTION dvar_matrix ALK(dvar_vector& mu, dvar_vector& sig, dvector& x)\n  //RETURN_ARRAYS_INCREMENT();\n  int i, j;\n  dvariable z1;\n  dvariable z2;\n  int si,ni; si=mu.indexmin(); ni=mu.indexmax();\n  int sj,nj; sj=x.indexmin(); nj=x.indexmax();\n  dvar_matrix pdf(si,ni,sj,nj);\n  double xs;\n  pdf.initialize();\n  for(i=si;i<=ni;i++) //loop over ages\n  {\n    for(j=sj;j<=nj;j++) //loop over length bins\n    {\n      if (j<nj)\n        xs=0.5*(x[sj+1]-x[sj]);  // accounts for variable bin-widths...?\n      z1=((x(j)-xs)-mu(i))/sig(i);\n      z2=((x(j)+xs)-mu(i))/sig(i);\n      pdf(i,j)=cumd_norm(z2)-cumd_norm(z1);\n    }//end nbins\n    pdf(i)/=sum(pdf(i));\n  }//end nage\n  //RETURN_ARRAYS_DECREMENT();\n  return(pdf);\n\n//---------------------------------------------------------------------------\n\n\nFUNCTION Get_Replacement_Yield\n  // compute next year's yield and SSB and add penalty to ensure F gives same SSB... \n  dvar_vector ntmp(1,nages);\n  ntmp = natage(endyr+1);\n  dvariable SSBnext;\n  dvar_matrix Ftmp(1,nfsh,1,nages);\n  dvar_vector Ctmp(1,nages);\n  dvar_vector Ztmp(1,nages);\n  dvar_vector Stmp(1,nages);\n  Ctmp.initialize();\n  Ztmp  = M(endyr);\n  dvariable sumF=0.;\n  for (k=1;k<=nfsh;k++)\n    sumF += sum(F(k,endyr));\n  for (k=1;k<=nfsh;k++)\n  {\n    Ftmp(k) = repl_F*sum(F(k,endyr)) / sumF;\n    Ztmp   += Ftmp(k);\n  }\n  Stmp = mfexp(-Ztmp);\n  for (k=1;k<=nfsh;k++)\n    Ctmp += elem_prod(wt_fsh(k,endyr),elem_prod(elem_div(Ftmp(k),Ztmp),elem_prod(1.-Stmp,ntmp)) );\n  repl_yld = sum(Ctmp) ;\n  ntmp(2,nages) = ++elem_prod(Stmp(1,nages-1),ntmp(1,nages-1));\n  ntmp(nages)  += ntmp(nages)*Stmp(nages);\n  ntmp(1)       = mean(mod_rec);\n  repl_SSB  = elem_prod(ntmp, pow(Stmp,spmo_frac)) * wt_mature; \n  obj_fun  += 200.*square(log(Sp_Biom(endyr))-log(repl_SSB));\n  \nFUNCTION Get_Selectivity\n  // Calculate the logistic selectivity (Only if being used...)   \n  for (k=1;k<=nfsh;k++)\n  {\n    switch (fsh_sel_opt(k))\n    {\n      case 1 : // Selectivity coefficients \n      //---Calculate the fishery selectivity from the sel_coffs (Only if being used...)   \n      {\n        int isel_ch_tmp = 1 ;\n        dvar_vector sel_coffs_tmp(1,nselages_fsh(k));\n        for (i=styr;i<=endyr;i++)\n        {\n          if (i==yrs_sel_ch_fsh(k,isel_ch_tmp)) \n          {\n            sel_coffs_tmp.initialize();\n            sel_coffs_tmp = log_selcoffs_fsh(k,isel_ch_tmp);\n            avgsel_fsh(k,isel_ch_tmp)              = log(mean(mfexp(sel_coffs_tmp)));\n            // Increment if there is still space to do so...\n            if (isel_ch_tmp<n_sel_ch_fsh(k))\n              isel_ch_tmp++;\n          }\n         // Need to flag for changing selectivity....XXX\n          log_sel_fsh(k,i)(1,nselages_fsh(k))        = sel_coffs_tmp;\n          log_sel_fsh(k,i)(nselages_fsh(k),nages)    = log_sel_fsh(k,i,nselages_fsh(k));\n          log_sel_fsh(k,i)                                  -= log(mean(mfexp(log_sel_fsh(k,i) )));\n        }\n      }\n      break;\n      case 2 : // Single logistic\n      {\n        sel_slope_fsh(k) = mfexp(logsel_slope_fsh(k));\n        int isel_ch_tmp = 1 ;\n        dvariable sel_slope_tmp = sel_slope_fsh(k,isel_ch_tmp);\n        dvariable sel50_tmp     = sel50_fsh(k,isel_ch_tmp);\n        for (i=styr;i<=endyr;i++)\n        {\n          if (i==yrs_sel_ch_fsh(k,isel_ch_tmp)) \n          {\n            sel_slope_tmp = sel_slope_fsh(k,isel_ch_tmp);\n            sel50_tmp     =     sel50_fsh(k,isel_ch_tmp);\n            if (isel_ch_tmp<n_sel_ch_fsh(k))\n              isel_ch_tmp++;\n          }\n          log_sel_fsh(k,i)(1,nselages_fsh(k))     = -1.*log( 1.0 + mfexp(-1.*sel_slope_tmp * \n                                                ( age_vector(1,nselages_fsh(k)) - sel50_tmp) ));\n          log_sel_fsh(k,i)(nselages_fsh(k),nages) = log_sel_fsh(k,i,nselages_fsh(k));\n        }\n    }\n    break;\n    case 3 : // Double logistic\n    {\n      sel_p1_fsh(k)  = mfexp(logsel_p1_fsh(k));\n      sel_p3_fsh(k)  = mfexp(logsel_p3_fsh(k));\n      int isel_ch_tmp = 1 ;\n      dvariable p1 = sel_p1_fsh(k,isel_ch_tmp);\n      dvariable p2 = sel_p2_fsh(k,isel_ch_tmp);\n      dvariable p3 = sel_p3_fsh(k,isel_ch_tmp);\n\t\t\tdvariable i1 = p1 + p2;\n\t\t\tdvariable i2 = p1 + i1 + p3;\n\t\t\t\n      for (i=styr;i<=endyr;i++)\n      {\n        if (i==yrs_sel_ch_fsh(k,isel_ch_tmp)) \n        {\n          p1 = sel_p1_fsh(k,isel_ch_tmp);\n          p2 = sel_p2_fsh(k,isel_ch_tmp);\n          p3 = sel_p3_fsh(k,isel_ch_tmp);\n\t\t\t    i1 = p1 + p2;\n\t\t\t    i2 = p1 + i1 + p3;\n          if (isel_ch_tmp<n_sel_ch_fsh(k))\n            isel_ch_tmp++;\n        }\n        log_sel_fsh(k,i)(1,nselages_fsh(k))     = ( -log(1.0 + mfexp(-2.9444389792/p1 * ( age_vector(1,nselages_fsh(k)) - i1) )) +\n               log(1. - 1./(1.0 + mfexp(-2.9444389792/p3 * ( age_vector(1,nselages_fsh(k)) - i2))) ) )+0.102586589 ; // constant at end is log(0.95*0.95)\n\n\t\t\t// cout << p1 << \" \"<<p2<<\" \"<<p3<<endl<<i1<<\" \"<<i2<<endl<<age_vector<<endl<<sel_fsh(k,i)<<endl;exit(1);\n  // OjO, still has nselages as part of configuration option...\n        log_sel_fsh(k,i)(nselages_fsh(k),nages) = log_sel_fsh(k,i,nselages_fsh(k));\n        \n        log_sel_fsh(k,i) -= max(log_sel_fsh(k,i));\n        // sel_fsh(k,i) /= 0.9025 ; // Simply 95th %ile squared as normalizing  \n      }\n    }\n    break;\n    //---Calculate the fishery selectivity from the sel_spl from nodes...\n    case 4 : // Splines\n     break;\n    } // End of switch for fishery selectivity type\n  } // End of fishery loop\n  // Survey specific---\n  for (k=1;k<=nind;k++)\n  {\n    switch (ind_sel_opt(k))\n    {\n      case 1 : // Selectivity coefficients\n      //---Calculate the fishery selectivity from the sel_coffs (Only if being used...)   \n      {\n        int isel_ch_tmp = 1 ;\n        dvar_vector sel_coffs_tmp(1,nselages_ind(k));\n        for (i=styr;i<=endyr;i++)\n        {\n          if (i==yrs_sel_ch_ind(k,isel_ch_tmp)) \n          {\n            sel_coffs_tmp.initialize();\n            sel_coffs_tmp = log_selcoffs_ind(k,isel_ch_tmp);\n            avgsel_ind(k,isel_ch_tmp)              = log(mean(mfexp(sel_coffs_tmp)));\n            if (isel_ch_tmp<n_sel_ch_ind(k))\n              isel_ch_tmp++;\n          }\n          log_sel_ind(k,i)(1,nselages_ind(k))        = sel_coffs_tmp;\n          log_sel_ind(k,i)(nselages_ind(k),nages)    = log_sel_ind(k,i,nselages_ind(k));\n          log_sel_ind(k,i)                                  -= log(mean(mfexp(log_sel_ind(k,i)(q_age_min(k),q_age_max(k))))); \n        }\n      }\n  \n        break;\n      case 2 : // Asymptotic logistic\n        {\n          sel_slope_ind(k) = mfexp(logsel_slope_ind(k));\n          int isel_ch_tmp = 1 ;\n          dvariable sel_slope_tmp = sel_slope_ind(k,isel_ch_tmp);\n          dvariable sel50_tmp     = sel50_ind(k,isel_ch_tmp);\n          for (i=styr;i<=endyr;i++)\n          {\n            if (i==yrs_sel_ch_ind(k,isel_ch_tmp)) \n            {\n              sel_slope_tmp = sel_slope_ind(k,isel_ch_tmp);\n              sel50_tmp     =     sel50_ind(k,isel_ch_tmp);\n              if (isel_ch_tmp<n_sel_ch_ind(k))\n                isel_ch_tmp++;\n            }\n            log_sel_ind(k,i) = - log( 1.0 + mfexp(-sel_slope_tmp * ( age_vector - sel50_tmp) ));\n            // log_sel_ind(k,i)                                  -= log(mean(mfexp(log_sel_ind(k,i)(q_age_min(k),q_age_max(k))))); \n          }\n        }\n        break;\n      case 3 : // Double logistic\n        {\n          sel_slope_ind(k)  = mfexp(logsel_slope_ind(k));\n          sel_dslope_ind(k) = mfexp(logsel_dslope_ind(k));\n          int isel_ch_tmp = 1 ;\n          dvariable sel_slope_tmp = sel_slope_ind(k,isel_ch_tmp);\n          dvariable sel50_tmp     = sel50_ind(k,isel_ch_tmp);\n          dvariable sel_dslope_tmp = sel_dslope_ind(k,isel_ch_tmp);\n          dvariable seld50_tmp     = seld50_ind(k,isel_ch_tmp);\n          for (i=styr;i<=endyr;i++)\n          {\n            if (i==yrs_sel_ch_ind(k,isel_ch_tmp)) \n            {\n              sel_slope_tmp  = sel_slope_ind(k,isel_ch_tmp);\n              sel50_tmp      =     sel50_ind(k,isel_ch_tmp);\n              sel_dslope_tmp = sel_dslope_ind(k,isel_ch_tmp);\n              seld50_tmp     =     seld50_ind(k,isel_ch_tmp);\n              if (isel_ch_tmp<n_sel_ch_ind(k))\n                isel_ch_tmp++;\n            }\n            log_sel_ind(k,i)(1,nselages_ind(k))     =\n                         -log( 1.0 + mfexp(-1.*sel_slope_tmp * \n                         ( age_vector(1,nselages_ind(k)) - sel50_tmp) ))+\n                         log( 1. - 1/(1.0 + mfexp(-sel_dslope_tmp * \n                         ( age_vector(1,nselages_ind(k)) - seld50_tmp))) );\n\n            log_sel_ind(k,i)(nselages_ind(k),nages) = \n                         log_sel_ind(k,i,nselages_ind(k));\n\n            log_sel_ind(k,i) -= max(log_sel_ind(k,i));  \n            log_sel_ind(k,i)                                  -= log(mean(mfexp(log_sel_ind(k,i)(q_age_min(k),q_age_max(k))))); \n          }\n        }\n      break;\n    }// end of swtiches for indices selectivity\n  } // End of indices loop\n\n  // Map selectivities across fisheries and indices as needed.\n  for (k=1;k<=nfsh;k++)\n    if (sel_map(2,k)!=k)  // If 2nd row shows a different fishery then use that fishery\n      log_sel_fsh(k) = log_sel_fsh(sel_map(2,k));\n\n  for (k=1+nfsh;k<=nfsh_and_ind;k++)\n    if (sel_map(1,k)!=2) \n      log_sel_ind(k-nfsh) = log_sel_fsh(sel_map(2,k));\n    else if (sel_map(2,k)!=(k-nfsh)) \n      log_sel_ind(k-nfsh) = log_sel_ind(sel_map(2,k));\n\n  sel_fsh = mfexp(log_sel_fsh);\n  sel_ind = mfexp(log_sel_ind);\n\nFUNCTION Get_NatMortality\n  natmort = Mest;\n\tif (active(Mest)) \n\t\tM(styr) = Mest;\n  // Age varying part\n  if (npars_Mage>0 )\n  {\n    int jj=1;\n    for (j=1;j<=nages;j++)\n    {\n      if (j==ages_M_changes(jj))\n      {\n        // M(styr,j) = M(styr,1)*mfexp(Mage_offset(jj));\n        M(styr,j) = Mest*mfexp(Mage_offset(jj));\n        jj++;\n        if (npars_Mage < jj) jj=npars_Mage;\n      }\n      else\n        if(j>1) \n          M(styr,j) = M(styr,j-1);\n    }\n  }\n\n  // Time varying part\n  if (npars_rw_M>0 && active(M_rw))\n  {\n    int ii=1;\n    for (i=styr+1;i<=endyr;i++)\n    {\n      if (i==yrs_rw_M(ii))\n      {\n        M(i) = M(i-1)*mfexp(M_rw(ii));\n        ii++;\n        if (npars_rw_M < ii) ii=npars_rw_M;\n      }\n      else\n        M(i) = M(i-1);\n    }\n  }\n  else\n    for (i=styr+1;i<=endyr;i++)\n      M(i) = M(i-1);\n\nFUNCTION Get_Mortality2\n  Get_NatMortality();\n  Z       = M;\n  for (k=1;k<=nfsh;k++)\n  {\n    F(k)   = elem_div(catage(k),natage);\n    Z     += F(k);\n  }\n  S = mfexp(-1.*Z);\n\nFUNCTION Get_Mortality\n  Get_NatMortality();\n  Z = M; \n  if (!Popes)\n  {\n    Fmort.initialize();\n    for (k=1;k<=nfsh;k++)\n    {\n      Fmort +=  fmort(k);\n      for (i=styr;i<=endyr;i++)\n      {\n        F(k,i)   =  fmort(k,i) * sel_fsh(k,i) ;\n        Z(i)    += F(k,i);\n      }\n    }\n    S  = mfexp(-1.*Z);\n  }\n  \n\nFUNCTION Get_Numbers_at_Age\n  // natage(styr,1) = mfexp(mean_log_rec + rec_dev(styr)); \n  // Recruitment in subsequent years\n  for (i=styr+1;i<=endyr;i++)\n    natage(i,1)=mfexp(mean_log_rec+rec_dev(i));\n\n  mod_rec(styr)  = natage(styr,1);\n\n  for (i=styr;i<=endyr;i++)\n  {\n    if (Popes)\n    {\n      dvariable  t1=mfexp(-natmort(i)*0.5);\n      dvariable  t2=mfexp(-natmort(i));\n      Catch_at_Age(i);\n      // Pope's approximation //   Next year N     =   This year x NatSurvivl - catch\n      natage(i+1)(2,nages) = ++(natage(i)(1,nages-1)*t2 - catage_tot(i)(1,nages-1)*t1);\n      Ftot(i)(1,nages-1) = log(natage(i)(1,nages-1)) - --log(natage(i+1)(2,nages)) - natmort(i);\n      natage(i+1,nages)   += natage(i,nages)*t2 - catage_tot(i,nages)*t1;\n      // Approximation to \"F\" continuous form for computing within-year sp biomass\n      Ftot(i,nages)      = log(natage(i,nages-1)+natage(i,nages)) -log(natage(i+1,nages)) -natmort(i);\n      // write_input_log <<i<<\" \"<<Ftot(i)(nages-4,nages)<<endl; // cout <<i<<\" \"<<natage(i)<<endl; // cout <<i<<\" \"<<natage(i+1)<<endl;\n      dvariable ctmp=sum(catage_tot(i));\n      for (k=1;k<=nfsh;k++)\n      {\n        F(k,i)  = Ftot(i) * sum(catage(k,i))/ctmp;\n      }\n      Z(i)    = Ftot(i)+natmort(i);\n      S(i)    = mfexp(-Z(i));\n    }\n    else // Baranov\n    {\n      // get_Fs( i ); //ojo, add switch here for different catch equation XX\n      // if (i!=endyr)\n      // {\n        natage(i+1)(2,nages) = ++elem_prod(natage(i)(1,nages-1),S(i)(1,nages-1));\n        natage(i+1,nages)   +=natage(i,nages)*S(i,nages);\n      // }\n    }\n    Catch_at_Age(i);\n    Sp_Biom(i)  = elem_prod(natage(i),pow(S(i),spmo_frac)) * wt_mature; \n    if (i<endyr) mod_rec(i+1)  = natage(i+1,1);\n  }\n\nFUNCTION Get_Survey_Predictions\n  // Survey computations------------------\n  dvariable sum_tmp;\n  sum_tmp.initialize();\n  int ii;\n  int iyr;\n  for (k=1;k<=nind;k++)\n  {\n    // Set rest of q's in time series equal to the random walk for current (avoids tricky tails...)\n    for (i=2;i<=(1+npars_rw_q(k));i++)\n    {\n      // get index for the number of observations (can be different than number of q's)\n      ii = yrs_rw_q(k,i-1) - yrs_ind(k,1) + 1;  \n      q_ind(k,ii)  = q_ind(k,ii-1)*mfexp(log_rw_q_ind(k,i-1));\n      for (iyr=ii+1;iyr<=nyrs_ind(k);iyr++)\n        q_ind(k,iyr)  = q_ind(k,ii);\n    }\n    for (i=1;i<=nyrs_ind(k);i++)\n    {        \n      iyr=yrs_ind(k,i);\n      pred_ind(k,i) = q_ind(k,i) * pow(elem_prod(natage(iyr),pow(S(iyr),ind_month_frac(k))) * \n                                     elem_prod(sel_ind(k,iyr) , wt_ind(k,iyr)),q_power_ind(k));\n    }\n    for (i=1;i<=nyrs_ind_age(k);i++)\n    {        \n      iyr = yrs_ind_age(k,i); \n      dvar_vector tmp_n   = elem_prod(pow(S(iyr),ind_month_frac(k)),elem_prod(sel_ind(k,iyr),natage(iyr)));  \n      sum_tmp             = sum(tmp_n);\n      if (use_age_err)\n        eac_ind(k,i)      = age_err * tmp_n/sum_tmp;\n      else\n        eac_ind(k,i)      = tmp_n/sum_tmp;\n    }\n    dvar_vector tmp_n(1,nages);\n    for (i=1;i<=nyrs_ind_length(k);i++)\n    {        \n      iyr          = yrs_ind_length(k,i); \n      tmp_n        = elem_prod(pow(S(iyr),ind_month_frac(k)),elem_prod(sel_ind(k,iyr),natage(iyr)));  \n      sum_tmp      = sum(tmp_n);\n      tmp_n       /= sum_tmp;\n      elc_ind(k,i) = tmp_n * P_age2len ;\n    }\n    iyr=yrs_ind(k,nyrs_ind(k));\n    dvar_vector natagetmp = elem_prod(S(endyr),natage(endyr));\n    natagetmp(2,nages) = ++natagetmp(1,nages-1);\n    natagetmp(1)       = SRecruit(Sp_Biom(endyr+1-rec_age));\n    natagetmp(nages)  += natage(endyr,nages)*S(endyr,nages);\n    // Assume same survival in 1st part of next year as same as first part of current\n    pred_ind_nextyr(k) = q_ind(k,nyrs_ind(k)) * pow(elem_prod(natagetmp,pow(S(endyr),ind_month_frac(k))) * \n                                     elem_prod(sel_ind(k,endyr) , wt_ind(k,endyr)),q_power_ind(k));\n  }\n\nFUNCTION Get_Fishery_Predictions\n  for (k=1;k<=nfsh;k++)\n  {\n    for (i=1; i<=nyrs_fsh_age(k); i++)\n    {\n      if (use_age_err)\n        eac_fsh(k,i) = age_err * catage(k,yrs_fsh_age(k,i))/sum(catage(k,yrs_fsh_age(k,i)));\n      else\n        eac_fsh(k,i) = catage(k,yrs_fsh_age(k,i))/sum(catage(k,yrs_fsh_age(k,i)));\n      eac_fsh(k,i) /= sum(eac_fsh(k,i));\n    }\n\n // predicted length compositions !!\n    for (i=1; i<=nyrs_fsh_length(k); i++)\n    {\n      elc_fsh(k,i) = catage(k,yrs_fsh_length(k,i))*P_age2len;\n      elc_fsh(k,i) /= sum(elc_fsh(k,i));\n    }\n  }\n\nFUNCTION Calc_Dependent_Vars\n  get_msy();\n\n  if (phase_proj>0) \n\t\tFuture_projections();\n  N_NoFsh.initialize();\n  N_NoFsh(styr) = natage(styr);\n  for (i=styr_sp;i<=styr;i++)\n    Sp_Biom_NoFish(i) = Sp_Biom(i);\n  for (i=styr;i<=endyr;i++)\n  {                 \n    recruits(i)  = natage(i,1);\n    if (i>styr)\n    {\n      N_NoFsh(i,1)        = recruits(i);\n      N_NoFsh(i,1)       *= SRecruit(Sp_Biom_NoFish(i-rec_age)) / SRecruit(Sp_Biom(i-rec_age));\n      N_NoFsh(i)(2,nages) = ++elem_prod(N_NoFsh(i-1)(1,nages-1),exp(-M(i-1)(1,nages-1)));\n      N_NoFsh(i,nages)   += N_NoFsh(i-1,nages)*exp(-M(i-1,nages));\n    }\n    totbiom_NoFish(i) = N_NoFsh(i)*wt_pop;\n    totbiom(i)        = natage(i)*wt_pop;\n    sumBiom(i)        = natage(i)(3,nages)*wt_pop(3,nages);\n    Sp_Biom_NoFish(i) = N_NoFsh(i)*elem_prod(pow(exp(-M(i)),spmo_frac) , wt_mature); \n    if (i>styr)\n\t\t  Sp_Biom_NoFishRatio(i) = Sp_Biom(i) / Sp_Biom_NoFish(i) ;\n    depletion         = totbiom(endyr)/totbiom(styr);\n    depletion_dyn     = totbiom(endyr)/totbiom_NoFish(endyr);\n  }\n  B100 = phizero * mean(recruits(styr_rec_est, endyr_rec_est));\n  dvar_vector Nnext(1,nages);\n  Nnext(2,nages) = ++elem_prod(natage(endyr)(1,nages-1),S(endyr)(1,nages-1));\n  Nnext(nages)  += natage(endyr,nages)*S(endyr,nages);\n  // Compute SSB in next year using mean recruits for age 1 and same survival as in endyr\n  Nnext(1)       = mfexp(mean_log_rec+rec_dev_future(endyr+1));\n  Sp_Biom(endyr+1)  = elem_prod(Nnext,pow(S(endyr),spmo_frac)) * wt_mature; \n  // Nnext(1)       = SRecruit(Sp_Biom(endyr+1-rec_age));\n  ABCBiom       = Nnext*wt_pop;\n  sumBiom(endyr+1) = Nnext(3,nages)*wt_pop(3,nages);\n  recruits(endyr+1) = Nnext(1);\n  totbiom(endyr+1)  = ABCBiom;\n  // Now do OFL for next year...\n  dvar_matrix seltmp(1,nfsh,1,nages);\n  dvar_matrix Fatmp(1,nfsh,1,nages);\n  dvar_vector Ztmp(1,nages);\n  seltmp.initialize();\n  Fatmp.initialize();\n  Ztmp.initialize();\n  for (k=1;k<=nfsh;k++)\n    seltmp(k) = (sel_fsh(k,endyr));\n  Ztmp = (M(styr));\n  for (k=1;k<=nfsh;k++)\n  { \n    Fatmp(k) = (Fratio(k) * Fmsy * seltmp(k));\n    Ztmp    += Fatmp(k);\n  } \n  dvar_vector survmsy = exp(-Ztmp);\n  dvar_vector ctmp(1,nages);\n  ctmp.initialize();\n  OFL=0.;\n  for (k=1;k<=nfsh;k++)\n  {\n      for ( j=1 ; j <= nages; j++ )\n        ctmp(j)      = Nnext(j) * Fatmp(k,j) * (1. - survmsy(j)) / Ztmp(j);\n      OFL  += wt_fsh(k,endyr) * ctmp;\n  }\n\nFUNCTION void Catch_at_Age(const int& i)\n  dvariable vbio=0.;\n  dvariable pentmp;\n  dvar_vector Nmid(1,nages);\n  dvar_vector Ctmp(1,nages);\n  catage_tot(i).initialize();\n  if (Popes)\n  {\n    Nmid = elem_prod(natage(i),mfexp(-M(i)/2) ); \n  }\n  for (k=1;k<=nfsh;k++)\n  {\n    if (Popes)\n    {\n      pentmp=0.;\n      Ctmp = elem_prod(Nmid,sel_fsh(k,i));\n      vbio = Ctmp*wt_fsh(k,i);\n      //Kludge to go here...\n      // dvariable SK = posfun( (.98*vbio - catch_bio(k,i))/vbio , 0.1 , pentmp );\n      dvariable SK = posfun( (vbio - catch_bio(k,i))/vbio , 0.1 , pentmp );\n      catch_tmp    = vbio - SK*vbio; \n      hrate        = catch_tmp / vbio;\n      fpen(4) += pentmp;\n      Ctmp *= hrate;                          \n      if (hrate>1) {cout << catch_tmp<<\" \"<<vbio<<endl;exit(1);}\n      catage_tot(i) += Ctmp;                      \n      catage(k,i)    = Ctmp;                      \n      if (last_phase())\n        pred_catch(k,i) = Ctmp*wt_fsh(k,i);\n    }\n    else\n    {\n      catage(k,i) = elem_prod(elem_div(F(k,i),Z(i)),elem_prod(1.-S(i),natage(i)));\n      pred_catch(k,i) = catage(k,i)*wt_fsh(k,i);\n    }\n  }\n  //+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==\nFUNCTION evaluate_the_objective_function\n  // if (active(fmort_dev))   \n  if (active(fmort))   \n  {\n    Cat_Like();\n    Fmort_Pen();\n  }\n  Rec_Like();\n  if (active(rec_dev))\n    Age_Like();\n  Srv_Like();\n  Sel_Like();\n  Compute_priors();\n  if (active(log_Rzero)) // OjO\n    obj_fun += .5 * square(log_Rzero-mean_log_rec); // A slight penalty to keep Rzero in reality...\n\n  obj_comps.initialize();\n  obj_comps(1)  = sum(catch_like);\n  obj_comps(2)  = sum(age_like_fsh);\n//------------------------------------------NEW-------------\n  obj_comps(3)  = sum(length_like_fsh);\n//-----------------------------------------------------------\n  obj_comps(4)  = sum(sel_like_fsh);\n  obj_comps(5)  = sum(ind_like);\n  obj_comps(6)  = sum(age_like_ind);\n  obj_comps(7)  = sum(length_like_ind);\n  obj_comps(8)  = sum(sel_like_ind);\n  obj_comps(9)  = sum(rec_like);\n  obj_comps(10) = sum(fpen);\n  obj_comps(11) = sum(post_priors_indq);\n  obj_comps(12) = sum(post_priors);\n  obj_fun     += sum(obj_comps);\n\nFUNCTION Cat_Like\n  // Eases into the catch-biomass likelihoods.  If too far off to start, full constraint to fit can be too aggressive\n  catch_like.initialize();\n  dvariable catch_pen;\n  switch (current_phase())\n  {\n    case 1:\n      catch_pen = .1;\n      break;\n    case 2:\n      catch_pen = .5;\n      break;\n    case 3:\n      catch_pen = .8;\n      break;\n    case 4:\n      catch_pen = 1.0;\n      break;\n    case 5:\n      catch_pen = 1;\n      break;\n    default:\n      catch_pen = 1;\n      break;\n  }\n  if (current_phase()>3)\n  {\n    for (k=1;k<=nfsh;k++)\n      for (i=styr;i<=endyr;i++)\n         catch_like(k) += .5*square(log(catch_bio(k,i)+.0001) - log(pred_catch(k,i)+.0001) )/catch_bio_lva(k,i);\n  }\n  else\n  {\n    for (k=1;k<=nfsh;k++)\n      catch_like(k) += catchbiomass_pen * norm2(log(catch_bio(k)   \n                      +.000001) - log(pred_catch(k) +.000001));\n  }\n\n  catch_like *= catch_pen;\n\nFUNCTION Rec_Like\n  rec_like.initialize();\n  if (active(rec_dev))\n  {\n    sigmar     =  mfexp(log_sigmar);\n    sigmarsq   =  square(sigmar);\n    if (current_phase()>2)\n    {\n      if (last_phase())\n        pred_rec = SRecruit(Sp_Biom(styr_rec-rec_age,endyr-rec_age).shift(styr_rec)(styr_rec,endyr));\n      else \n        pred_rec = .1+SRecruit(Sp_Biom(styr_rec-rec_age,endyr-rec_age).shift(styr_rec)(styr_rec,endyr));\n\n      dvariable SSQRec;\n      SSQRec.initialize();\n      dvar_vector chi(styr_rec_est,endyr_rec_est);\n      chi = log(mod_rec(styr_rec_est,endyr_rec_est)) - log(pred_rec(styr_rec_est,endyr_rec_est));\n      SSQRec   = norm2( chi ) ;\n      m_sigmarsq =  SSQRec/nrecs_est;\n      m_sigmar   =  sqrt(m_sigmarsq);\n\n      if (current_phase()>4||last_phase())\n        rec_like(1) = (SSQRec+ m_sigmarsq/2.)/(2*sigmarsq) + nrecs_est*log_sigmar; \n      else\n        rec_like(1) = .1*(SSQRec+ m_sigmarsq/2.)/(2*sigmarsq) + nrecs_est*log_sigmar; \n    }\n\n    // Variance term for the parts not estimated by sr curve\n    if (last_phase())\n    {\n      rec_like(4) += .5*norm2( rec_dev(styr_rec,styr_rec_est) )/sigmarsq + (styr_rec_est-styr_rec)*log(sigmar) ; \n      if ( endyr > endyr_rec_est)\n        rec_like(4) += .5*norm2( rec_dev(endyr_rec_est,endyr  ) )/sigmarsq + (endyr-endyr_rec_est)*log(sigmar) ; \n    }\n    else // JNI comment next line\n       rec_like(2) += norm2( rec_dev(styr_rec,endyr) ) ;\n\n    // rec_like(2) += norm2( rec_dev(styr_rec_est,endyr) ) ;\n\n    if (active(rec_dev_future))\n    {\n      // Future recruitment variability (based on past)\n      sigmar_fut   = sigmar ;\n      rec_like(3) += norm2(rec_dev_future)/(2*square(sigmar_fut))+ size_count(rec_dev_future)*log(sigmar_fut);\n    }\n  }\n\nFUNCTION Compute_priors\n  post_priors.initialize();\n  post_priors_indq.initialize();\n  for (k=1;k<=nind;k++)\n  {\n    if (active(log_q_ind(k)))\n      post_priors_indq(k) += square(log(q_ind(k,1)/qprior(k)))/(2.*cvqprior(k)*cvqprior(k)); \n    if (active(log_q_power_ind(k)))\n      post_priors_indq(k) += square(log(q_power_ind(k)/q_power_prior(k)))/(2.*cvq_power_prior(k)*cvq_power_prior(k)); \n    if (active(log_rw_q_ind(k)))\n      for (int i=1;i<=npars_rw_q(k);i++)\n      {\n        post_priors_indq(k) += square(log_rw_q_ind(k,i))/ (2.*sigma_rw_q(k,i)*sigma_rw_q(k,i)) ;\n      }\n     //  -q_power_prior(k))/(2*cvq_power_prior(k)*cvq_power_prior(k)); \n  }\n\n  if (active(Mest))\n    post_priors(1) += square(log(Mest/natmortprior))/(2.*cvnatmortprior*cvnatmortprior); \n\n  if (active(Mage_offset))  \n    post_priors(1) += norm2(Mage_offset)/(2.*cvnatmortprior*cvnatmortprior); \n\n  if (active(M_rw))\n    for (int i=1;i<=npars_rw_M;i++)\n      post_priors(1) +=  square(M_rw(i))/ (2.*sigma_rw_M(i)*sigma_rw_M(i)) ;\n\n  if (active(steepness))\n    post_priors(2) += square(log(steepness/steepnessprior))/(2*cvsteepnessprior*cvsteepnessprior); \n\n  if (active(log_sigmar))\n    post_priors(3) += square(log(sigmar/sigmarprior))/(2*cvsigmarprior*cvsigmarprior); \n\n\n//--------------------------NEW------------------------------------\n  if (active(log_Linf))\n    post_priors(4) += square(log_Linf-log_Linfprior)/(2*cvLinfprior*cvLinfprior); \n\n  if (active(log_k))\n    post_priors(5) += square(log_k-log_kprior)/(2*cvkprior*cvkprior); \n\n  if (active(log_Lo))\n    post_priors(6) += square(log_Lo-log_Loprior)/(2*cvLoprior*cvLoprior); \n\n  if (active(log_sdage))\n    post_priors(7) += square(log_sdage-log_sdageprior)/(2*cvsdageprior*cvsdageprior); \n\nFUNCTION Fmort_Pen\n  // Phases less than 3, penalize High F's---------------------------------\n  if (current_phase()<3)\n    fpen(1) += 1.* norm2(F - .2);\n  else \n    fpen(1) += 0.0001*norm2(F - .2); \n\n  // for (k=1;k<=nfsh;k++)  fpen(2) += 20.*square(mean(fmort_dev(k)) ); // this is just a normalizing constraint (fmort_devs sum to zero) }\n    \nFUNCTION Sel_Like \n  sel_like_fsh.initialize();\n  sel_like_ind.initialize();\n  for (k=1;k<=nfsh;k++)\n  {\n    if (active(logsel_p1_fsh(k))||active(logsel_slope_fsh(k)))\n    {\n      sel_like_fsh(k,3)    += .1*square( logsel_p1_fsh(k,1) )  ;\n      sel_like_fsh(k,3)    += .1*square(    sel_p2_fsh(k,1) )  ;\n      sel_like_fsh(k,3)    += .1*square( logsel_p3_fsh(k,1) )  ;\n      for (i=2;i<=n_sel_ch_fsh(k);i++)\n      {\n          int iyr = yrs_sel_ch_fsh(k,i) ;\n          dvariable var_tmp = square(sel_sigma_fsh(k,i));\n\n          sel_like_fsh(k,2)    += .5*norm2( log_sel_fsh(k,iyr-1) - log_sel_fsh(k,iyr) ) / var_tmp ;\n          sel_like_fsh(k,3)    += .1*square( logsel_p1_fsh(k,i) )  ;\n          sel_like_fsh(k,3)    += .1*square(    sel_p2_fsh(k,i) )  ;\n          sel_like_fsh(k,3)    += .1*square( logsel_p3_fsh(k,i) )  ;\n      }\n    }\n\n    if (active(log_selcoffs_fsh(k)))\n    {\n      for (i=1;i<=n_sel_ch_fsh(k);i++)\n      {\n        int iyr = yrs_sel_ch_fsh(k,i) ;\n        // If curvature penalty is assumed....\n        sel_like_fsh(k,1) += curv_pen_fsh(k)*norm2(first_difference( first_difference(log_sel_fsh(k,iyr))));\n        // If curvature penalty (sigma) is estimated....\n        // dvariable var=mfexp(2.0*logSdsmu_fsh(k));\n        // sel_like_fsh(k,1) += 0.5*(size.count(log_sel_fsh(k,iyr))*log(var) +  norm2(first_difference( first_difference(log_sel_fsh(k,iyr)))) /var);\n        if (i>1)\n        {\n          // This part is the penalty on the change itself--------------\n          dvariable var_tmp = square(sel_sigma_fsh(k,i));\n          sel_like_fsh(k,2)    += .5*norm2( log_sel_fsh(k,iyr-1) - log_sel_fsh(k,iyr) ) / var_tmp ;\n        }\n        int nagestmp = nselages_fsh(k);\n        for (j=seldecage;j<=nagestmp;j++)\n        {\n          dvariable difftmp = log_sel_fsh(k,iyr,j-1)-log_sel_fsh(k,iyr,j) ;\n          if (difftmp > 0.)\n            sel_like_fsh(k,3)    += .5*square( difftmp ) / seldec_pen_fsh(k);\n        }\n        obj_fun            += 20 * square(avgsel_fsh(k,i)); // To normalize selectivities\n      }\n    }\n  }\n  for (k=1;k<=nind;k++)\n  {\n    if (active(logsel_slope_ind(k)))\n    {\n      for (i=2;i<=n_sel_ch_ind(k);i++)\n      {\n          int iyr = yrs_sel_ch_ind(k,i) ;\n          dvariable var_tmp = square(sel_sigma_ind(k,i));\n          sel_like_ind(k,2)    += .5*norm2( log_sel_ind(k,iyr-1) - log_sel_ind(k,iyr) ) / var_tmp ;\n      }\n    }\n    if (active(log_selcoffs_ind(k)))\n    {\n      int nagestmp = nselages_ind(k);\n      for (i=1;i<=n_sel_ch_ind(k);i++)\n      {\n        int iyr = yrs_sel_ch_ind(k,i) ;\n        sel_like_ind(k,1) += curv_pen_ind(k)*norm2(first_difference( first_difference(log_sel_ind(k,iyr))));\n        // This part is the penalty on the change itself--------------\n        if (i>1)\n        {\n          dvariable var_tmp = square(sel_sigma_ind(k,i));\n          sel_like_ind(k,2)    += .5*norm2( log_sel_ind(k,iyr-1) - log_sel_ind(k,iyr) ) / var_tmp ;\n        }\n        for (j=seldecage;j<=nagestmp;j++)\n        {\n          dvariable difftmp = log_sel_ind(k,iyr,j-1)-log_sel_ind(k,iyr,j) ;\n          if (difftmp > 0.)\n            sel_like_ind(k,3)    += .5*square( difftmp ) / seldec_pen_ind(k);\n        }\n        obj_fun            += 20. * square(avgsel_ind(k,i));  // To normalize selectivities\n      }\n    }\n  }\n\nFUNCTION Srv_Like\n  // Fit to indices (log-Normal) -------------------------------------------\n  ind_like.initialize();\n  int iyr;\n  for (k=1;k<=nind;k++)\n    for (i=1;i<=nyrs_ind(k);i++)\n    {\n      // iyr = int(yrs_ind(k,i));\n      ind_like(k) += square(log(obs_ind(k,i)) - log(pred_ind(k,i)) ) / \n                                   (2.*obs_lse_ind(k,i)*obs_lse_ind(k,i));\n    }\n  /* normal distribution option to add someday...\n    for (i=1;i<=nyrs_ind(k);i++)\n      ind_like(k) += square(obs_ind(k,i) - pred_ind(k,yrs_ind(k,i)) ) / \n                                   (2.*obs_se_ind(k,i)*obs_se_ind(k,i));\n  */\n\nFUNCTION Age_Like\n  age_like_fsh.initialize();\n\tdvariable nsamtheta;\n  for (k=1;k<=nfsh;k++)\n    for (int i=1;i<=nyrs_fsh_age(k);i++)\n      age_like_fsh(k) -= n_sample_fsh_age(k,i)*(oac_fsh(k,i) + 0.001) * log(eac_fsh(k,i) + 0.001 ) ;\n  age_like_fsh -= offset_fsh;\n  /*\n  logistic_normal cMyAgeComp(oac_fsh(1),eac_fsh(1));\n  age_like_fsh = cMyAgeComp.negative_loglikelihood(tau);\n        // dirichlet-multinomial\n  for (k=1;k<=nfsh;k++)\n    for (int i=1;i<=nyrs_fsh_age(k);i++)\n\t\t{\n\t\t\t nsamtheta = n_sample_fsh_age(k,i)*theta ;\n       age_like_fsh(k) -= lgamma( nsamtheta );\n       age_like_fsh(k) += lgamma( n_sample_fsh_age(k,i) + nsamtheta );\n       for(j=1; j<=nages; j++)\n\t\t\t {\n         age_like_fsh(k) -= lgamma( AgeComp_at(AgeI,YearI) + \n\t\t\t\t            theta*n_samp(YearI)*(Cn_at(AgeI,YearI)/tmp_sum*0.9999 + 0.0001/(AgeMax+1)) );\n         age_like_fsh(k) += lgamma( theta*n_samp(YearI)*(Cn_at(AgeI,YearI)/tmp_sum*0.9999 + 0.0001/(AgeMax+1)) );\n       }\n       n_effective(YearI) = 1/(1+theta) + n_samp(YearI)*(theta/(1+theta));\n     }\n\t\n  */\n\n//-----------------------------------NEW-----------------------\n  length_like_fsh.initialize();\n  for (k=1;k<=nfsh;k++)\n    for (int i=1;i<=nyrs_fsh_length(k);i++)\n      length_like_fsh(k) -= n_sample_fsh_length(k,i)*(olc_fsh(k,i) + 0.001) * log(elc_fsh(k,i) + 0.001 ) ;\n  length_like_fsh -= offset_lfsh;\n//----------------------------------------------------------\n  length_like_ind.initialize();\n  for (k=1;k<=nind;k++)\n    for (int i=1;i<=nyrs_ind_length(k);i++)\n      length_like_ind(k) -= n_sample_ind_length(k,i)*(olc_ind(k,i) + 0.001) * log(elc_ind(k,i) + 0.001 ) ;\n  length_like_ind -= offset_lind;\n//----------------------------------------------------------\n  age_like_ind.initialize();\n  for (k=1;k<=nind;k++)\n    for (int i=1;i<=nyrs_ind_age(k);i++)\n      age_like_ind(k) -= n_sample_ind_age(k,i)*(oac_ind(k,i) + 0.001) * log(eac_ind(k,i) + 0.001 ) ;\n  age_like_ind -= offset_ind;\n\nFUNCTION Oper_Model\n // Initialize things used here only\n  mc_count++;\n  get_msy();\n  Write_SimDatafile();\n  Write_Datafile();\n  dmatrix new_ind(1,nind,1,nyrs_ind);\n  new_ind.initialize();\n\n  int nsims;\n  ifstream sim_in(\"nsims.dat\");\n  sim_in >> nsims; sim_in.close();\n\n  dvector ran_ind_vect(1,nind);\n  ofstream SaveOM(\"Om_Out.dat\",ios::app);\n  double C_tmp;\n  dvariable Fnow;\n  // Initialize recruitment in first year\n  for (i=styr_fut-rec_age;i<styr_fut;i++)\n    Sp_Biom_future(i) = Sp_Biom(i);\n  nage_future(styr_fut)(2,nages)              = ++elem_prod(natage(endyr)(1,nages-1),S(endyr)(1,nages-1));\n  nage_future(styr_fut,nages)                += natage(endyr,nages)*S(endyr,nages);\n\n  // assume survival same as in last year...\n  Sp_Biom_future(styr_fut) = elem_prod(nage_future(styr_fut),pow(S(endyr),spmo_frac)) * wt_mature; \n  for (int isim=1;isim<=nsims;isim++)\n  {\n    cout<<isim<<\" \"<<cmp_no<<\" \"<<mc_count<<\" \"<<endl;\n    // Copy file to get mean for Mgt Strategies\n    system(\"init_stuff.bat\");\n    for (i=styr_fut;i<=endyr_fut;i++)\n    {\n      // Some unit normals...for generating data\n      ran_ind_vect.fill_randn(rng);\n      cout<<ran_ind_vect<<endl;\n      // Create new indices observations\n      // for (k = 1 ; k<= nind ; k++) new_ind(k) = mfexp(ran_ind_vect(k)*.2)*value(nage_future(i)*q_ind(k,nyrs_ind(k))*sel_ind(k,endyr)); // use value function since converts to a double\n      // new_ind(1) = mfexp(ran_ind_vect(1)*0.2)*value(sum(nage_future(i)*q_ind(1,nyrs_ind(1))));\n      if(styr_fut==i)\n        new_ind(1) = mfexp(ran_ind_vect(1)*0.2)*value(wt_ind(1,endyr)*(natage(i-1)));\n      else\n        new_ind(1) = mfexp(ran_ind_vect(1)*0.2)*value(wt_ind(1,endyr)*(nage_future(i-1)));\n      // now for Selecting which MP to use\n      // Append new indices observation to datafile\n      ifstream tacin(\"ctac.dat\");\n      int nobstmp;\n      tacin >> nobstmp ;\n      dvector t_tmp(1,nobstmp);\n      tacin >> t_tmp;\n      tacin.close();\n      ofstream octac(\"ctac.dat\");\n      octac<<nobstmp+1<<endl;\n      octac<<t_tmp<<endl;\n      octac<<new_ind(1)<<endl;\n      octac.close();\n      system(\"ComputeTAC.bat \" + (itoa(cmp_no,10))); // commandline function to get TAC (catchnext.dat)\n     // Now read in TAC (actual catch)\n     ifstream CatchNext(\"CatchNext.dat\");\n     CatchNext >> C_tmp; \n     CatchNext.close();\n     //if (cmp_no==5) C_tmp=value((natmort(styr))*mean(t_tmp(nobstmp-2,nobstmp)));\n     //if (cmp_no==6) C_tmp=value((natmort(styr))*.75*mean(t_tmp(nobstmp-2,nobstmp)));\n     if (cmp_no==5) \n     {\n       C_tmp = min(C_tmp*1.1,value((natmort(styr)*t_tmp(nobstmp))));\n       ofstream cnext(\"CatchNext.dat\");\n       cnext <<C_tmp<<endl;\n       cnext.close();\n     }\n     if (cmp_no==6) \n     {\n       C_tmp = min(C_tmp*1.1,value(natmort(styr)*.75*t_tmp(nobstmp)));\n       ofstream cnext(\"CatchNext.dat\");\n       cnext <<C_tmp<<endl;\n       cnext.close();\n     }\n\n     Fnow = SolveF2(endyr,nage_future(i), C_tmp);\n\n      F_future(1,i) = sel_fsh(1,endyr) * Fnow;\n      //Z_future(i)   = F_future(1,i) + max(natmort);\n      Z_future(i)   = F_future(1,i) + mean(M);\n      S_future(i)   = mfexp(-Z_future(i));\n      nage_future(i,1)  = SRecruit( Sp_Biom_future(i-rec_age) ) * mfexp(rec_dev_future(i)) ;     \n      Sp_Biom_future(i) = wt_mature * elem_prod(nage_future(i),pow(S_future(i),spmo_frac)) ;\n      // Now graduate for the next year....\n      if (i<endyr_fut)\n      {\n        nage_future(i+1)(2,nages) = ++elem_prod(nage_future(i)(1,nages-1),S_future(i)(1,nages-1));\n        nage_future(i+1,nages)   += nage_future(i,nages)*S_future(i,nages);\n      }\n      catage_future(i) = 0.; \n      for (k = 1 ; k<= nfsh ; k++)\n        catage_future(i) += elem_prod(nage_future(i) , elem_prod(F_future(k,i) , elem_div( ( 1.- S_future(i) ) , Z_future(i))));\n  \n      SaveOM << model_name       <<\n        \" \"  << cmp_no           <<\n        \" \"  << mc_count         <<\n        \" \"  << isim             <<\n        \" \"  << i                <<\n        \" \"  << Fnow             <<\n        \" \"  << Fnow/Fmsy        <<\n        \" \"  << Sp_Biom_future(i-rec_age)                       <<\n        \" \"  << nage_future(i)                                  <<\n        \" \"  << catage_future(i)*wt_fsh(1,endyr)                <<\n        \" \"  << mean(M)                                   <<\n        \" \"  << t_tmp(nobstmp)                                  <<\n      endl;\n    }\n  }\n  // if (mc_count>5) exit(1);\n  SaveOM.close();\n  if (!mceval_phase())\n    exit(1);\n\nFUNCTION void get_future_Fs(const int& i,const int& iscenario)\n    f_tmp.initialize();\n    dvar_matrix F_fut_tmp(1,nfsh,1,nages);\n    for (k=1;k<=nfsh;k++) F_fut_tmp(k) =F(k,endyr);\n    switch (iscenario)\n    {\n      case 1:\n        // f_tmp = F35;\n        for (int k=1;k<=nfsh;k++) f_tmp(k) = mean(F(k,endyr));\n        // for (int k=1;k<=nfsh;k++) f_tmp(k) = SolveF2(endyr,nage_future(i), 1.0  * catch_lastyr(k));\n        break;\n      case 2:\n        // for (int k=1;k<=nfsh;k++) f_tmp(k) = Fratio(k)*Fmsy; // mean(F(k,endyr));\n        for (int k=1;k<=nfsh;k++) f_tmp(k) = mean(F(k,endyr));\n        f_tmp *= 0.75;\n        break;\n      case 3:\n        for (int k=1;k<=nfsh;k++) f_tmp(k) = mean(F(k,endyr));\n        f_tmp *= 0.5;\n        break;\n      case 4:\n        // for (int k=1;k<=nfsh;k++) f_tmp(k) = .25*mean(F(k,endyr));\n        // F_fut_tmp *= 0.25;\n        for (int k=1;k<=nfsh;k++) f_tmp(k) = mean(F(k,endyr));\n        f_tmp *= 0.25;\n      case 5:\n        f_tmp = 0.0;\n        F_fut_tmp = 0.0;\n        break;\n    }\n    Z_future(i) = M(endyr);\n    for (k=1;k<=nfsh;k++)\n    {\n      F_future(k,i) = sel_fsh(k,endyr) * f_tmp(k);\n      Z_future(i)  += F_future(k,i);\n    }\n    S_future(i) = mfexp(-Z_future(i));\n\nFUNCTION Future_projections\n  // Need to check on treatment of Fratio--whether it should be included or not\n  SSB_fut.initialize();\n  catch_future.initialize();\n  for (int iscen=1;iscen<=5;iscen++)\n  {\n   // Future Sp_Biom set equal to estimated Sp_Biom w/ right lag\n    // Sp_Biom_future(styr_fut-rec_age,styr_fut-1) = Sp_Biom(endyr-rec_age+1,endyr);\n    for (i=styr_fut-rec_age;i<styr_fut;i++)\n      Sp_Biom_future(i) = wt_mature * elem_prod(natage(i),pow(S(i),spmo_frac)) ;\n\n    nage_future(styr_fut)(2,nages) = ++elem_prod(natage(endyr)(1,nages-1),S(endyr)(1,nages-1));\n    nage_future(styr_fut,nages)   += natage(endyr,nages)*S(endyr,nages);\n    Sp_Biom_future(styr_fut)       = wt_mature * elem_prod(nage_future(i),pow(S_future(i),spmo_frac)) ;\n    // Future Recruitment (and Sp_Biom)\n    for (i=styr_fut;i<endyr_fut;i++)\n    {\n      nage_future(i,1)  = SRecruit( Sp_Biom_future(i-rec_age) ) * mfexp(rec_dev_future(i)) ;     \n      get_future_Fs(i,iscen);\n      // Now graduate for the next year....\n      nage_future(i+1)(2,nages) = ++elem_prod(nage_future(i)(1,nages-1),S_future(i)(1,nages-1));\n      nage_future(i+1,nages)   += nage_future(i,nages)*S_future(i,nages);\n      Sp_Biom_future(i) = wt_mature * elem_prod(nage_future(i),pow(S_future(i),spmo_frac)) ;\n    }\n    nage_future(endyr_fut,1)  = SRecruit( Sp_Biom_future(endyr_fut-rec_age) ) * mfexp(rec_dev_future(endyr_fut)) ;     \n    get_future_Fs(endyr_fut,iscen);\n    Sp_Biom_future(endyr_fut)  = wt_mature * elem_prod(nage_future(endyr_fut),pow(S_future(endyr_fut),spmo_frac)) ;\n    /*\n\t\tif (iscen==1)\n    {\n      for (i=endyr+1;i<=endyr_fut;i++)\n      {                   \n        N_NoFsh(i,1)        = nage_future(i,1);\n        // Adjustment for no-fishing recruits (ratio of R_nofish/R_fish)\n        N_NoFsh(i,1)       *= SRecruit(Sp_Biom_NoFish(i-rec_age)) / SRecruit(Sp_Biom_future(i-rec_age));\n        N_NoFsh(i)(2,nages) = ++N_NoFsh(i-1)(1,nages-1)*exp(-mean(natmort));\n        N_NoFsh(i,nages)   +=   N_NoFsh(i-1,nages)*exp(-mean(natmort));\n        Sp_Biom_NoFish(i)   = (N_NoFsh(i)*pow(exp(-mean(natmort)),spmo_frac) * wt_mature); \n        // Sp_Biom_NoFishRatio(i)  = Sp_Biom_future(i) / Sp_Biom_NoFish(i) ;\n      }\n    }\n    */\n    // Now get catch at future ages\n    dvar_vector catage_tmp(1,nages);\n    for (i=styr_fut; i<=endyr_fut; i++)\n    {\n      catage_future(i).initialize();\n      if (iscen!=5) \n      {\n        for (k = 1 ; k<= nfsh ; k++)\n        {\n          catage_tmp.initialize();\n          catage_tmp = elem_prod(nage_future(i) , elem_prod(F_future(k,i) , \n                                elem_div( ( 1.- S_future(i) ) , Z_future(i))));\n          catage_future(i) += catage_tmp;\n          catch_future(iscen,i)  += catage_tmp*wt_fsh(k,endyr);\n        }\n      }\n      SSB_fut(iscen,i) = Sp_Biom_future(i);\n    }\n  }   //End of loop over F's\n  Sp_Biom(endyr+1) = Sp_Biom_future(endyr+1);\n\nFUNCTION get_msy\n  /** Function calculates used in calculating MSY and MSYL for a designated component of the\n  population, given values for stock recruitment and selectivity...  \n  Fmsy is the trial value of MSY example of the use of \"funnel\" to reduce the amount of storage for derivative calculations \n  */\n\n  dvariable sumF=0.;\n  for (k=1;k<=nfsh;k++)\n    sumF += sum(F(k,endyr));\n  for (k=1;k<=nfsh;k++)\n    Fratio(k) = sum(F(k,endyr)) / sumF;\n\n  dvariable Stmp;\n  dvariable Rtmp;\n  double df=1.e-05;\n  dvariable F1;\n  F1.initialize();\n  F1 = (0.8*natmortprior);\n  dvariable F2;\n  dvariable F3;\n  dvariable yld1;\n  dvariable yld2;\n  dvariable yld3;\n  dvariable dyld;\n  dvariable dyldp;\n  int breakout=0;\n  // Newton Raphson stuff to go here\n  for (int ii=1;ii<=8;ii++)\n  {\n    if (mceval_phase()&&(F1>5||F1<0.01)) \n    {\n      ii=8;\n      if (F1>5) F1=5.0; \n      else      F1=0.001; \n      breakout    = 1;\n    }\n    F2     = F1 + df*.5;\n    F3     = F2 - df;\n    // yld1   = yield(Fratio,F1, Stmp,Rtmp); // yld2   = yield(Fratio,F2,Stmp,Rtmp); // yld3   = yield(Fratio,F3,Stmp,Rtmp);\n    yld1   = yield(Fratio,F1);\n    yld2   = yield(Fratio,F2);\n    yld3   = yield(Fratio,F3);\n    dyld   = (yld2 - yld3)/df;                          // First derivative (to find the root of this)\n    dyldp  = (yld2 + yld3 - 2.*yld1)/(.25*df*df);       // Second derivative (for Newton Raphson)\n    if (breakout==0)\n    {\n      F1    -= dyld/dyldp;\n    }\n    else\n    {\n      if (F1>5) \n        cout<<\"Fmsy v. high \"<< endl;// yld1<<\" \"<< yld2<<\" \"<< yld3<<\" \"<< F1<<\" \"<< F2<<\" \"<< F3<<\" \"<< endl;\n      else      \n        cout<<\"Fmsy v. low \"<< endl;// yld1<<\" \"<< yld2<<\" \"<< yld3<<\" \"<< F1<<\" \"<< F2<<\" \"<< F3<<\" \"<< endl;\n    }\n  }\n  {\n    dvar_vector ttt(1,5);\n    ttt      = yld(Fratio,F1);\n    Fmsy     = F1;\n    Rtmp     = ttt(3);\n    MSY      = ttt(2);\n    Bmsy     = ttt(1);\n    MSYL     = ttt(1)/Bzero;\n    lnFmsy   = log(MSY/ttt(5)); // Exploitation fraction relative to total biomass\n    Bcur_Bmsy= Sp_Biom(endyr)/Bmsy;\n\n    dvariable FFtmp;\n    FFtmp.initialize();\n    for (k=1;k<=nfsh;k++)\n      FFtmp += mean(F(k,endyr));\n    Fcur_Fmsy= FFtmp/Fmsy;\n    Rmsy     = Rtmp;\n  }\n\nFUNCTION void get_msy(int iyr)\n  /** Function calculates used in calculating MSY and MSYL for a designated component of the\n  population, given values for stock recruitment and selectivity...  \n  Fmsy is the trial value of MSY example of the use of \"funnel\" to reduce the amount of storage for derivative calculations */\n\n  dvariable sumF=0.;\n  for (k=1;k<=nfsh;k++)\n    sumF += sum(F(k,iyr));\n  for (k=1;k<=nfsh;k++)\n    Fratio(k) = sum(F(k,iyr)) / sumF;\n\n  dvariable Stmp;\n  dvariable Rtmp;\n  double df=1.e-05;\n  dvariable F1;\n  F1.initialize();\n  F1 = (0.8*natmortprior);\n  dvariable F2;\n  dvariable F3;\n  dvariable yld1;\n  dvariable yld2;\n  dvariable yld3;\n  dvariable dyld;\n  dvariable dyldp;\n  int breakout=0;\n  // Newton Raphson stuff to go here\n  for (int ii=1;ii<=8;ii++)\n  {\n    if (mceval_phase()&&(F1>5||F1<0.01)) \n    {\n      ii=8;\n      if (F1>5) F1=5.0; \n      else      F1=0.001; \n      breakout    = 1;\n    }\n    F2     = F1 + df*.5;\n    F3     = F2 - df;\n    // yld1   = yield(Fratio,F1, Stmp,Rtmp); // yld2   = yield(Fratio,F2,Stmp,Rtmp); // yld3   = yield(Fratio,F3,Stmp,Rtmp);\n    yld1   = yield(Fratio,F1,iyr);\n    yld2   = yield(Fratio,F2,iyr);\n    yld3   = yield(Fratio,F3,iyr);\n    dyld   = (yld2 - yld3)/df;                          // First derivative (to find the root of this)\n    dyldp  = (yld2 + yld3 - 2.*yld1)/(.25*df*df);   // Second derivative (for Newton Raphson)\n    if (breakout==0)\n    {\n      F1    -= dyld/dyldp;\n    }\n    else\n    {\n      if (F1>5) \n        cout<<\"Fmsy v. high \"<< endl;// yld1<<\" \"<< yld2<<\" \"<< yld3<<\" \"<< F1<<\" \"<< F2<<\" \"<< F3<<\" \"<< endl;\n      else      \n        cout<<\"Fmsy v. low \"<< endl;// yld1<<\" \"<< yld2<<\" \"<< yld3<<\" \"<< F1<<\" \"<< F2<<\" \"<< F3<<\" \"<< endl;\n    }\n  }\n  {\n    dvar_vector ttt(1,5);\n    ttt      = yld(Fratio,F1,iyr);\n    Fmsy     = F1;\n    Rtmp     = ttt(3);\n    MSY      = ttt(2);\n    Bmsy     = ttt(1);\n    MSYL     = ttt(1)/Bzero;\n    lnFmsy   = log(MSY/ttt(5)); // Exploitation fraction relative to total biomass\n    Bcur_Bmsy= Sp_Biom(iyr)/Bmsy;\n\n    dvariable FFtmp;\n    FFtmp.initialize();\n    for (k=1;k<=nfsh;k++)\n      FFtmp += mean(F(k,iyr));\n    Fcur_Fmsy= FFtmp/Fmsy;\n    Rmsy     = Rtmp;\n  }\n\nFUNCTION dvar_vector yld(const dvar_vector& Fratio, const dvariable& Ftmp,int iyr)\n  RETURN_ARRAYS_INCREMENT();\n  /*dvariable utmp=1.-mfexp(-(Ftmp)); dvariable Ntmp; dvariable Btmp; dvariable yield; dvariable survtmp=exp(-1.*natmort); dvar_vector seltmp=sel_fsh(endyr); Ntmp = 1.; Btmp = Ntmp*wt(1)*seltmp(1); Stmp = .5*Ntmp*wt(1)*maturity(1); yield= 0.; for ( j=1 ; j < nages ; j++ ) { Ntmp  *= (1.-utmp*seltmp(j))*survtmp; Btmp  += Ntmp*wt(j+1)*seltmp(j+1); Stmp  += .5 * Ntmp *wt(j+1)*maturity(j+1); } //Max Age - 1 yr yield   += utmp * Btmp; Ntmp    /= (1-survtmp*(1.-utmp*seltmp(nages))); Btmp    += Ntmp*wt(nages)*seltmp(nages); Stmp    += 0.5 *wt(nages)* Ntmp *maturity(nages); yield   += utmp * Btmp; //cout<<yield<<\" \"<<Stmp<<\" \"<<Btmp<<\" \";*/\n  dvar_vector msy_stuff(1,5);\n  dvariable phi;\n  dvar_vector Ntmp(1,nages);\n  dvar_vector Ctmp(1,nages);\n  msy_stuff.initialize();\n\n  dvar_matrix seltmp(1,nfsh,1,nages);\n  for (k=1;k<=nfsh;k++)\n   seltmp(k) = sel_fsh(k,iyr); // NOTE uses last-year of fishery selectivity for projections.\n\n  dvar_matrix Fatmp(1,nfsh,1,nages);\n  dvar_vector Ztmp(1,nages);\n\n  Ztmp = M(iyr);\n  for (k=1;k<=nfsh;k++)\n  { \n    Fatmp(k) = Fratio(k) * Ftmp * seltmp(k);\n    Ztmp    += Fatmp(k);\n  } \n  dvar_vector survtmp = mfexp(-Ztmp);\n\n  Ntmp(1) = 1.;\n  for ( j=1 ; j < nages; j++ )\n    Ntmp(j+1)  =   Ntmp(j) * survtmp(j); // Begin numbers in the next year/age class\n  Ntmp(nages)  /= (1.- survtmp(nages)); \n\n  for (k=1;k<=nfsh;k++)\n  {\n    Ctmp.initialize();\n    for ( j=1 ; j <= nages; j++ )\n      Ctmp(j)      = Ntmp(j) * Fatmp(k,j) * (1. - survtmp(j)) / Ztmp(j);\n\n    msy_stuff(2)  += wt_fsh(k,iyr) * Ctmp;\n  }\n  phi    = elem_prod( Ntmp , pow(survtmp,spmo_frac ) ) * wt_mature;\n  // Req    = Requil(phi) * exp(sigmarsq/2);\n  msy_stuff(5)  = Ntmp * wt_pop;      \n  msy_stuff(4)  = phi/phizero ;       // SPR\n  msy_stuff(3)  = Requil(phi) ;       // Eq Recruitment\n  msy_stuff(5) *= msy_stuff(3);       // BmsyTot\n  msy_stuff(2) *= msy_stuff(3);       // MSY\n  msy_stuff(1)  = phi*(msy_stuff(3)); // Bmsy\n  RETURN_ARRAYS_DECREMENT();\n  return msy_stuff;\n\n //+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+ \nFUNCTION dvar_vector yld(const dvar_vector& Fratio, const dvariable& Ftmp)\n  RETURN_ARRAYS_INCREMENT();\n  /*dvariable utmp=1.-mfexp(-(Ftmp)); dvariable Ntmp; dvariable Btmp; dvariable yield; dvariable survtmp=exp(-1.*natmort); dvar_vector seltmp=sel_fsh(endyr); Ntmp = 1.; Btmp = Ntmp*wt(1)*seltmp(1); Stmp = .5*Ntmp*wt(1)*maturity(1); yield= 0.; for ( j=1 ; j < nages ; j++ ) { Ntmp  *= (1.-utmp*seltmp(j))*survtmp; Btmp  += Ntmp*wt(j+1)*seltmp(j+1); Stmp  += .5 * Ntmp *wt(j+1)*maturity(j+1); } //Max Age - 1 yr yield   += utmp * Btmp; Ntmp    /= (1-survtmp*(1.-utmp*seltmp(nages))); Btmp    += Ntmp*wt(nages)*seltmp(nages); Stmp    += 0.5 *wt(nages)* Ntmp *maturity(nages); yield   += utmp * Btmp; //cout<<yield<<\" \"<<Stmp<<\" \"<<Btmp<<\" \";*/\n  dvar_vector msy_stuff(1,5);\n  dvariable phi;\n  dvar_vector Ntmp(1,nages);\n  dvar_vector Ctmp(1,nages);\n  msy_stuff.initialize();\n\n  dvar_matrix seltmp(1,nfsh,1,nages);\n  for (k=1;k<=nfsh;k++)\n   seltmp(k) = sel_fsh(k,endyr); // NOTE uses last-year of fishery selectivity for projections.\n\n  dvar_matrix Fatmp(1,nfsh,1,nages);\n  dvar_vector Ztmp(1,nages);\n\n  Ztmp = M(styr);\n  for (k=1;k<=nfsh;k++)\n  { \n    Fatmp(k) = Fratio(k) * Ftmp * seltmp(k);\n    Ztmp    += Fatmp(k);\n  } \n  dvar_vector survtmp = mfexp(-Ztmp);\n\n  Ntmp(1) = 1.;\n  for ( j=1 ; j < nages; j++ )\n    Ntmp(j+1)  =   Ntmp(j) * survtmp(j); // Begin numbers in the next year/age class\n  Ntmp(nages)  /= (1.- survtmp(nages)); \n\n  for (k=1;k<=nfsh;k++)\n  {\n    Ctmp.initialize();\n    for ( j=1 ; j <= nages; j++ )\n      Ctmp(j)      = Ntmp(j) * Fatmp(k,j) * (1. - survtmp(j)) / Ztmp(j);\n\n    msy_stuff(2)  += wt_fsh(k,endyr) * Ctmp;\n  }\n  phi    = elem_prod( Ntmp , pow(survtmp,spmo_frac ) ) * wt_mature;\n  // Req    = Requil(phi) * exp(sigmarsq/2);\n  msy_stuff(5)  = Ntmp * wt_pop;      \n  msy_stuff(4)  = phi/phizero ;       // SPR\n  msy_stuff(3)  = Requil(phi) ;       // Eq Recruitment\n  msy_stuff(5) *= msy_stuff(3);       // BmsyTot\n  msy_stuff(2) *= msy_stuff(3);       // MSY\n  msy_stuff(1)  = phi*(msy_stuff(3)); // Bmsy\n  RETURN_ARRAYS_DECREMENT();\n  return msy_stuff;\n\nFUNCTION dvariable yield(const dvar_vector& Fratio, const dvariable& Ftmp,int iyr)\n  RETURN_ARRAYS_INCREMENT();\n  /*dvariable utmp=1.-mfexp(-(Ftmp)); dvariable Ntmp; dvariable Btmp; dvariable yield; dvariable survtmp=exp(-1.*natmort); dvar_vector seltmp=sel_fsh(endyr); Ntmp = 1.; Btmp = Ntmp*wt(1)*seltmp(1); Stmp = .5*Ntmp*wt(1)*maturity(1); yield= 0.; for ( j=1 ; j < nages ; j++ ) { Ntmp  *= (1.-utmp*seltmp(j))*survtmp; Btmp  += Ntmp*wt(j+1)*seltmp(j+1); Stmp  += .5 * Ntmp *wt(j+1)*maturity(j+1); } //Max Age - 1 yr yield   += utmp * Btmp; Ntmp    /= (1-survtmp*(1.-utmp*seltmp(nages))); Btmp    += Ntmp*wt(nages)*seltmp(nages); Stmp    += 0.5 *wt(nages)* Ntmp *maturity(nages); yield   += utmp * Btmp; //cout<<yield<<\" \"<<Stmp<<\" \"<<Btmp<<\" \";*/\n  dvariable phi;\n  dvariable Req;\n  dvar_vector Ntmp(1,nages);\n  dvar_vector Ctmp(1,nages);\n  dvariable   yield;\n  yield.initialize();\n\n  dvar_matrix seltmp(1,nfsh,1,nages);\n  for (k=1;k<=nfsh;k++)\n   seltmp(k) = sel_fsh(k,iyr); // NOTE uses last-year of fishery selectivity for projections.\n\n  dvar_matrix Fatmp(1,nfsh,1,nages);\n  dvar_vector Ztmp(1,nages);\n\n  Ztmp = M(iyr);\n  for (k=1;k<=nfsh;k++)\n  { \n    Fatmp(k) = Fratio(k) * Ftmp * seltmp(k);\n    Ztmp    += Fatmp(k);\n  } \n  dvar_vector survtmp = mfexp(-Ztmp);\n\n  Ntmp(1) = 1.;\n  for ( j=1 ; j < nages; j++ )\n    Ntmp(j+1)  =   Ntmp(j) * survtmp(j); // Begin numbers in the next year/age class\n  Ntmp(nages)  /= (1.- survtmp(nages)); \n\n  for (k=1;k<=nfsh;k++)\n  {\n    Ctmp.initialize();\n    for ( j=1 ; j <= nages; j++ )\n      Ctmp(j)      = Ntmp(j) * Fatmp(k,j) * (1. - survtmp(j)) / Ztmp(j);\n\n    yield  += wt_fsh(k,iyr) * Ctmp;\n  }\n  phi    = elem_prod( Ntmp , pow(survtmp,spmo_frac ) )* wt_mature;\n  // Req    = Requil(phi) * mfexp(sigmarsq/2);\n  Req    = Requil(phi) ;\n  yield *= Req;\n\n  RETURN_ARRAYS_DECREMENT();\n  return yield;\n\nFUNCTION dvariable yield(const dvar_vector& Fratio, const dvariable& Ftmp)\n  RETURN_ARRAYS_INCREMENT();\n  /*dvariable utmp=1.-mfexp(-(Ftmp)); dvariable Ntmp; dvariable Btmp; dvariable yield; dvariable survtmp=exp(-1.*natmort); dvar_vector seltmp=sel_fsh(endyr); Ntmp = 1.; Btmp = Ntmp*wt(1)*seltmp(1); Stmp = .5*Ntmp*wt(1)*maturity(1); yield= 0.; for ( j=1 ; j < nages ; j++ ) { Ntmp  *= (1.-utmp*seltmp(j))*survtmp; Btmp  += Ntmp*wt(j+1)*seltmp(j+1); Stmp  += .5 * Ntmp *wt(j+1)*maturity(j+1); } //Max Age - 1 yr yield   += utmp * Btmp; Ntmp    /= (1-survtmp*(1.-utmp*seltmp(nages))); Btmp    += Ntmp*wt(nages)*seltmp(nages); Stmp    += 0.5 *wt(nages)* Ntmp *maturity(nages); yield   += utmp * Btmp; //cout<<yield<<\" \"<<Stmp<<\" \"<<Btmp<<\" \";*/\n  dvariable phi;\n  dvariable Req;\n  dvar_vector Ntmp(1,nages);\n  dvar_vector Ctmp(1,nages);\n  dvariable   yield;\n  yield.initialize();\n\n  dvar_matrix seltmp(1,nfsh,1,nages);\n  for (k=1;k<=nfsh;k++)\n   seltmp(k) = sel_fsh(k,endyr); // NOTE uses last-year of fishery selectivity for projections.\n\n  dvar_matrix Fatmp(1,nfsh,1,nages);\n  dvar_vector Ztmp(1,nages);\n\n  Ztmp = M(styr);\n  for (k=1;k<=nfsh;k++)\n  { \n    Fatmp(k) = Fratio(k) * Ftmp * seltmp(k);\n    Ztmp    += Fatmp(k);\n  } \n  dvar_vector survtmp = mfexp(-Ztmp);\n\n  Ntmp(1) = 1.;\n  for ( j=1 ; j < nages; j++ )\n    Ntmp(j+1)  =   Ntmp(j) * survtmp(j); // Begin numbers in the next year/age class\n  Ntmp(nages)  /= (1.- survtmp(nages)); \n\n  for (k=1;k<=nfsh;k++)\n  {\n    Ctmp.initialize();\n    for ( j=1 ; j <= nages; j++ )\n      Ctmp(j)      = Ntmp(j) * Fatmp(k,j) * (1. - survtmp(j)) / Ztmp(j);\n\n    yield  += wt_fsh(k,endyr) * Ctmp;\n  }\n  phi    = elem_prod( Ntmp , pow(survtmp,spmo_frac ) )* wt_mature;\n  // Req    = Requil(phi) * mfexp(sigmarsq/2);\n  Req    = Requil(phi) ;\n  yield *= Req;\n\n  RETURN_ARRAYS_DECREMENT();\n  return yield;\n\nFUNCTION dvariable yield(const dvar_vector& Fratio, dvariable& Ftmp, dvariable& Stmp,dvariable& Req)\n  RETURN_ARRAYS_INCREMENT();\n  dvariable phi;\n  dvar_vector Ntmp(1,nages);\n  dvar_vector Ctmp(1,nages);\n  dvariable   yield   = 0.;\n\n  dvar_matrix seltmp(1,nfsh,1,nages);\n  for (k=1;k<=nfsh;k++)\n   seltmp(k) = sel_fsh(k,endyr); // NOTE uses last-year of fishery selectivity for projections.\n\n  dvar_matrix Fatmp(1,nfsh,1,nages);\n  dvar_vector Ztmp(1,nages);\n\n  Ztmp = M(styr);\n  for (k=1;k<=nfsh;k++)\n  { \n    Fatmp(k) = Fratio(k) * Ftmp * seltmp(k);\n    Ztmp    += Fatmp(k);\n  } \n  dvar_vector survtmp = mfexp(-Ztmp);\n\n  Ntmp(1) = 1.;\n  for ( j=1 ; j < nages; j++ )\n    Ntmp(j+1)  =   Ntmp(j) * survtmp(j); // Begin numbers in the next year/age class\n  Ntmp(nages)  /= (1.- survtmp(nages)); \n  for (k=1;k<=nfsh;k++)\n  {\n    Ctmp.initialize();\n    for ( j=1 ; j <= nages; j++ )\n      Ctmp(j)      = Ntmp(j) * Fatmp(k,j) * (1. - survtmp(j)) / Ztmp(j);\n    yield  += wt_fsh(k,endyr) * Ctmp;\n  }\n  phi    = elem_prod( Ntmp , pow(survtmp,spmo_frac ) )* wt_mature;\n  // Req    = Requil(phi) * exp(sigmarsq/2);\n  Req    = Requil(phi) ;\n  yield *= Req;\n  Stmp   = phi*Req;\n\n  RETURN_ARRAYS_DECREMENT();\n  return yield;\n\nFUNCTION Profile_F\n  /** NOTE THis will need to be conditional on SrType too Function calculates \n  used in calculating MSY and MSYL for a designated component of the\n  population, given values for stock recruitment and selectivity...  \n  Fmsy is the trial value of MSY example of the use of \"funnel\" to \n  reduce the amount of storage for derivative calculations \n  */\n  cout << \"Doing a profile over F....\"<<endl;\n  ofstream prof_F(\"Fprof.yld\");\n dvariable sumF=0.;\n  for (k=1;k<=nfsh;k++)\n    sumF += sum(F(k,endyr));\n  for (k=1;k<=nfsh;k++)\n    Fratio(k) = sum(F(k,endyr)) / sumF;\n  dvariable Stmp;\n  dvariable Rtmp;\n  double df=1.e-7;\n  dvariable F1=.05;\n  dvariable F2;\n  dvariable F3;\n  dvariable yld1;\n  dvariable yld2;\n  dvariable yld3;\n  dvariable dyld;\n  dvariable dyldp;\n  prof_F <<\"Profile of stock, yield, and recruitment over F\"<<endl;\n  prof_F << model_name<<\" \"<<datafile_name<<endl;\n  prof_F <<endl<<endl<<\"F  Stock  Yld  Recruit SPR\"<<endl;\n  prof_F <<0.0<<\" \"<< Bzero <<\" \"<<0.0<<\" \"<<Rzero<< \" 1.00\"<<endl; \n  dvar_vector ttt(1,5);\n  for (int ii=1;ii<=500;ii++)\n  {\n    F1    = double(ii)/500;\n    yld1  = yield(Fratio,F1,Stmp,Rtmp);\n    ttt   = yld(Fratio,F1);\n    prof_F <<F1<<\" \"<< ttt << endl; \n  } \n\nFUNCTION dvar_vector SRecruit(const dvar_vector& Stmp)\n  RETURN_ARRAYS_INCREMENT();\n  dvar_vector RecTmp(Stmp.indexmin(),Stmp.indexmax());\n  switch (SrType)\n  {\n    case 1:\n      RecTmp = elem_prod((Stmp / phizero) , mfexp( alpha * ( 1. - Stmp / Bzero ))) ; //Ricker form from Dorn\n      break;\n    case 2:\n      RecTmp = elem_prod(Stmp , 1. / ( alpha + beta * Stmp));        //Beverton-Holt form\n      break;\n    case 3:\n      RecTmp = mfexp(mean_log_rec);                    //Avg recruitment\n      break;\n    case 4:\n      RecTmp = elem_prod(Stmp , mfexp( alpha  - Stmp * beta)) ; //Old Ricker form\n      break;\n  }\n  RETURN_ARRAYS_DECREMENT();\n  return RecTmp;\n\nFUNCTION dvariable SRecruit(const double& Stmp)\n  RETURN_ARRAYS_INCREMENT();\n  dvariable RecTmp;\n  switch (SrType)\n  {\n    case 1:\n      RecTmp = (Stmp / phizero) * mfexp( alpha * ( 1. - Stmp / Bzero )) ; //Ricker form from Dorn\n      break;\n    case 2:\n      RecTmp = Stmp / ( alpha + beta * Stmp);        //Beverton-Holt form\n      break;\n    case 3:\n      RecTmp = mfexp(mean_log_rec);                    //Avg recruitment\n      break;\n    case 4:\n      RecTmp = Stmp * mfexp( alpha  - Stmp * beta) ; //old Ricker form\n      break;\n  }\n  RETURN_ARRAYS_DECREMENT();\n  return RecTmp;\n\nFUNCTION dvariable SRecruit(const dvariable& Stmp)\n  RETURN_ARRAYS_INCREMENT();\n  dvariable RecTmp;\n  switch (SrType)\n  {\n    case 1:\n      RecTmp = (Stmp / phizero) * mfexp( alpha * ( 1. - Stmp / Bzero )) ; //Ricker form from Dorn\n      break;\n    case 2:\n      RecTmp = Stmp / ( alpha + beta * Stmp);        //Beverton-Holt form\n      break;\n    case 3:\n      RecTmp = mfexp(mean_log_rec );                    //Avg recruitment\n      break;\n    case 4:\n      RecTmp = Stmp * mfexp( alpha  - Stmp * beta) ; //old Ricker form\n      break;\n  }\n  RETURN_ARRAYS_DECREMENT();\n  return RecTmp;\n\nFUNCTION Get_Bzero\n  /** Get the value of B zero */ \n  Bzero.initialize();\n  Rzero    =  mfexp(log_Rzero); \n\n  dvar_vector survtmp(1,nages);\n  survtmp = mfexp(-M(styr));\n\n  dvar_matrix natagetmp(styr_rec,styr,1,nages);\n  natagetmp.initialize();\n\n  natagetmp(styr_rec,1) = Rzero;\n  for (j=2; j<=nages; j++)\n    natagetmp(styr_rec,j) = natagetmp(styr_rec,j-1) * survtmp(j-1);\n  natagetmp(styr_rec,nages) /= (1.-survtmp(nages)); \n\n  Bzero = elem_prod(wt_mature , pow(survtmp,spmo_frac))*natagetmp(styr_rec) ;\n  phizero = Bzero/Rzero;\n\n  switch (SrType)\n  {\n    case 1:\n      alpha = log(-4.*steepness/(steepness-1.));\n      break;\n    case 2:\n    {\n      alpha  =  Bzero * (1. - (steepness - 0.2) / (0.8*steepness) ) / Rzero;\n      beta   = (5. * steepness - 1.) / (4. * steepness * Rzero);\n    }\n    break;\n    case 4:\n    {\n      beta  = log(5.*steepness)/(0.8*Bzero) ;\n      alpha = log(Rzero/Bzero)+beta*Bzero;\n    }\n      break;\n  }\n  Sp_Biom.initialize();\n  Sp_Biom(styr_sp,styr_rec-1) = Bzero;\n  for (i=styr_rec;i<styr;i++)\n  {\n    Sp_Biom(i) = elem_prod(natagetmp(i),pow(survtmp,spmo_frac)) * wt_mature; \n    // natagetmp(i,1)          = mfexp(rec_dev(i) + log_Rzero); // OjO numbers a function of mean not SR curve...\n\t\trecruits(i)             = mfexp(rec_dev(i) + mean_log_rec);\n    natagetmp(i,1)          = recruits(i);\n    natagetmp(i+1)(2,nages) = ++elem_prod(natagetmp(i)(1,nages-1),mfexp(-M(styr)(1,nages-1)) );\n    natagetmp(i+1,nages)   += natagetmp(i,nages)*mfexp(-M(styr,nages));\n  }\n  // This sets first year recruitment as deviation from mean recruitment (since SR curve can\n  // be defined for different periods and is treated semi-independently)\n  natagetmp(styr,1)   = mfexp(rec_dev(styr) + mean_log_rec);\n  mod_rec(styr_rec,styr) = column(natagetmp,1);\n  natage(styr)  = natagetmp(styr); // OjO\n  Sp_Biom(styr) = elem_prod(natagetmp(styr),pow(survtmp,spmo_frac)) * wt_mature; \n\nFUNCTION dvariable Requil(dvariable& phi)\n  RETURN_ARRAYS_INCREMENT();\n  dvariable RecTmp;\n  switch (SrType)\n  {\n    case 1:\n      RecTmp =  Bzero * (alpha + log(phi) - log(phizero) ) / (alpha*phi);\n      break;\n    case 2:\n      RecTmp =  (phi-alpha)/(beta*phi);\n      break;\n    case 3:\n      RecTmp =  mfexp(mean_log_rec);\n      break;\n    case 4:\n      RecTmp =  (log(phi)+alpha) / (beta*phi); //RecTmp =  (log(phi)/alpha + 1.)*beta/phi;\n      break;\n  }\n  // Req    = Requil(phi) * exp(sigmarsq/2);\n  // return RecTmp* exp(sigmarsq/2);\n  RETURN_ARRAYS_DECREMENT();\n  return RecTmp;\n\nFUNCTION write_mceval_hdr\n    for (k=1;k<=nind;k++)\n      mceval<< \" model Obj_Fun q_ind_\"<< k<< \" \";\n    mceval<<\"M steepness depletion MSY MSYL Fmsy Fcur_Fmsy Bcur_Bmsy Bmsy totbiom_\"<<endyr<<\" \"<< \n    \" F35          \"<< \n    \" F40          \"<< \n    \" F50          \"<< \n    \" fut_SPB_Fmsy_\"<< endyr_fut<<\" \"<< \n    \" fut_SPB_F50%_\"<< endyr_fut<<\" \"<< \n    \" fut_SPB_F40%_\"<< endyr_fut<<\" \"<< \n    \" fut_SPB_F35%_\"<< endyr_fut<<\" \"<< \n    \" fut_SPB_F0_\"  << endyr_fut<<\" \"<< \n    \" fut_catch_Fmsy_\"<<styr_fut<<\" \"<<  \n    \" fut_catch_F50%_\"<<styr_fut<<\" \"<<  \n    \" fut_catch_F40%_\"<<styr_fut<<\" \"<<  \n    \" fut_catch_F35%_\"<<styr_fut<<\" \"<<  endl;\n\n//+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+ \nREPORT_SECTION\n  if (last_phase())\n  {\n    save_gradients(gradients);\n    int nvar1=initial_params::nvarcalc(); // get the number of active parameters\n    int ndvar=stddev_params::num_stddev_calc();\n    int offset=1;\n    dvector param_values(1,nvar1+ndvar);\n    initial_params::copy_all_values(param_values,offset);\n    for (int i=0;i<initial_params::num_initial_params;i++)\n    {\n      // cout << \"# \" << initial_params::varsptr[i]->label() << \"\\n\" << endl; \n      if (withinbound(0,(initial_params::varsptr[i])->phase_start, initial_params::current_phase))\n      {\n        int sc = (initial_params::varsptr[i])->size_count();\n        if (sc>0)\n        {\n          // write_input_log << \"# \" << initial_params::varsptr[i]->label() << endl<<param_values(i)<<\"\\n\" << endl; \n        } \n      }\n    }\n  //--------------------------------------------------------\n  //  Write cumulative likelihoods for main data parts\n  // Count up number of columns\n\tint icum  = 0;\n\tint ncols = 0;\n  for (k=1;k<=nind;k++)\n\t{\n\t\tif (nyrs_ind(k)>0)\n\t\t  ncols++;\n    for (i=1;i<=nyrs_ind(k);i++)\n\t    icum++;\n\t}\n  for (k=1;k<=nfsh;k++)\n\t{\n\t\tif (nyrs_fsh_age(k)>0)\n\t\t  ncols++;\n    for (int i=1;i<=nyrs_fsh_age(k);i++)\n\t    icum++;\n\t}\n  for (k=1;k<=nind;k++)\n\t{\n\t\tif (nyrs_ind_length(k)>0)\n\t\t  ncols++;\n    for (int i=1;i<=nyrs_ind_length(k);i++)\n\t    icum++;\n\t\tif (nyrs_ind_age(k)>0)\n\t\t  ncols++;\n    for (int i=1;i<=nyrs_ind_age(k);i++)\n\t    icum++;\n\t}\n  //--------------------------------------------------------\n  dmatrix cum_NLL(styr,endyr,1,ncols);\n  cum_NLL.initialize();\n\n  // Fit to indices (log-Normal) -------------------------------------------\n\tfor (int iyr=styr+1; iyr<=endyr;iyr++)\n\t{\n\t\tint icol=0;\n    for (k=1;k<=nind;k++)\n\t\t{\n\t\t\ticol++;\n      for (i=1;i<=nyrs_ind(k);i++)\n      {\n        if( iyr == yrs_ind(k,i) )\n          cum_NLL(iyr,icol) += value(square(log(obs_ind(k,i)) - log(pred_ind(k,i)) ) / \n                                     (2.*obs_lse_ind(k,i)*obs_lse_ind(k,i)) );\n      }\n    }\n  \n    for (k=1;k<=nfsh;k++)\n\t\t{\n\t\t\tif(nyrs_fsh_age(k)>0)\n\t\t\t{\n\t\t\t\ticol++;\n        for (int i=1;i<=nyrs_fsh_age(k);i++)\n          if( iyr == yrs_fsh_age(k,i))\n\t\t\t\t\t{\n            cum_NLL(iyr,icol) -= value(n_sample_fsh_age(k,i)*(oac_fsh(k,i) + 0.001) * log(eac_fsh(k,i) + 0.001 )  );\n            cum_NLL(iyr,icol) +=      (n_sample_fsh_age(k,i)*(oac_fsh(k,i) + 0.001) * log(oac_fsh(k,i) + 0.001 )  );\n\t\t\t\t\t}\n      }\n    }\n  \n    for (k=1;k<=nfsh;k++)\n\t\t\tif(nyrs_fsh_length(k)>0)\n\t\t\t{\n\t\t\t  icol++;\n        for (int i=1;i<=nyrs_fsh_length(k);i++)\n          if( iyr == yrs_fsh_length(k,i))\n\t\t\t\t\t{\n            cum_NLL(iyr,icol) -= value(n_sample_fsh_length(k,i)*(olc_fsh(k,i) + 0.001) * log(elc_fsh(k,i) + 0.001 ) );\n            cum_NLL(iyr,icol) +=      (n_sample_fsh_length(k,i)*(olc_fsh(k,i) + 0.001) * log(olc_fsh(k,i) + 0.001 ) );\n\t\t\t    }\n\t\t\t}\n    //----------------------------------------------------------\n    for (k=1;k<=nind;k++)\n\t\t{\n\t\t\tif(nyrs_ind_length(k)>0)\n\t\t\t{\n\t\t\t  icol++;\n        for (int i=1;i<=nyrs_ind_length(k);i++)\n          if( iyr == yrs_ind_length(k,i))\n\t\t\t\t\t{\n            cum_NLL(iyr,icol) -= value(n_sample_ind_length(k,i)*(olc_ind(k,i) + 0.001) * log(elc_ind(k,i) + 0.001 ) );\n            cum_NLL(iyr,icol) +=      (n_sample_ind_length(k,i)*(olc_ind(k,i) + 0.001) * log(olc_ind(k,i) + 0.001 ) );\n\t\t\t    }\n\t\t\t}\n\t  }\n  \n    //----------------------------------------------------------\n    for (k=1;k<=nind;k++)\n\t  {\n\t\t\tif(nyrs_ind_age(k)>0)\n\t\t\t{\n\t\t\t  icol++;\n        for (int i=1;i<=nyrs_ind_age(k);i++)\n          if( iyr == yrs_ind_age(k,i))\n\t\t\t    {\n            cum_NLL(iyr,icol) -= value(n_sample_ind_age(k,i)*(oac_ind(k,i) + 0.001) * log(eac_ind(k,i) + 0.001 ) );\n            cum_NLL(iyr,icol) +=      (n_sample_ind_age(k,i)*(oac_ind(k,i) + 0.001) * log(oac_ind(k,i) + 0.001 ) );\n\t\t\t    }\n\t\t\t}\n\t\t}\n\t\tif(iyr<endyr)\n      cum_NLL(iyr+1) = cum_NLL(iyr) ; \n\t}\n  ofstream cum_like(\"cum_NLL.rep\");\n\treport<<\"Cumulative likelihoods\"<<endl;\n\tfor (int iyr=styr+1; iyr<=endyr;iyr++)\n\t{\n\t\tcum_like<< iyr<<\" \"<<cum_NLL(iyr)<<endl;\n\t\treport<< iyr<<\" \"<<cum_NLL(iyr)<<endl;\n\t}\n  //----------------------------------------------------------\n    if (!Popes)\n      for (k=1;k<=nfsh;k++)\n        Ftot += F(k);\n    log_param(Mest);\n    log_param(mean_log_rec);\n    log_param(steepness);\n    log_param(log_Rzero);\n    log_param(rec_dev);\n    log_param(log_sigmar);\n    log_param(fmort);\n    // log_param(log_selcoffs_fsh);\n    // log_param(log_sel_spl_fsh);\n    // log_param(logsel_slope_fsh);\n    // log_param(sel50_fsh);\n    // log_param(logsel_dslope_fsh);\n    // log_param(seld50_fsh);\n    log_param(rec_dev_future);\n    // log_param(log_q_ind);\n    // log_param(log_q_power_ind);\n    // log_param(log_selcoffs_ind);\n    // log_param(logsel_slope_ind);\n    // log_param(logsel_dslope_ind);\n    // log_param(sel50_ind);\n    // log_param(seld50_ind);\n  }\n    \n  if (oper_mod)\n    Oper_Model();\n\n  cout <<\"===============================================================\"<<endl;\n  if(last_phase())\n    cout<<\"||  ++++++ Completed phase \"<<current_phase()<<\" In last phase now +++++\"<< endl<<\"||\"<<endl<<\"||  \"<<cntrlfile_name <<endl;\n  else\n    cout<<\"||  ++++++ Completed phase \"<<current_phase()<<\" ++++++++++++++++\"<< endl<<\"||\"<<endl<<\"||  \"<<cntrlfile_name <<endl;\n  cout<<\"||\"<<endl<<\"||\"<<endl;\n  cout <<\"_______________________________________________________________\"<<endl;\n    adstring comma = adstring(\",\"); \n    report << model_name<<\" \"<< endl<< endl;\n    report << \"Estimated annual F's \" << endl;\n    Fmort.initialize();\n    for (k=1;k<=nfsh;k++)\n      for (i=styr;i<=endyr;i++) \n        Fmort(i) += mean(F(k,i));\n    report << Fmort<<endl;\n    report << \"Total mortality (Z)\"<<endl;\n    report << Z<<endl;\n    report << \"Estimated numbers of fish \" << endl;\n    for (i=styr;i<=endyr;i++) \n      report <<\"       Year: \"<< i << \" \"<< natage(i) << endl;\n    report << endl<< \"Estimated F mortality \" << endl;\n    for (k=1;k<=nfsh;k++)\n    {\n      report << \"Fishery \"<< k <<\" : \"<< endl ;\n      for (i=styr;i<=endyr;i++) \n        report << \"        Year: \"<<i<<\" \"<<F(k,i)<<  \" \"<< endl;\n    }\n\n    report << endl<< \"survey q \" << endl;\n    report <<q_ind<<endl;\n    report << endl<< \"Observed survey values \" << endl;\n    for (k=1;k<=nind;k++)\n    {\n      int ii=1;\n      report <<endl<< \"Yr_Obs_Pred_Survey \"<< k <<\" : \"<< endl ;\n      for (int iyr=styr;iyr<=endyr;iyr++)\n      {\n        dvariable pred_tmp ;\n        if (ii<=nyrs_ind(k))\n        {\n          pred_tmp = q_ind(k,ii) * pow(elem_prod(natage(iyr),pow(S(iyr),ind_month_frac(k))) * \n                        elem_prod(sel_ind(k,iyr) , wt_ind(k,iyr)),q_power_ind(k));\n          if (yrs_ind(k,ii)==iyr)\n          {\n            report << iyr<< \" \"<< \n                     obs_ind(k,ii) << \" \"<< pred_tmp <<endl;\n            ii++;\n          }\n          else\n            report << iyr<< \" -1 \"<< \" \"<< pred_tmp   <<endl;\n        }\n      }\n    }\n\n    report << endl<< \"Survey_Q:  \"<<q_ind << endl;\n\n    report << endl<< \"Observed Prop \" << endl;\n    for (k=1;k<=nfsh;k++)\n    {\n      report << \"ObsFishery \"<< k <<\" : \"<< endl ;\n      for (i=1;i<=nyrs_fsh_age(k);i++) \n        report << yrs_fsh_age(k,i)<< \" \"<< oac_fsh(k,i) << endl;\n    }\n    report << endl<< \"Predicted prop  \" << endl;\n    for (k=1;k<=nfsh;k++)\n    {\n      report << \"PredFishery \"<< k <<\" : \"<< endl;\n      for (i=1;i<=nyrs_fsh_age(k);i++) \n        report << yrs_fsh_age(k,i)<< \" \"<< eac_fsh(k,i) << endl;\n    }\n    for (k=1;k<=nfsh;k++)\n    {\n      report << \"Pobs_length_fishery_\"<< (k) <<\"\"<< endl;\n      for (i=1;i<=nyrs_fsh_length(k);i++) \n        report << yrs_fsh_length(k,i)<< \" \"<< olc_fsh(k,i) << endl;\n      report   << endl;\n    }\n    for (k=1;k<=nfsh;k++)\n    {\n      report << \"Pred_length_fishery_\"<< (k) <<\"\"<< endl;\n      for (i=1;i<=nyrs_fsh_length(k);i++) \n        report << yrs_fsh_length(k,i)<< \" \"<< elc_fsh(k,i) << endl;\n      report   << endl;\n    }\n    report << endl<< \"Observed prop Survey\" << endl;\n    for (k=1;k<=nind;k++)\n    {\n      report << \"ObsSurvey \"<<k<<\" : \"<<  endl;\n      for (i=1;i<=nyrs_ind_age(k);i++) \n        report << yrs_ind_age(k,i)<< \" \"<< oac_ind(k,i) << endl;\n    }\n    report << endl<< \"Predicted prop Survey\" << endl;\n    for (k=1;k<=nind;k++)\n    {\n      report << \"PredSurvey \"<<k<<\" : \"<<  endl;\n      for (i=1;i<=nyrs_ind_age(k);i++) \n        report << yrs_ind_age(k,i)<< \" \"<< eac_ind(k,i) << endl;\n    }\n    report << endl<< \"Observed catch biomass \" << endl;\n    report << catch_bio << endl;\n    report << \"predicted catch biomass \" << endl;\n    report << pred_catch << endl;\n\n    report << endl<< \"Estimated annual fishing mortality \" << endl;\n    for (k=1;k<=nfsh;k++)\n      report << \" Average_F_Fshry_\"<<k<< \" Full_selection_F_Fshry_\"<<k;\n\n    report << endl;\n    for (i=styr;i<=endyr;i++)\n    {\n      report<< i<< \" \";\n      for (k=1;k<=nfsh;k++)\n        report<< mean(F(k,i)) <<\" \"<< mean(F(k,i))*max(sel_fsh(k,i)) << \" \";\n\n      report<< endl;\n    }\n    report << endl<< \"Selectivity\" << endl;\n    for (k=1;k<=nfsh;k++)\n      for (i=styr;i<=endyr;i++)\n        report << \"Fishery \"<< k <<\"  \"<< i<<\" \"<<sel_fsh(k,i) << endl;\n    for (k=1;k<=nind;k++)\n      for (i=styr;i<=endyr;i++)\n        report << \"Survey  \"<< k <<\"  \"<< i<<\" \"<<sel_ind(k,i) << endl;\n\n    report << endl<< \"Stock Recruitment stuff \"<< endl;\n    for (i=styr_rec;i<=endyr;i++)\n      if (active(log_Rzero))\n        report << i<< \" \"<<Sp_Biom(i-rec_age)<< \" \"<< SRecruit(Sp_Biom(i-rec_age))<< \" \"<< mod_rec(i)<<endl;\n      else \n        report << i<< \" \"<<Sp_Biom(i-rec_age)<< \" \"<< \" 999\" << \" \"<< mod_rec(i)<<endl;\n\n    report << endl<< \"Curve to plot \"<< endl;\n    report <<\"stock Recruitment\"<<endl;\n    report <<\"0 0 \"<<endl;\n    dvariable stock;\n    for (i=1;i<=30;i++)\n    {\n      stock = double (i) * Bzero /25.;\n      if (active(log_Rzero))\n        report << stock <<\" \"<< SRecruit(stock)<<endl;\n      else\n        report << stock <<\" 99 \"<<endl;\n    }\n\n    report   << endl<<\"Likelihood Components\" <<endl;\n    report   << \"----------------------------------------- \" <<endl;\n    report   << \"  catch_like  age_like_fsh sel_like_fsh ind_like age_like_ind sel_like_ind rec_like fpen post_priors_indq post_priors residual total\"<<endl;\n    report   << \" \"<<obj_comps<<endl;\n\n    obj_comps(13)= obj_fun - sum(obj_comps) ; // Residual \n    obj_comps(14)= obj_fun ;                  // Total\n    report   <<\"  catch_like       \"<<setw(10)<<obj_comps(1) <<endl\n             <<\"  age_like_fsh     \"<<setw(10)<<obj_comps(2) <<endl\n             <<\"  length_like_fsh  \"<<setw(10)<<obj_comps(3) <<endl\n             <<\"  sel_like_fsh     \"<<setw(10)<<obj_comps(4) <<endl\n             <<\"  ind_like        \"<<setw(10)<<obj_comps(5) <<endl\n             <<\"  length_like_ind  \"<<setw(10)<<obj_comps(6) <<endl\n             <<\"  age_like_ind     \"<<setw(10)<<obj_comps(6) <<endl\n             <<\"  sel_like_ind     \"<<setw(10)<<obj_comps(7) <<endl\n             <<\"  rec_like         \"<<setw(10)<<obj_comps(8) <<endl\n             <<\"  fpen             \"<<setw(10)<<obj_comps(9) <<endl\n             <<\"  post_priors_indq \"<<setw(10)<<obj_comps(10) <<endl\n             <<\"  post_priors      \"<<setw(10)<<obj_comps(11)<<endl\n             <<\"  residual         \"<<setw(10)<<obj_comps(12)<<endl\n             <<\"  total            \"<<setw(10)<<obj_comps(13)<<endl;\n\n    report   << endl;\n    report   << \"Fit to Catch Biomass \"<<endl;\n    report   << \"-------------------------\" <<endl;\n    for (k=1;k<=nfsh;k++)\n      report << \"  Catch_like_Fshry_#\"<< k <<\"  \"<< catch_like(k) <<endl;\n    report   << endl;\n\n    report << \"Age likelihoods for fisheries :\"<<endl;\n    report   << \"-------------------------\" <<endl;\n    for (k=1;k<=nfsh;k++)\n      report << \"  Age_like_Fshry_#\"<< k <<\"  \"<< age_like_fsh(k) <<endl;\n    report   << endl;\n\n    report   << \"Selectivity penalties for fisheries :\"<<endl;\n    report   << \"-------------------------\" <<endl;\n    report   << \"  Fishery Curvature_Age Change_Time Dome_Shaped\"<<endl;\n    for (k=1;k<=nfsh;k++)\n      report << \"  Sel_Fshry_#\"<< k <<\"  \"<< sel_like_fsh(k,1) <<\" \"<<sel_like_fsh(k,2)<<\" \"<<sel_like_fsh(k,3)<< endl;\n    report   << endl;\n  \n    report   << \"survey Likelihood(s) \" <<endl;\n    report   << \"-------------------------\" <<endl;\n    for (k=1;k<=nind;k++)\n      report << \"  Survey_Index_#\"<< k <<\"  \" << ind_like(k)<<endl;\n    report   << endl;\n\n    report << setw(10)<< setfixed() << setprecision(5) <<endl;\n    report   << \"Age likelihoods for surveys :\"<<endl;\n    report   << \"-------------------------\" <<endl;\n    for (k=1;k<=nind;k++)\n      report << \"  Age_Survey_#\"<< k <<\"  \" << age_like_ind(k)<<endl;\n    report   << endl;\n\n    report   << \"Selectivity penalties for surveys :\"<<endl;\n    report   << \"-------------------------\" <<endl;\n    report   << \"  Survey Curvature_Age Change_Time Dome_Shaped\"<<endl;\n    for (k=1;k<=nind;k++)\n      report << \"  Sel_Survey_#\"<< k <<\"  \"<< sel_like_ind(k,1) <<\" \"<<sel_like_ind(k,2)<<\" \"<<sel_like_ind(k,3)<< endl;\n    report   << endl;\n\n    report << setw(10)<< setfixed() << setprecision(5) <<endl;\n    report   << \"Recruitment penalties: \" <<rec_like<<endl;\n    report   << \"-------------------------\" <<endl;\n    report   << \"  (sigmar)            \" <<sigmar<<endl;\n    report   << \"  S-R_Curve           \" <<rec_like(1)<< endl;\n    report   << \"  Regularity          \" <<rec_like(2)<< endl;\n    report   << \"  Future_Recruits     \" <<rec_like(3)<< endl;\n    report   << endl;\n\n    report   << \"F penalties:          \" <<endl;\n    report   << \"-------------------------\" <<endl;\n    report   << \"  Avg_F               \" <<fpen(1) <<endl;\n    report   << \"  Effort_Variability  \" <<fpen(2) <<endl;\n    report   << endl;\n\n    report   << \"Contribution of Priors:\"<<endl;\n    report   << \"-------------------------\" <<endl;\n    report   << \"Source                \";\n    report   <<           \" Posterior\";\n    report   <<           \" Param_Val\";\n    report   <<           \" Prior_Val\";\n    report   <<           \"  CV_Prior\"<<endl;\n  // (*ad_printf)(\"f = %lf\\n\",value(f));\n    for (k=1;k<=nind;k++)\n    {\n      report << \"Q_Survey_#\"<< k <<\"           \"\n             << setw(10)<<post_priors_indq(k) \n             << setw(10)<< q_ind(k)\n             << setw(10)<< qprior(k)\n             << setw(10)<< cvqprior(k)<<endl;\n\n      report << \"Q_power_Survey_#\"<< k <<\"           \"\n             << setw(10)<<post_priors_indq(k) \n             << setw(10)<< q_power_ind(k)\n             << setw(10)<< q_power_prior(k)\n             << setw(10)<< cvq_power_prior(k)<<endl;\n    }\n\n    // writerep(post_priors(1),repstring);\n    // cout <<repstring<<endl;\n    report   << \"Natural_Mortality     \"\n             << setw(10)<< post_priors(1)\n             << setw(10)<< M\n             << setw(10)<< natmortprior\n             << setw(10)<< cvnatmortprior <<endl;\n    report   << \"Steepness             \"\n             << setw(10)<< post_priors(2)\n             << setw(10)<< steepness\n             << setw(10)<< steepnessprior\n             << setw(10)<< cvsteepnessprior <<endl;\n    report   << \"SigmaR                \"\n             << setw(10)<< post_priors(3)\n             << setw(10)<< sigmar\n             << setw(10)<< sigmarprior\n             << setw(10)<< cvsigmarprior <<endl;\n    report   << endl;\n    report<<\"Num_parameters_Estimated \"<<initial_params::nvarcalc()<<endl;\n    \n  report <<cntrlfile_name<<endl;\n  report <<datafile_name<<endl;\n  report <<model_name<<endl;\n  if (SrType==2) \n    report<< \"Beverton-Holt\" <<endl;\n  else\n    report<< \"Ricker\" <<endl;\n  report<<\"Steepnessprior,_CV,_phase: \" <<steepnessprior<<\" \"<<\n    cvsteepnessprior<<\" \"<<\n    phase_srec<<\" \"<< endl;\n\n  report<<\"sigmarprior,_CV,_phase: \" <<sigmarprior<<\" \"<<  cvsigmarprior <<\" \"<<phase_sigmar<<endl;\n\n  report<<\"Rec_estimated_in_styr_endyr: \" <<styr_rec    <<\" \"<<endyr        <<\" \"<<endl;\n  report<<\"SR_Curve_fit__in_styr_endyr: \" <<styr_rec_est<<\" \"<<endyr_rec_est<<\" \"<<endl;\n  report<<\"Model_styr_endyr:            \" <<styr        <<\" \"<<endyr        <<\" \"<<endl;\n\n  report<<\"M_prior,_CV,_phase \"<< natmortprior<< \" \"<< cvnatmortprior<<\" \"<<phase_M<<endl;\n  report<<\"qprior,_CV,_phase \" <<qprior<<\" \"<<cvqprior<<\" \"<< phase_q<<endl;\n  report<<\"q_power_prior,_CV,_phase \" <<q_power_prior<<\" \"<<cvq_power_prior<<\" \"<< phase_q_power<<endl;\n\n  report<<\"cv_catchbiomass: \" <<cv_catchbiomass<<\" \"<<endl;\n  report<<\"Projection_years \"<< nproj_yrs<<endl;\n  for (k=1;k<=nfsh;k++)\n    report << \"Fsh_sel_opt_fish: \"<<k<<\" \"<<fsh_sel_opt(k)<<\" \"<<sel_change_in_fsh(k)<<endl;\n  for (k=1;k<=nind;k++)\n    report<<\"Survey_Sel_Opt_Survey: \" <<k<<\" \"<<(ind_sel_opt(k))<<endl;\n    \n  report <<\"Phase_survey_Sel_Coffs: \"<<phase_selcoff_ind<<endl; \n  report <<\"Fshry_Selages: \" << nselages_in_fsh  <<endl;\n  report <<\"Survy_Selages: \" << nselages_in_ind <<endl;\n  report << \"Phase_for_age-spec_fishery \"<<phase_selcoff_fsh<<endl;\n  report << \"Phase_for_logistic_fishery \"<<phase_logist_fsh<<endl;\n  report << \"Phase_for_dble_logistic_fishery \"<<phase_dlogist_fsh<<endl;\n  report << \"Phase_for_age-spec_survey  \"<<phase_selcoff_ind<<endl;\n  report << \"Phase_for_logistic_survey  \"<<phase_logist_ind<<endl;\n  report << \"Phase_for_dble_logistic_indy \"<<phase_dlogist_ind<<endl;\n\n  for (k=1; k<=nfsh;k++)\n  {\n    report <<\"Number_of_select_changes_fishery: \"<<k<<\" \"<<n_sel_ch_fsh(k)<<endl;\n    report<<\"Yrs_fsh_sel_change: \"<<yrs_sel_ch_fsh(k)<<endl;\n    report << \"sel_change_in: \"<<sel_change_in_fsh(k) << endl;\n  }\n  for (k=1; k<=nind;k++)\n  {\n    report <<\"Number_of_select_changes_survey: \"<<k<<\" \"<<n_sel_ch_ind(k)<<endl;\n    report<<\"Yrs_ind_sel_change: \"<<yrs_sel_ch_ind(k)<<endl;\n    report << \"sel_change_in: \"<<sel_change_in_ind(k) << endl;\n  }\n\nFUNCTION write_msy_out\n  ofstream msyout(\"msyout.dat\");\n  msyout << \" # Natural Mortality       \" <<endl;\n  for (j=1;j<=nages;j++) \n    msyout <<M <<\" \";\n  msyout <<endl;\n  msyout << spawnmo<< \"  # Spawnmo                   \" <<endl;\n  msyout <<\"# Wt spawn\"<<endl<< wt_pop<< endl;\n  msyout <<\"# Wt fish\"<<endl;\n  for (k=1;k<=nfsh;k++) \n    msyout <<wt_fsh(k,endyr)<< \" \";\n  msyout <<endl;\n  msyout <<\"# Maturity\"<<endl<< maturity<< endl;\n  msyout <<\"# selectivity\"<<endl;\n  for (k=1;k<=nfsh;k++) \n    msyout<< sel_fsh(k,endyr) <<\" \";\n  msyout<< endl;\n  msyout<<\"Srec_Option \"<<SrType<< endl;\n  msyout<<\"Alpha \"<<alpha<< endl;\n  msyout<<\"beta \"<<beta<< endl;\n  msyout<<\"steepness \"<<steepness<< endl;\n  msyout<<\"Bzero \"<<Bzero<< endl;\n  msyout<<\"Rzero \"<<Rzero<< endl;\n\n\n// Function to write out data file for projection model....just an output for alternative projections\nFUNCTION write_proj\n  ofstream projout( projfile_name );\n// Function to write out data file for projection model....\n projout << \"#model_name\"<<endl;\n projout << model_name<<endl;\n projout <<\"1    # SSLn species...\"<<endl;\n projout <<\"0    # Buffer of Dorn\"<<endl;\n projout <<nfsh<< \"    # Number of fsheries\"<<endl;\n projout <<\"1    # Number of sexes\"<<endl;\n dvariable sumF=0.;\n dmatrix seltmp(1,nfsh,1,nages) ;\n seltmp.initialize();\n Fratio.initialize();\n for (i = endyr-4;i<=endyr;i++) \n   for (k=1;k<=nfsh;k++)\n   {\n     Fratio(k) += (mean(F(k,i))) ;\n     sumF      += Fratio(k) ;\n     seltmp(k) += value(sel_fsh(k,i));\n   }\n sumF /= 5.;\n seltmp /= 5.;\n for (k=1;k<=nfsh;k++) seltmp(k) /= max(seltmp(k));\n projout << sumF << \"  # averagei 5yr f                  \" <<endl;\n // projout << mean(Fmort(endyr_r-4,endyr_r))<<\"  # averagei 5yr f                  \" <<endl;\n projout << \" 1  # author f                  \" <<endl;\n projout <<\" 0.4  # ABC SPR        \"<<endl;\n projout <<\" 0.35 # MSY/OFL SPR    \"<<endl;\n projout << \"# Spawnmo  \"<<endl<<spawnmo <<endl;\n projout <<nages<< \" # Number of ages\" <<endl;\n projout << \"# Fratio\"<<endl<<Fratio/sum(Fratio) <<endl;\n projout <<M(endyr) << \" # Natural Mortality       \" <<endl;\n projout <<\"# Maturity\"<<endl<< maturity/max(maturity)<< endl;\n projout <<\"# Wt spawn\"<<endl<< wt_pop     << endl;\n projout <<\"# Wt fsh\"<<endl; for (k=1;k<=nfsh;k++) projout << wt_fsh(k,endyr)<<endl;\n projout <<\"# selectivity\"<<endl; for (k=1;k<=nfsh;k++) projout << seltmp(k)<<endl;\n projout <<\"# natage\"<<endl<< natage(endyr) << endl;\n projout <<\"#_N_recruitment_years (not including last 1 estimates)\"<<endl<<endyr-(1977+rec_age+1) << endl;\n projout <<\"#_Recruitment_start_at_1977_yearclass=1978_for_age_1_recruits\"<<yy(1977+rec_age,endyr-1-rec_age)<<endl;\n projout <<mod_rec(1977+rec_age,endyr-1-rec_age)<< endl;\n // projout <<\"# Nrec\"<<endl<< endyr-1978<< endl;\n // projout <<\"# rec\"<<endl<< pred_rec(1978,endyr) << endl;\n projout <<\"# SpawningBiomass\"<<endl; // << Sp_Biom(1978-1,endyr-1) << endl;\n projout <<Sp_Biom(1977+rec_age,endyr-1-rec_age)<< endl;\n projout.close();\n\t\n\nFUNCTION write_projout\n// Function to write out data file for projection model....\n  ofstream projout( projfile_name );\n  \n  projout <<\"# \"<<model_name <<\" \"<< projfile_name<<endl;\n  projout <<\"123  # seed\"<<endl;\n  // Flag to tell if this is a SSL species                 \n  projout << \"1 # Flag to tell if this is a SSL forage species                 \"<<endl;\n  projout << \"0 # Flag to Dorn's version of a constant buffer                  \"<<endl;\n  // Flag to solve for F in first year or not 0==don't solve\n  projout<< \" 1 # Flag to solve for F in first year or not 0==don't solve\"<<endl;\n  // Flag to use 2nd-year catch/TAC\n  projout<< \"0 # Flag to use 2nd-year catch/TAC\"<<endl;\n  projout << nfsh<<\"   # Number of fisheries\"<<endl;\n  projout <<\"14   # Number of projection years\"<<endl;\n  projout <<\"1000 # Number of simulations\"<<endl;\n  projout <<endyr<< \" # Begin year of projection\" <<endl;\n  projout <<nages<< \" # Number of ages\" <<endl;\n  for (j=1;j<=nages;j++) \n    projout <<M(endyr,j) <<\" \";\n  projout << \" # Natural Mortality       \" <<endl;\n  double sumtmp;\n  sumtmp = 0.;\n  for (k=1;k<=nfsh;k++) \n    sumtmp += catch_bio(k,endyr);\n  projout << sumtmp<< \" # TAC in current year (assumed catch) \" <<endl;\n  projout << sumtmp<< \" # TAC in current year+1 (assumed catch) \" <<endl;\n  for (k=1;k<=nfsh;k++) \n    projout <<  F(k,endyr)/mean((F(k,endyr)))<<\" \"<<endl;\n   //  + fmort_dev(k,endyr)) /Fmort(endyr)<<\" \";\n\n  projout << \"   # Fratio                  \" <<endl;\n  dvariable sumF=0.;\n  for (k=1;k<=nfsh;k++)\n  {\n    Fratio(k) = sum(F(k,endyr)) ;\n    sumF += Fratio(k) ;\n  }\n  Fratio /= sumF;\n  projout << Fratio         <<endl;\n  projout <<\"  # average f\" <<endl;\n  projout << \" 1  # author f                  \" <<endl;\n  projout << spawnmo<< \"  # Spawnmo                   \" <<endl;\n  projout <<\"# Wt spawn\"<<endl<< wt_pop<< endl;\n  projout <<\"# Wt fish\"<<endl;\n  for (k=1;k<=nfsh;k++) \n    projout <<wt_fsh(k,endyr)<< \" \";\n  projout <<endl;\n  projout <<\"# Maturity\"<<endl<< maturity<< endl;\n  projout <<\"# selectivity\"<<endl;\n  for (k=1;k<=nfsh;k++) \n    projout<< sel_fsh(k,endyr) <<\" \"<<endl;\n  projout<< endl;\n  projout <<\"# natage\"<<endl<< natage(endyr) << endl;\n  if (styr<(1977-rec_age-1))\n  {\n    projout <<\"#_N_recruitment_years (not including last 1 estimates)\"<<endl<<endyr-(1977+rec_age+1) << endl;\n    projout <<\"#_Recruitment_start_at_1977_yearclass=1978_for_age_1_recruits\"<<yy(1977+rec_age,endyr-1)<<endl<<mod_rec(1977+rec_age,endyr-1)<< endl;\n  }\n\nFINAL_SECTION\n  /** Final section to compute projection input and profiles (over F) */\n  // Calc_Dependent_Vars();\n  // write_proj();\n  // write_projout();\n  // write_msy_out();\n  Profile_F();\n  Write_R();\nFUNCTION dvariable get_spr_rates(double spr_percent)\n  /**  Get the SPR rates given spr_percent */\n  RETURN_ARRAYS_INCREMENT();\n  dvar_matrix sel_tmp(1,nages,1,nfsh);\n  sel_tmp.initialize();\n  for (k=1;k<=nfsh;k++)\n    for (j=1;j<=nages;j++)\n      sel_tmp(j,k) = sel_fsh(k,endyr,j); // NOTE uses last-year of fishery selectivity for projections.\n  dvariable sumF=0.;\n  for (k=1;k<=nfsh;k++)\n  {\n    Fratio(k) = sum(F(k,endyr)) ;\n    sumF += Fratio(k) ;\n  }\n  Fratio /= sumF;\n  double df=1.e-3;\n  dvariable F1 ;\n  F1.initialize();\n  F1 = .8*natmortprior;\n  dvariable F2;\n  dvariable F3;\n  dvariable yld1;\n  dvariable yld2;\n  dvariable yld3;\n  dvariable dyld;\n  dvariable dyldp;\n  // Newton Raphson stuff to go here\n  for (int ii=1;ii<=6;ii++)\n  {\n    F2     = F1 + df;\n    F3     = F1 - df;\n    yld1   = -1000*square(log(spr_percent/spr_ratio(F1, sel_tmp,styr)));\n    yld2   = -1000*square(log(spr_percent/spr_ratio(F2, sel_tmp,styr)));\n    yld3   = -1000*square(log(spr_percent/spr_ratio(F3, sel_tmp,styr)));\n    dyld   = (yld2 - yld3)/(2*df);                          // First derivative (to find the root of this)\n    dyldp  = (yld3-(2*yld1)+yld2)/(df*df);  // Newton-Raphson approximation for second derivitive\n    F1    -= dyld/dyldp;\n  }\n  RETURN_ARRAYS_DECREMENT();\n  return(F1);\n\nFUNCTION dvariable spr_ratio(dvariable trial_F,dvar_matrix sel_tmp,int iyr)\n  /**  Get the SPR ratio given F, Selectivity and year */\n  dvariable SBtmp;\n  dvar_vector Ntmp(1,nages);\n  dvar_vector srvtmp(1,nages);\n  SBtmp.initialize();\n  Ntmp.initialize();\n  srvtmp.initialize();\n  dvar_matrix Ftmp(1,nages,1,nfsh); // note that this is in reverse order of usual indexing (age, fshery)\n  Ftmp = sel_tmp;\n  for (j=1;j<=nages;j++) \n  {\n    Ftmp(j) = elem_prod(Ftmp(j), trial_F * Fratio);\n    srvtmp(j)  = mfexp(-sum(Ftmp(j)) - M(iyr,j));\n  }\n  Ntmp(1)=1.;\n  j=1;\n  SBtmp  += Ntmp(j)*wt_mature(j)*pow(srvtmp(j),spmo_frac);\n  for (j=2;j<nages;j++)\n  {\n    Ntmp(j) = Ntmp(j-1)*srvtmp(j-1);\n    SBtmp  += Ntmp(j)*wt_mature(j)*pow(srvtmp(j),spmo_frac);\n  }\n  Ntmp(nages)=Ntmp(nages-1)*srvtmp(nages-1)/(1.-srvtmp(nages));\n  SBtmp  += Ntmp(nages)*wt_mature(nages)*pow(srvtmp(nages),spmo_frac);\n  return(SBtmp/phizero);\n\nFUNCTION dvariable spr_unfished(int i)\n  /**  Get the SPR ratio given no fishing */\n  dvariable Ntmp;\n  dvariable SBtmp;\n  SBtmp.initialize();\n  Ntmp = 1.;\n  for (j=1;j<nages;j++)\n  {\n    SBtmp += Ntmp*wt_mature(j)*exp(-spmo_frac * M(i,j));\n    Ntmp  *= mfexp( -M(i,j));\n  }\n  Ntmp    /= (1.-exp(-M(i,nages)));\n  SBtmp += Ntmp*wt_mature(nages)*exp(-spmo_frac * M(i,nages));\n  return(SBtmp);\n\nFUNCTION compute_spr_rates\n  /**  Get the SPR rate no fishing */\n  //Compute SPR Rates and add them to the likelihood for Females \n  dvariable sumF=0.;\n  for (k=1;k<=nfsh;k++)\n  {\n    Fratio(k) = sum(F(k,endyr)) ;\n    sumF += Fratio(k) ;\n  }\n  Fratio /= sumF;\n\n  F35_est = get_spr_rates(.35);\n  F50_est = get_spr_rates(.50);\n  F40_est = get_spr_rates(.40);\n\n  for (k=1;k<=nfsh;k++)\n  {\n    F50(k) = F50_est * (Fratio(k));\n    F40(k) = F40_est * (Fratio(k));\n    F35(k) = F35_est * (Fratio(k));\n  }\n  // cout << F50<<endl<<F40<<endl<<F35<<endl;\n\nFUNCTION void writerep(dvariable& tmp,adstring& tmpstring)\n  // cout <<tmpstring<<endl<<endl;\n  tmpstring = printf(\"3.5%f\",value(tmp));\n\nFUNCTION dvariable SolveF2(const int& iyr, const dvar_vector& N_tmp, const double&  TACin)\n  RETURN_ARRAYS_INCREMENT();\n  dvariable dd = 10.;\n  dvariable cc; \n  dvar_matrix Fratsel(1,nfsh,1,nages);\n  dvar_vector M_tmp(1,nages) ;\n  dvar_vector Z_tmp(1,nages) ;\n  dvar_vector S_tmp(1,nages) ;\n  dvar_vector Ftottmp(1,nages);\n  dvariable btmp =  N_tmp * elem_prod(sel_fsh(1,iyr),wt_pop);\n  dvariable ftmp;\n  M_tmp = M(iyr);\n  ftmp = TACin/btmp;\n    for (k=1;k<=nfsh;k++)\n      Fratsel(k) = Fratio(k)*sel_fsh(k,iyr);\n    for (int ii=1;ii<=5;ii++)\n    {\n      Ftottmp.initialize();\n      for (k=1;k<=nfsh;k++)\n        Ftottmp += ftmp*Fratsel(k);\n  \n      Z_tmp = Ftottmp  + M_tmp; \n      S_tmp = mfexp( -Z_tmp );\n      cc = 0.0;\n      for (k=1;k<=nfsh;k++)\n        cc += wt_fsh(k,endyr) * elem_prod(elem_div(ftmp*Fratsel(k),  Z_tmp),elem_prod(1.-S_tmp,N_tmp)); // Catch equation (vectors)\n  \n      dd = cc / TACin - 1.;\n      if (dd<0.) dd *= -1.;\n      ftmp += (TACin-cc) / btmp;\n    }\n  RETURN_ARRAYS_DECREMENT();\n  return(ftmp);\n\nFUNCTION dvar_vector SolveF2(const int& iyr, const dvector&  Catch)\n  // Returns vector of F's (given year) by fleet\n  // Requires: N and fleet specific wts & selectivities at age, catch \n  // iterate to get Z's right\n  RETURN_ARRAYS_INCREMENT();\n  dvariable dd = 10.;\n  dvariable cc; \n  dvar_matrix  seltmp(1,nfsh,1,nages);\n  dvar_matrix  wt_tmp(1,nfsh,1,nages);\n  dvar_matrix Fratsel(1,nfsh,1,nages);\n  dvar_vector N_tmp = natage(iyr);\n  dvar_vector M_tmp(1,nages) ;\n  dvar_vector Z_tmp(1,nages) ;\n  dvar_vector S_tmp(1,nages) ;\n  dvar_vector Ftottmp(1,nages);\n  dvar_vector Frat(1,nfsh);\n  dvar_vector btmp(1,nfsh);\n  dvar_vector ftmp(1,nfsh);\n  dvar_vector hrate(1,nfsh);\n  btmp.initialize(); \n  M_tmp = M(iyr);\n  // Initial guess for Fratio\n  for (k=1;k<=nfsh;k++)\n  {\n    seltmp(k)= sel_fsh(k,iyr); // Selectivity\n    wt_tmp(k)= wt_fsh(k,iyr); // \n    btmp(k)  =  N_tmp * elem_prod(seltmp(k),wt_tmp(k));\n    hrate(k) = Catch(k)/btmp(k);\n    Frat(k)  = Catch(k)/sum(Catch);\n    Fratsel(k) = Frat(k)*seltmp(k);\n    ftmp(k) = 1.1*(1.- posfun(1.-hrate(k),.10,fpen(4)));\n  }\n  // Initial fleet-specific F\n  // iterate to balance effect of multiple fisheries...........\n  for (int kk=1;kk<=nfsh;kk++) \n  {\n    for (k=1;k<=nfsh;k++)\n    {\n      if (hrate(k) <.9999) \n      {\n        for (int ii=1;ii<=8;ii++)\n        {\n          Ftottmp.initialize();\n          Ftottmp   = ftmp*Fratsel;\n          Z_tmp     = Ftottmp  + M_tmp; \n          S_tmp     = mfexp( -Z_tmp );\n          cc        = wt_tmp(k) * elem_prod(elem_div(ftmp(k)*Fratsel(k),  Z_tmp),elem_prod(1.-S_tmp,N_tmp)); // Catch equation (vectors)\n          ftmp(k)  += ( Catch(k)-cc ) / btmp(k);\n        }\n        Frat(k)    = ftmp(k)/sum(ftmp);\n        Fratsel(k) = Frat(k)*seltmp(k);\n      }\n    }\n  }\n  RETURN_ARRAYS_DECREMENT();\n  return(ftmp);\n\nFUNCTION Write_SimDatafile\n  {\n  int nsims;\n  // get the number of simulated datasets to create...\n  ifstream sim_in(\"nsims.dat\"); sim_in >> nsims; sim_in.close();\n  char buffer [33];\n  ofstream SimDB(\"simout.dat\",ios::app); \n  ofstream TruDB(\"truout.dat\",ios::app); \n  // compute the autocorrelation term for residuals of fit to indices...\n  // for (k=1;k<=nind;k++) ac(k) = get_AC(k);\n  // #int nyrs_fsh_age_sim = endyr-styr;\n  // #int nyrs_ind_sim     = 1+endyr-styr;\n  // #int nyrs_ind_age_sim = 1+endyr-styr;\n  // yrs_fsh_age_sim.fill_seqadd(1977,1);\n  // yrs_ind_sim.fill_seqadd(1977,1);\n  // yrs_ind_age_sim.fill_seqadd(1977,1);\n  // dvector new_ind_sim(1,nyrs_ind_sim);\n  // ivector n_sample_fsh_age_sim(1,nyrs_fsh_age_sim);\n  // ivector n_sample_ind_age_sim(1,nyrs_ind_age_sim);\n\n  ivector nyrs_fsh_age_sim  = nyrs_fsh_age;\n  ivector nyrs_ind_sim      = nyrs_ind;\n  ivector nyrs_ind_age_sim  = nyrs_ind_age;\n  //init_imatrix yrs_ind_in(1,nind,1,nyrs_ind)         //Years of index value (annual)\n  imatrix yrs_fsh_age_sim(1,nfsh,1,nyrs_fsh_age_sim);\n  imatrix yrs_ind_sim(1,nind,1,nyrs_ind_sim);\n  imatrix yrs_ind_age_sim(1,nind,1,nyrs_ind_sim);\n  imatrix n_sample_fsh_age_sim(1,nfsh,1,nyrs_fsh_age_sim);\n  imatrix n_sample_ind_age_sim(1,nind,1,nyrs_ind_age_sim);\n  yrs_fsh_age_sim       = yrs_fsh_age;\n  yrs_ind_sim           = yrs_ind;\n  yrs_ind_age_sim       = yrs_ind_age;\n  dmatrix new_ind_sim(1,nind,1,nyrs_ind);\n  dvector sim_rec_devs(styr_rec,endyr);\n  dvector sim_Sp_Biom(styr_rec,endyr);\n  dmatrix sim_natage(styr_rec,endyr,1,nages);\n  dmatrix catagetmp(styr,endyr,1,nages);\n  dvector sim_catchbio(styr,endyr);\n  double survtmp = value(mfexp(-natmort(styr)));\n  for (k=1;k<=nfsh;k++) Ftot += F(k);\n\n  for (int isim=1;isim<=nsims;isim++)\n  {\n    new_ind_sim.initialize();\n    sim_natage.initialize();\n    // Start w/ simulated population\n    // Simulate using new recruit series (same F's)\n    // fill vector with unit normal RVs\n    sim_rec_devs.fill_randn(rng);\n    sim_rec_devs *= value(sigmar);\n    sim_natage(styr_rec,1) = value(Rzero)*exp(sim_rec_devs(styr_rec));\n    for (j=2; j<=nages; j++)\n      sim_natage(styr_rec,j) = sim_natage(styr_rec,j-1) * survtmp;\n    sim_natage(styr_rec,nages) /= (1.-survtmp); \n  \n    // Simulate population w/ process errors in recruits\n    for (i=styr_rec;i<=endyr;i++)\n    {\n      sim_Sp_Biom(i) = sim_natage(i)*pow(survtmp,spmo_frac) * wt_mature; \n      if (i>styr_rec+rec_age)\n        sim_natage(i,1)          = value(SRecruit(sim_Sp_Biom(i-rec_age)))*mfexp(sim_rec_devs(i)); \n      else\n        sim_natage(i,1)          = value(SRecruit(sim_Sp_Biom(i)))*mfexp(sim_rec_devs(i)); \n  \n      if (i>=styr)\n      {\n        // apply estimated survival rates\n        sim_Sp_Biom(i)          = value( elem_prod(sim_natage(i),pow(S(i),spmo_frac)) * wt_mature); \n        catagetmp(i)            = value( elem_prod(elem_div(Ftot(i),Z(i)),elem_prod(1.-S(i),sim_natage(i))));\n        sim_catchbio(i)         = catagetmp(i)*wt_fsh(1,i);\n        if (i<endyr)\n        {\n          sim_natage(i+1)(2,nages) = value( ++elem_prod(sim_natage(i)(1,nages-1),S(i)(1,nages-1)));\n          sim_natage(i+1,nages)   += value( sim_natage(i,nages)*S(i,nages));\n        }\n      }\n      else\n      {\n        if (i<endyr)\n        {\n          sim_natage(i+1)(2,nages) = ++(sim_natage(i)(1,nages-1) * survtmp);\n          sim_natage(i+1,nages)   += sim_natage(i,nages)*survtmp;\n        }\n      }\n    }\n  \n    //===============================================\n    //Now write from simulated population\n    //\n    // Create the name of the simulated dataset\n    // simname = \"sim_\"+ adstring(itoa(isim,buffer,10)) + \".dat\";\n    // truname = \"tru_\"+ adstring(itoa(isim,buffer,10)) + \".dat\";\n\t\tsimname = \"sim_\"+ adstring(sprintf(buffer,\"%d\",isim)) + \".dat\";\n    truname = \"tru_\"+ adstring(sprintf(buffer,\"%d\",isim)) + \".dat\";\n    ofstream trudat(truname);\n    truth(Rzero);\n    truth(Fmsy);\n    truth(MSY);\n    dvector ntmp(1,nages);\n    dmatrix seltmp(1,nfsh,1,nages);\n    dmatrix Fatmp(1,nfsh,1,nages);\n    dvector Ztmp(1,nages);\n    seltmp.initialize();\n    Fatmp.initialize();\n    Ztmp.initialize();\n    ntmp.initialize();\n    for (k=1;k<=nfsh;k++)\n     seltmp(k) = value(sel_fsh(k,endyr));\n    Ztmp = value(natmort(styr));\n    for (k=1;k<=nfsh;k++)\n    { \n      Fatmp(k) = value(Fratio(k) * Fmsy * seltmp(k));\n      Ztmp    += Fatmp(k);\n    } \n    dvector survmsy = exp(-Ztmp);\n    ntmp(1) = value(Rmsy);\n    for (j=2;j<=nages;j++) \n      ntmp(j) = ntmp(j-1)*survmsy(j-1);\n    ntmp(nages) /= (1-survmsy(nages));\n    // dvariable phi    = elem_prod( ntmp , pow(survmsy,spmo_frac ) )* wt_mature;\n    truth(Rmsy);\n    truth(seltmp);\n    double SurvBmsy;\n    double q_ind_sim=value(mean(q_ind(1)));\n    SurvBmsy = value(elem_prod(wt_ind(1,endyr),elem_prod(pow(survmsy,ind_month_frac(1)), ntmp)) * q_ind_sim*sel_ind(1,endyr)); \n    truth(ntmp);\n    double Cmsy   = value(yield(Fratio,  Fmsy));\n    truth(Cmsy);\n    // Now do OFL for next year...\n    ntmp(1)       = value(SRecruit(sim_Sp_Biom(endyr+1-rec_age)));\n    ntmp(2,nages) = value( ++elem_prod(sim_natage(endyr)(1,nages-1),S(endyr)(1,nages-1)));\n    ntmp(nages)  += value( sim_natage(endyr,nages)*S(endyr,nages));\n    dvector ctmp(1,nages);\n    ctmp.initialize();\n    OFL=0.;\n    for (k=1;k<=nfsh;k++)\n    {\n      for ( j=1 ; j <= nages; j++ )\n        ctmp(j)      = ntmp(j) * Fatmp(k,j) * (1. - survmsy(j)) / Ztmp(j);\n      OFL  += wt_fsh(k,endyr) * ctmp;\n    }\n    double NextSurv = value(elem_prod(wt_ind(1,endyr),elem_prod(pow(survmsy,ind_month_frac(1)), ntmp)) * \n                        q_ind_sim*sel_ind(1,endyr)); \n    double NextSSB  = elem_prod(ntmp, pow(survmsy,spmo_frac)) * wt_mature; \n    // Catch at following year for Fmsy\n    truth(OFL);\n    truth(SurvBmsy);\n    truth(steepness);\n    truth(natmort);\n    truth(sim_natage);\n    truth(sim_Sp_Biom);\n    // Open the simulated dataset for writing\n    ofstream simdat(simname);\n    simdat << \"# first year\" <<endl;\n    simdat << styr <<endl;\n    simdat << \"# Last  year\" <<endl;\n    simdat << endyr <<endl;\n    simdat << \"# age recruit\" <<endl;\n    simdat << rec_age <<endl;\n    simdat << \"# oldest age\" <<endl;\n    simdat << oldest_age <<endl;\n    simdat << \"# Number of fisheries \" <<endl;\n    simdat << nfsh <<endl;                                   \n    simdat << fshnameread <<endl;                                   \n    simdat << \"# Catch biomass by fishery \" <<endl;\n    for (k=1;k<=nfsh;k++)\n    {\n      simdat << \"# \" <<fshname(k) <<\" \" << k <<endl;\n      simdat << sim_catchbio <<endl;\n    }\n    simdat << \"# Catch biomass uncertainty by fishery (std errors)\" <<endl;\n    for (k=1;k<=nfsh;k++)\n    {\n      simdat << \"# \" <<fshname(k) <<\" \" << k <<endl;\n      simdat << catch_bio_sd(k) <<endl;   \n    }\n    simdat << \"# number of years for fishery age data \" <<endl;\n    for (k=1;k<=nfsh;k++)\n    {\n      simdat << \"# \" <<fshname(k)<< \" \" << k <<endl;\n      simdat << nyrs_fsh_age_sim(k) <<endl;\n    }\n    simdat << \"# years for fishery age data \" <<endl;\n    for (k=1;k<=nfsh;k++)\n    {\n      simdat << \"# \" <<fshname(k)<< \" \" << k <<endl;\n      simdat << yrs_fsh_age_sim  <<endl;\n    }\n    simdat << \"# sample sizes for fishery age data \" <<endl;\n    for (k=1;k<=nfsh;k++)\n    {\n      n_sample_fsh_age_sim(k) = mean(n_sample_fsh_age(k));\n      simdat << \"# \" <<fshname(k)<< \" \" << k <<endl;\n      simdat << n_sample_fsh_age_sim(k)         <<endl;    \n    }\n    simdat << \"# Observed age compositions for fishery\" <<endl;\n    for (k=1;k<=nfsh;k++)\n    {\n      dvector p(1,nages);\n      double Ctmp; // total catch\n      dvector freq(1,nages);\n      simdat << \"# \" << fshname(k) <<endl;\n      for (i=1;i<=nyrs_fsh_age_sim(k);i++)\n      {\n        int iyr = yrs_fsh_age_sim(k,i);\n        // Add noise here\n        freq.initialize();\n        ivector bin(1,n_sample_fsh_age_sim(k,i));\n        p  = catagetmp(iyr);\n        p /= sum(p);\n        bin.fill_multinomial(rng,p); // fill a vector v\n        for (int j=1;j<=n_sample_fsh_age_sim(k,i);j++)\n          freq(bin(j))++;\n        // Apply ageing error to samples..............\n        // p = age_err *freq/sum(freq); \n        p = freq/sum(freq); \n        // cout << p  <<endl;\n        simdat << p  <<endl;\n        // Compute total catch given this sample size for catch-age\n        Ctmp = sim_catchbio(iyr) / (p*wt_fsh(k,iyr)); \n        // Simulated catage = proportion sampled\n        // sim_catage(k,i) = p * Ctmp;\n      }\n    }\n    simdat << \"# Annual wt-at-age for fishery\" <<endl;\n    for (k=1;k<=nfsh;k++)\n    {\n      simdat << \"# \" <<fshname(k)<< \" \" << (k) <<endl;\n      // Add noise here\n      simdat << wt_fsh(k)  <<endl;  \n    }\n    simdat << \"# number of indices\" <<endl;\n    simdat << nind <<endl;                                   \n    simdat << indnameread <<endl;                                   \n    simdat << \"# Number of years of index values (annual)\" <<endl;\n    for (k=1;k<=nind;k++)\n    {\n      simdat << \"# \" << indname(k) <<endl;\n      simdat << nyrs_ind_sim(k)  <<endl;                   \n    }\n    simdat << \"# Years of index values (annual)\" <<endl;\n    for (k=1;k<=nind;k++)\n    {\n      simdat << \"# \" << indname(k) <<endl;\n      simdat << yrs_ind_sim <<endl;         \n    }\n    simdat << \"# Month that index occurs \"<<endl;\n    for (k=1;k<=nind;k++)\n    {\n      simdat << \"# \" << indname(k) <<endl;\n      simdat << mo_ind(k) <<endl;\n    }\n    simdat << \"# values for indices (annual)\"<<endl;\n    // note assumes only one index...\n    double ind_sigma;\n    dmatrix ind_devs(1,nind,1,nyrs_ind_sim);\n    for (k=1;k<=nind;k++)\n    {\n      ind_sigma = mean(obs_lse_ind(k)) ;\n      //ind_sigma = 0.30 ;\n      simdat << \"# \" <<indname(k)<< \" \" << k <<endl;\n      // Add noise here\n      // fill vector with unit normal RVs\n      ind_devs.fill_randn(rng);\n      ind_devs(k) *= ind_sigma ;\n      for (i=1;i<=nyrs_ind_sim(k);i++)\n      {\n        int iyr=yrs_ind_sim(k,i);\n        //uncorrelated...corr_dev(k,i) = ac(k) * corr_dev(k,i-1) + sqrt(1.-square(ac(k))) * corr_dev(k,i);\n        new_ind_sim(k,i) = mfexp(ind_devs(k,i) - ind_sigma/2.) * value(elem_prod(wt_ind(k,iyr),elem_prod(pow(S(iyr),ind_month_frac(k)), \n                        sim_natage(iyr))) * q_ind_sim*sel_ind(k,iyr)); \n      }\n      simdat << new_ind_sim(k)     <<endl;\n      dvector ExactSurvey = elem_div(new_ind_sim(k),exp(ind_devs(k)-ind_sigma/2.));\n      truth(ExactSurvey);\n    }\n    simdat << \"# standard errors for indices (by year) \" <<endl;\n    for (k=1;k<=nind;k++)\n    {\n      simdat << \"# \" <<indname(k)<< \" \" << k <<endl;\n      // simdat << new_ind_sim*mean(elem_div(obs_se_ind(k),obs_ind(k)))  <<endl;\n      simdat << new_ind_sim(k)*ind_sigma  <<endl;\n    }\n    simdat << \"# Number of years of age data available for index\" <<endl;\n    for (k=1;k<=nind;k++)\n    {\n      simdat << \"# \" <<indname(k)<< \" \" << k <<endl;\n      simdat << nyrs_ind_age_sim(k) <<endl;\n    }\n    simdat << \"# Years of index values (annual)\" <<endl;\n    for (k=1;k<=nind;k++)\n    {\n      simdat << \"# \" <<indname(k)<< endl;\n      simdat << yrs_ind_age_sim(k) <<endl;\n    }\n    simdat << \"# Sample sizes for age data from indices\" <<endl;\n    for (k=1;k<=nind;k++)\n    {\n      n_sample_ind_age_sim(k) = mean(n_sample_ind_age(k));\n      simdat << \"# \" <<indname(k)<< endl;\n      simdat << n_sample_ind_age_sim(k) <<endl;\n    }\n    simdat << \"# values of proportions at age in index\" <<endl;\n    for (k=1;k<=nind;k++)\n    {\n      simdat << \"# \" <<indname(k)<< endl;\n      dvector p(1,nages);\n      dvector freq(1,nages);\n      for (i=1;i<=nyrs_ind_age_sim(k);i++)\n      {\n        int iyr = yrs_ind_age_sim(k,i);\n        // Add noise here\n        freq.initialize();\n        ivector bin(1,n_sample_ind_age_sim(k,i));\n        // p = age_err * value(elem_prod( elem_prod(pow(S(iyr),ind_month_frac(k)), sim_natage(iyr))*q_ind_sim , sel_ind(k,iyr))); \n        p = value(elem_prod( elem_prod(pow(S(iyr),ind_month_frac(k)), sim_natage(iyr))*q_ind_sim , sel_ind(k,iyr))); \n        p /= sum(p);\n        // fill vector with multinomial samples\n        bin.fill_multinomial(rng,p); // fill a vector v\n        for (int j=1;j<=n_sample_ind_age_sim(k,i);j++)\n          freq(bin(j))++;\n        simdat << \"# \" <<indname(k)<< \" year: \"<< iyr<< endl;\n        simdat << freq/sum(freq) <<endl;\n      }\n    }\n    simdat << \"# Mean wts at age for indices\" <<endl;\n    for (k=1;k<=nind;k++)\n    {\n      simdat << \"# \" <<indname(k)<< endl;\n      // Could add noise here\n      simdat <<  wt_ind(k)  <<endl;\n    }\n  \n    simdat << \"# Population mean wt at age\" <<endl;\n    simdat << wt_pop <<endl;\n  \n    simdat << \"# Population maturity at age\" <<endl;\n    simdat << maturity  <<endl;\n  \n    simdat << \"# Peak spawning month\" <<endl;\n    simdat << spawnmo <<endl;\n  \n    simdat << \"# ageing error \" <<endl;\n    simdat << age_err <<endl;\n\n    simdat <<endl<<endl<<\"Additional output\"<<endl;\n    simdat << \"# Fishery_Effort \" <<endl;\n    for (k=1;k<=nfsh;k++)\n    {\n      dvector ran_fsh_vect(styr,endyr);\n      // fill vector with unit normal RVs\n      ran_fsh_vect.fill_randn(rng);\n      // Sigma on effort is ~15% white noise (add red noise later)\n      ran_fsh_vect *= 0.15; \n      dvector avail_biom(styr,endyr);\n      for (i=styr;i<=endyr;i++)\n      {\n        avail_biom(i) = wt_fsh(k,i)*value(elem_prod(sim_natage(i),sel_fsh(k,i))); \n      }\n      act_eff(k) = elem_prod(exp(ran_fsh_vect), (elem_div(catch_bio(k), avail_biom)) );\n      // Normalize effort\n      act_eff(k) /= mean(act_eff(k));\n      for (i=styr;i<=endyr;i++)\n        simdat<<fshname(k)<<\" \"<<i<<\" \"<<act_eff(k,i) <<endl;\n    }\n    simdat << \"# Fishery catch-at-age \" <<endl;\n    for (k=1;k<=nfsh;k++)\n    {\n      simdat << \"# \" <<fshname(k)<< \" \" << k <<endl;\n      simdat << \"Fishery Year \"<<age_vector << endl;\n      for (i=1;i<=nyrs_fsh_age(k);i++)\n        simdat<<fshname(k)<<\" \"<<yrs_fsh_age(k,i)<<\" \"<<catagetmp(yrs_fsh_age(k,i)) <<endl;\n    }\n    // Write simple file by simulation\n    dmatrix ExactSurvey(1,nind,1,nyrs_ind) ;\n    for (k=1;k<=nind;k++)\n    {\n      ExactSurvey(k) = elem_div(new_ind_sim(k),exp(ind_devs(k)-ind_sigma/2.));\n      for (i=1;i<=nyrs_ind(k);i++)\n      {\n        SimDB<<model_name<<\" simIndex \"<<isim<<\" \"<< yrs_ind_sim(k,i) <<\" \"<< \n        new_ind_sim(k,i) <<\" \"<< \n        new_ind_sim(k,i)*ind_sigma  <<endl;\n      }\n    }\n      \n    for (k=1;k<=nfsh;k++)\n    {\n      ExactSurvey(k) = elem_div(new_ind_sim(k),exp(ind_devs(k)-ind_sigma/2.));\n      for (i=styr;i<=endyr;i++)\n      {\n       SimDB<<model_name<<\" simCatch \"<<isim<<\" \"<< i<<\" \"<< sim_catchbio(i)       <<\" \"<< endl;\n       TruDB<<model_name<<\" \" <<isim<<\" \"<< i<<\" \"<<\n        sim_catchbio(i)      <<\" \"<< \n        sim_natage(i,1)      <<\" \"<< \n        sim_Sp_Biom(i)       <<\" \"<< \n        steepness            <<\" \"<< \n        Bmsy                 <<\" \"<< \n        MSYL                 <<\" \"<< \n        MSY                  <<\" \"<< \n        SurvBmsy             <<\" \"<<\n        endl;\n    }\n    TruDB<<model_name<<\" \"<<isim<<\" \"<< endyr+1<<\" \"<<\n        OFL                  <<\" \"<< \n        SRecruit(sim_Sp_Biom(endyr+1-rec_age))<<\" \"<<\n        sim_Sp_Biom(endyr)   <<\" \"<< \n        NextSurv             <<\" \"<< \n        steepness            <<\" \"<< \n        Bmsy                 <<\" \"<< \n        MSYL                 <<\" \"<< \n        MSY                  <<\" \"<< \n        SurvBmsy             <<\" \"<<\n        endl;\n    }\n    trudat.close();\n  }\n  SimDB.close();\n  TruDB.close();\n  exit(1);\n  // End of simulating datasets...................\n  }\n\nFUNCTION Write_Datafile\n  dmatrix new_ind(1,nind,1,nyrs_ind);\n  new_ind.initialize();\n  int nsims;\n  // get the number of simulated datasets to create...\n  ifstream sim_in(\"nsims.dat\"); sim_in >> nsims; sim_in.close();\n  char buffer [33];\n  // compute the autocorrelation term for residuals of fit to indices...\n  for (k=1;k<=nind;k++)\n    ac(k) = get_AC(k);\n  for (int isim=1;isim<=nsims;isim++)\n  {\n    // Create the name of the simulated dataset\n    // simname = \"sim_\"+ adstring(itoa(isim,buffer,10)) + \".dat\";\n\t\tsimname = \"sim_\"+ adstring(sprintf(buffer,\"%d\",isim)) + \".dat\";\n    // Open the simulated dataset for writing\n    ofstream simdat(simname);\n    simdat << \"# first year\" <<endl;\n    simdat << styr <<endl;\n    simdat << \"# Last  year\" <<endl;\n    simdat << endyr <<endl;\n    simdat << \"# age recruit\" <<endl;\n    simdat << rec_age <<endl;\n    simdat << \"# oldest age\" <<endl;\n    simdat << oldest_age <<endl;\n    simdat << \"# Number of fisheries \" <<endl;\n    simdat << nfsh <<endl;                                   \n    simdat << fshnameread <<endl;                                   \n    simdat << \"# Catch biomass by fishery \" <<endl;\n    for (k=1;k<=nfsh;k++)\n    {\n      simdat << \"# \" <<fshname(k) <<\" \" << k <<endl;\n      simdat << catch_bio(k) <<endl;\n    }\n    simdat << \"# Catch biomass uncertainty by fishery (std errors)\" <<endl;\n    for (k=1;k<=nfsh;k++)\n    {\n      simdat << \"# \" <<fshname(k) <<\" \" << k <<endl;\n      simdat << catch_bio_sd(k) <<endl;   \n    }\n    simdat << \"# number of years for fishery age data \" <<endl;\n    for (k=1;k<=nfsh;k++)\n    {\n      simdat << \"# \" <<fshname(k)<< \" \" << k <<endl;\n      simdat << nyrs_fsh_age(k) <<endl;\n    }\n    simdat << \"# years for fishery age data \" <<endl;\n    for (k=1;k<=nfsh;k++)\n    {\n      simdat << \"# \" <<fshname(k)<< \" \" << k <<endl;\n      simdat << yrs_fsh_age(k)  <<endl;\n    }\n    simdat << \"# sample sizes for fishery age data \" <<endl;\n    for (k=1;k<=nfsh;k++)\n    {\n      simdat << \"# \" <<fshname(k)<< \" \" << k <<endl;\n      simdat << n_sample_fsh_age(k)  <<endl;    \n    }\n    simdat << \"# Observed age compositions for fishery\" <<endl;\n    for (k=1;k<=nfsh;k++)\n    {\n      dvector p(1,nages);\n      double Ctmp; // total catch\n      dvector freq(1,nages);\n      simdat << \"# \" << fshname(k) <<endl;\n      for (i=1;i<=nyrs_fsh_age(k);i++)\n      {\n        int iyr = yrs_fsh_age(k,i);\n        // Add noise here\n        freq.initialize();\n        ivector bin(1,n_sample_fsh_age(k,i));\n        p  = value(catage(k,iyr));\n        p /= sum(p);\n        bin.fill_multinomial(rng,p); // fill a vector v\n        for (int j=1;j<=n_sample_fsh_age(k,i);j++)\n          freq(bin(j))++;\n        // Apply ageing error to samples..............\n        p = age_err *freq/sum(freq); \n        // cout << p  <<endl;\n        simdat << p  <<endl;\n        // Compute total catch given this sample size\n        Ctmp = catch_bio(k,iyr) / (p*wt_fsh(k,iyr)); \n        // Simulated catage = proportion sampled\n        catage(k,i) = p * Ctmp;\n      }\n    }\n    simdat << \"# Annual wt-at-age for fishery\" <<endl;\n    for (k=1;k<=nfsh;k++)\n    {\n      simdat << \"# \" <<fshname(k)<< \" \" << (k) <<endl;\n      // Add noise here\n      simdat << wt_fsh(k)  <<endl;  \n    }\n    simdat << \"# number of indices\" <<endl;\n    simdat << nind <<endl;                                   \n    simdat << indnameread <<endl;                                   \n    simdat << \"# Number of years of index values (annual)\" <<endl;\n    for (k=1;k<=nind;k++)\n    {\n      simdat << \"# \" << indname(k) <<endl;\n      simdat << nyrs_ind(k)  <<endl;                   \n    }\n    simdat << \"# Years of index values (annual)\" <<endl;\n    for (k=1;k<=nind;k++)\n    {\n      simdat << \"# \" << indname(k) <<endl;\n      simdat << yrs_ind(k)  <<endl;         \n    }\n    simdat << \"# Month that index occurs \"<<endl;\n    for (k=1;k<=nind;k++)\n    {\n      simdat << \"# \" << indname(k) <<endl;\n      simdat << mo_ind(k) <<endl;\n    }\n    simdat << \"# values for indices (annual)\"<<endl;\n    for (k=1;k<=nind;k++)\n    {\n      simdat << \"# \" <<indname(k)<< \" \" << k <<endl;\n      // Add noise here\n      dvector ran_ind_vect(1,nyrs_ind(k));\n      // fill vector with unit normal RVs\n      ran_ind_vect.fill_randn(rng);\n      // do first year uncorrelated\n      i=1;\n      int iyr=yrs_ind(k,i);\n      corr_dev(k)  = ran_ind_vect;\n      new_ind(k,i) = mfexp(corr_dev(k,i) * obs_lse_ind(k,i) ) * \n                     value(elem_prod(wt_ind(k,iyr),elem_prod(pow(S(iyr),ind_month_frac(k)), natage(iyr)))*\n                     q_ind(k,i)*sel_ind(k,iyr)); \n      // do next years correlated with previous\n      for (i=2;i<=nyrs_ind(k);i++)\n      {\n        iyr=yrs_ind(k,i);\n        corr_dev(k,i) = ac(k) * corr_dev(k,i-1) + sqrt(1.-square(ac(k))) * corr_dev(k,i);\n        new_ind(k,i) = mfexp(corr_dev(k,i) * obs_lse_ind(k,i) ) * \n                        value(elem_prod(wt_ind(k,iyr),elem_prod(pow(S(iyr),ind_month_frac(k)), \n                        natage(iyr))) * q_ind(k,i)*sel_ind(k,iyr)); \n      }\n      simdat << new_ind(k)      <<endl;\n    }\n    simdat << \"# standard errors for indices (by year) \" <<endl;\n    for (k=1;k<=nind;k++)\n    {\n      simdat << \"# \" <<indname(k)<< \" \" << k <<endl;\n      simdat << obs_se_ind(k)  <<endl;\n    }\n    simdat << \"# Number of years of age data available for index\" <<endl;\n    for (k=1;k<=nind;k++)\n    {\n      simdat << \"# \" <<indname(k)<< \" \" << k <<endl;\n      simdat << nyrs_ind_age(k)  <<endl;\n    }\n    simdat << \"# Years of index values (annual)\" <<endl;\n    for (k=1;k<=nind;k++)\n    {\n      simdat << \"# \" <<indname(k)<< endl;\n      simdat << yrs_ind_age(k)  <<endl;\n    }\n    simdat << \"# Sample sizes for age data from indices\" <<endl;\n    for (k=1;k<=nind;k++)\n    {\n      simdat << \"# \" <<indname(k)<< endl;\n      simdat << n_sample_ind_age(k)  <<endl;\n    }\n    simdat << \"# values of proportions at age in index\" <<endl;\n    for (k=1;k<=nind;k++)\n    {\n      simdat << \"# \" <<indname(k)<< endl;\n      dvector p(1,nages);\n      dvector freq(1,nages);\n      for (i=1;i<=nyrs_ind_age(k);i++)\n      {\n        int iyr = yrs_ind_age(k,i);\n        // Add noise here\n        freq.initialize();\n        ivector bin(1,n_sample_ind_age(k,i));\n        p = age_err * value(elem_prod( elem_prod(pow(S(iyr),ind_month_frac(k)), natage(iyr))*q_ind(k,i) , sel_ind(k,iyr))); \n        p /= sum(p);\n        // fill vector with multinomial samples\n        bin.fill_multinomial(rng,p); // fill a vector v\n        for (int j=1;j<=n_sample_ind_age(k,i);j++)\n          freq(bin(j))++;\n        simdat << \"# \" <<indname(k)<< \" year: \"<< iyr<< endl;\n        simdat << freq/sum(freq) <<endl;\n      }\n    }\n    simdat << \"# Mean wts at age for indices\" <<endl;\n    for (k=1;k<=nind;k++)\n    {\n      simdat << \"# \" <<indname(k)<< endl;\n      // Could add noise here\n      simdat <<  wt_ind(k)  <<endl;\n    }\n  \n    simdat << \"# Population mean wt at age\" <<endl;\n    simdat << wt_pop <<endl;\n  \n    simdat << \"# Population maturity at age\" <<endl;\n    simdat << maturity  <<endl;\n  \n    simdat << \"# Peak spawning month\" <<endl;\n    simdat << spawnmo <<endl;\n  \n    simdat << \"# ageing error \" <<endl;\n    simdat << age_err <<endl;\n\n    simdat <<endl<<endl<<\"Additional output\"<<endl;\n    simdat << \"# Fishery_Effort \" <<endl;\n    for (k=1;k<=nfsh;k++)\n    {\n      dvector ran_fsh_vect(styr,endyr);\n      // fill vector with unit normal RVs\n      ran_fsh_vect.fill_randn(rng);\n      // Sigma on effort is ~15% white noise (add red noise later)\n      ran_fsh_vect *= 0.15; \n      dvector avail_biom(styr,endyr);\n      for (i=styr;i<=endyr;i++)\n      {\n        avail_biom(i) = wt_fsh(k,i)*value(elem_prod(natage(i),sel_fsh(k,i))); \n      }\n      act_eff(k) = elem_prod(exp(ran_fsh_vect), (elem_div(catch_bio(k), avail_biom)) );\n      // Normalize effort\n      act_eff(k) /= mean(act_eff(k));\n      for (i=styr;i<=endyr;i++)\n        simdat<<fshname(k)<<\" \"<<i<<\" \"<<act_eff(k,i) <<endl;\n    }\n    simdat << \"# Fishery catch-at-age \" <<endl;\n    for (k=1;k<=nfsh;k++)\n    {\n      simdat << \"# \" <<fshname(k)<< \" \" << k <<endl;\n      simdat << \"Fishery Year \"<<age_vector << endl;\n      for (i=1;i<=nyrs_fsh_age(k);i++)\n        simdat<<fshname(k)<<\" \"<<yrs_fsh_age(k,i)<<\" \"<<catage(k,i) <<endl;\n    }\n  }\n  exit(1);\n  // End of simulating datasets...................\n  \n\nFUNCTION Write_R\n  ofstream R_report(\"For_R.rep\");\n  for (k=1;k<=nfsh;k++)\n  {\n    R_report<< \"$sel_p1_fsh_\"<<k<<endl<<sel_p1_fsh(k)<<endl;\n    R_report<< \"$sel_p2_fsh_\"<<k<<endl<<sel_p2_fsh(k)<<endl;\n    R_report<< \"$sel_p3_fsh_\"<<k<<endl<<sel_p3_fsh(k)<<endl;\n  }\n  R_Report(phizero);\n  R_Report(B100);\n  R_Report(B100.sd);\n  R_report<< \"$repl_yld\"<<endl<<repl_yld<<endl; \n  R_report<< \"$repl_SSB\"<<endl<<repl_SSB<<endl; \n  R_report<<\"$M\"<<endl; \n  R_report<<M<<endl;\n  for (k=1;k<=nind;k++)\n  {\n    R_report<<\"$q_\"<<k<<endl; \n    for (i=1;i<nyrs_ind(k);i++)\n    {        \n      int iyr=yrs_ind(k,i);\n      for (int ii=iyr;ii<yrs_ind(k,i+1);ii++)\n        R_report<<ii<<\" \"<<pow(q_ind(k,i),q_power_ind(k))<<endl;\n    }\n    R_report<<yrs_ind(k,nyrs_ind(k))<<\" \"<<pow(q_ind(k,nyrs_ind(k)),q_power_ind(k))<<endl;\n  }\n  R_report<<\"$M_equil\"<<endl; R_report<<natmort<<endl;\n  R_report<<\"$SurvNextYr\"<<endl; R_report<< pred_ind_nextyr <<endl;\n  R_report<<\"$Yr\"<<endl; for (i=styr;i<=endyr;i++) R_report<<i<<\" \"; R_report<<endl;\n  R_Report(P_age2len);\n  R_Report(len_bins);\n  R_report<<\"$TotF\"<<endl << Ftot<<endl;\n  R_report<<\"$TotBiom_NoFish\"<<endl; for (i=styr;i<=endyr;i++) \n  {\n    double lb=value(totbiom_NoFish(i)/exp(2.*sqrt(log(1+square(totbiom_NoFish.sd(i))/square(totbiom_NoFish(i))))));\n    double ub=value(totbiom_NoFish(i)*exp(2.*sqrt(log(1+square(totbiom_NoFish.sd(i))/square(totbiom_NoFish(i))))));\n    R_report<<i<<\" \"<<totbiom_NoFish(i)<<\" \"<<totbiom_NoFish.sd(i)<<\" \"<<lb<<\" \"<<ub<<endl;\n  }\n  R_report<<\"$SSB_NoFishR\"<<endl; for (i=styr+1;i<=endyr;i++) \n  {\n    double lb=value(Sp_Biom_NoFishRatio(i)/exp(2.*sqrt(log(1+square(Sp_Biom_NoFishRatio.sd(i))/square(Sp_Biom_NoFishRatio(i))))));\n    double ub=value(Sp_Biom_NoFishRatio(i)*exp(2.*sqrt(log(1+square(Sp_Biom_NoFishRatio.sd(i))/square(Sp_Biom_NoFishRatio(i))))));\n    R_report<<i<<\" \"<<Sp_Biom_NoFishRatio(i)<<\" \"<< Sp_Biom_NoFishRatio.sd(i)<<\" \"<<lb<<\" \"<<ub<<endl;\n  }\n\n  R_report<<\"$TotBiom\"<<endl; \n  for (i=styr;i<=endyr+1;i++) \n  {\n    double lb=value(totbiom(i)/exp(2.*sqrt(log(1+square(totbiom.sd(i))/square(totbiom(i))))));\n    double ub=value(totbiom(i)*exp(2.*sqrt(log(1+square(totbiom.sd(i))/square(totbiom(i))))));\n    R_report<<i<<\" \"<<totbiom(i)<<\" \"<<totbiom.sd(i)<<\" \"<<lb<<\" \"<<ub<<endl;\n  }\n\n  for (k=1;k<=5;k++){\n    R_report<<\"$SSB_fut_\"<<k<<endl; \n    for (i=styr_fut;i<=endyr_fut;i++) \n    {\n      double lb=value(SSB_fut(k,i)/exp(2.*sqrt(log(1+square(SSB_fut.sd(k,i))/square(SSB_fut(k,i))))));\n      double ub=value(SSB_fut(k,i)*exp(2.*sqrt(log(1+square(SSB_fut.sd(k,i))/square(SSB_fut(k,i))))));\n      R_report<<i<<\" \"<<SSB_fut(k,i)<<\" \"<<SSB_fut.sd(k,i)<<\" \"<<lb<<\" \"<<ub<<endl;\n    }\n  }\n  double ctmp;\n  for (k=1;k<=5;k++){\n    R_report<<\"$Catch_fut_\"<<k<<endl; \n    for (i=styr_fut;i<=endyr_fut;i++) \n    {\n      if (k==5) ctmp=0.;else ctmp=value(catch_future(k,i));\n      R_report<<i<<\" \"<<ctmp<<endl;\n    }\n  }\n\n  R_report<<\"$SSB\"<<endl; for (i=styr_sp;i<=endyr+1;i++) \n  {\n    double lb=value(Sp_Biom(i)/exp(2.*sqrt(log(1+square(Sp_Biom.sd(i))/square(Sp_Biom(i))))));\n    double ub=value(Sp_Biom(i)*exp(2.*sqrt(log(1+square(Sp_Biom.sd(i))/square(Sp_Biom(i))))));\n    R_report<<i<<\" \"<<Sp_Biom(i)<<\" \"<<Sp_Biom.sd(i)<<\" \"<<lb<<\" \"<<ub<<endl;\n  }\n\n  R_report<<\"$R\"<<endl; for (i=styr;i<=endyr;i++) \n  {\n    double lb=value(recruits(i)/exp(2.*sqrt(log(1+square(recruits.sd(i))/square(recruits(i))))));\n    double ub=value(recruits(i)*exp(2.*sqrt(log(1+square(recruits.sd(i))/square(recruits(i))))));\n    R_report<<i<<\" \"<<recruits(i)<<\" \"<<recruits.sd(i)<<\" \"<<lb<<\" \"<<ub<<endl;\n  }\n    R_report << \"$N\"<<endl;\n    for (i=styr;i<=endyr;i++) \n      R_report <<   i << \" \"<< natage(i) << endl;\n      R_report   << endl;\n\n    for (k=1;k<=nfsh;k++)\n    {\n      R_report << \"$F_age_\"<< (k) <<\"\"<< endl ;\n      for (i=styr;i<=endyr;i++) \n        R_report <<i<<\" \"<<F(k,i)<<\" \"<< endl;\n        R_report   << endl;\n    }\n\n    R_report <<endl<< \"$Fshry_names\"<< endl;\n    for (k=1;k<=nfsh;k++)\n      R_report << fshname(k) << endl ;\n\n    R_report <<endl<< \"$Index_names\"<< endl;\n    for (k=1;k<=nind;k++)\n      R_report << indname(k) << endl ;\n\n    for (k=1;k<=nind;k++)\n    {\n      int ii=1;\n\t\t\tdouble qtmp;\n\t\t\tqtmp = value(q_ind(k,1));\n      R_report <<endl<< \"$Obs_Survey_\"<< k <<\"\"<< endl ;\n      for (i=styr;i<=endyr;i++)\n      {\n        if (ii<=yrs_ind(k).indexmax())\n        {\n          if (yrs_ind(k,ii)==i)\n          {\n\t\t\t\t\t\tqtmp = value(q_ind(k,ii));\n            double PearsResid   =  value((obs_ind(k,ii)-pred_ind(k,ii))/obs_se_ind(k,ii) );\n            double lnPearsResid =  value((log(obs_ind(k,ii))-log(pred_ind(k,ii)))/obs_lse_ind(k,ii) );\n            R_report << i<< \" \"<< obs_ind(k,ii)   <<\" \"<< \n                                  pred_ind(k,ii)  <<\" \"<< \n                                  obs_se_ind(k,ii)<<\" \"<<  \n                                  PearsResid      <<\" \"<<\n                                  lnPearsResid    << endl; //values of survey index value (annual)\n            ii++;\n          }\n          else\n          {\n             int iyr=i; \n             double predtmp = value(qtmp * pow(elem_prod(natage(iyr),pow(S(iyr),ind_month_frac(k))) * \n                              elem_prod(sel_ind(k,iyr) , wt_ind(k,iyr)),q_power_ind(k)) );\n            R_report << i<< \" NA \"<< \" \"<< predtmp <<\" NA NA NA\"<<endl;\n          }\n        }\n        else\n        {\n          int iyr=i; \n          double predtmp = value(qtmp * pow(elem_prod(natage(iyr),pow(S(iyr),ind_month_frac(k))) * \n                            elem_prod(sel_ind(k,iyr) , wt_ind(k,iyr)),q_power_ind(k)) );\n          R_report << i<< \" NA \"<< \" \"<< predtmp <<\" NA NA NA\"<<endl;\n        }\n      }\n      R_report   << endl;\n      R_report << endl<< \"$Index_Q_\"<<k<<endl;\n      R_report<< q_ind(k) << endl;\n    }\n    R_report   << endl;\n    for (k=1;k<=nfsh;k++)\n    {\n      if (nyrs_fsh_age(k)>0) \n      { \n        R_report << \"$pobs_fsh_\"<< (k) <<\"\"<< endl;\n        for (i=1;i<=nyrs_fsh_age(k);i++) \n          R_report << yrs_fsh_age(k,i)<< \" \"<< oac_fsh(k,i) << endl;\n        R_report   << endl;\n\n        R_report << \"$phat_fsh_\"<< (k) <<\"\"<< endl;\n        for (i=1;i<=nyrs_fsh_age(k);i++) \n          R_report << yrs_fsh_age(k,i)<< \" \"<< eac_fsh(k,i) << endl;\n          R_report   << endl;\n\n        R_report << \"$sdnr_age_fsh_\"<< (k) <<\"\"<< endl;\n        for (i=1;i<=nyrs_fsh_age(k);i++) \n          R_report << yrs_fsh_age(k,i)<< \" \"<< sdnr( eac_fsh(k,i),oac_fsh(k,i),n_sample_fsh_age(k,i)) << endl;\n        R_report   << endl;\n      }\n      if (nyrs_fsh_length(k)>0) \n      { \n        R_report << \"$pobs_len_fsh_\"<< (k) <<\"\"<< endl;\n        for (i=1;i<=nyrs_fsh_length(k);i++) \n          R_report << yrs_fsh_length(k,i)<< \" \"<< olc_fsh(k,i) << endl;\n        R_report   << endl;\n\n        R_report << \"$phat_len_fsh_\"<< (k) <<\"\"<< endl;\n        for (i=1;i<=nyrs_fsh_length(k);i++) \n          R_report << yrs_fsh_length(k,i)<< \" \"<< elc_fsh(k,i) << endl;\n        R_report   << endl;\n\n        R_report << \"$sdnr_length_fsh_\"<< (k) <<\"\"<< endl;\n        for (i=1;i<=nyrs_fsh_length(k);i++) \n          R_report << yrs_fsh_length(k,i)<< \" \"<< sdnr( elc_fsh(k,i),olc_fsh(k,i),n_sample_fsh_length(k,i)) << endl;\n        R_report   << endl;\n      }\n    }\n    for (k=1;k<=nind;k++)\n    {\n      if (nyrs_ind_age(k)>0) \n      { \n        R_report << \"$pobs_ind_\"<<(k)<<\"\"<<  endl;\n        for (i=1;i<=nyrs_ind_age(k);i++) \n          R_report << yrs_ind_age(k,i)<< \" \"<< oac_ind(k,i) << endl;\n        R_report   << endl;\n        \n        R_report << \"$phat_ind_\"<<(k)<<\"\"<<  endl;\n        for (i=1;i<=nyrs_ind_age(k);i++) \n          R_report << yrs_ind_age(k,i)<< \" \"<< eac_ind(k,i) << endl;\n        R_report   << endl;\n\n        R_report << \"$sdnr_age_ind_\"<< (k) <<\"\"<< endl;\n        for (i=1;i<=nyrs_ind_age(k);i++) \n          R_report << yrs_ind_age(k,i)<< \" \"<< sdnr( eac_ind(k,i),oac_ind(k,i),n_sample_ind_age(k,i)) << endl;\n        R_report   << endl;\n      }\n      if (nyrs_ind_length(k)>0) \n      { \n        R_report << \"$pobs_len_ind_\"<< (k) <<\"\"<< endl;\n        for (i=1;i<=nyrs_ind_length(k);i++) \n          R_report << yrs_ind_length(k,i)<< \" \"<< olc_ind(k,i) << endl;\n        R_report   << endl;\n        R_report << \"$phat_len_ind_\"<< (k) <<\"\"<< endl;\n        for (i=1;i<=nyrs_ind_length(k);i++) \n          R_report << yrs_ind_length(k,i)<< \" \"<< elc_ind(k,i) << endl;\n        R_report   << endl;\n        R_report << \"$sdnr_length_ind_\"<< (k) <<\"\"<< endl;\n        for (i=1;i<=nyrs_ind_length(k);i++) \n          R_report << yrs_ind_length(k,i)<< \" \"<< sdnr( eac_ind(k,i),oac_ind(k,i),n_sample_ind_length(k,i)) << endl;\n        R_report   << endl;\n\n      } \n    }\n    for (k=1;k<=nind;k++)\n\t\t{\n      R_report <<\"$sdnr_ind_\"<<k<<endl;\n\t\t\tR_report << std_dev(elem_div((pred_ind(k)-obs_ind(k)),obs_se_ind(k)))<<endl;\n\t\t}\n    for (k=1;k<=nfsh;k++)\n    {\n      R_report << endl<< \"$Obs_catch_\"<<(k) << endl;\n      R_report << catch_bio(k) << endl;\n      R_report   << endl;\n      R_report << \"$Pred_catch_\" <<(k) << endl;\n      R_report << pred_catch(k) << endl;\n      R_report   << endl;\n    }\n\n    for (k=1;k<=nfsh;k++)\n    {\n      R_report << \"$F_fsh_\"<<(k)<<\" \"<<endl;\n      for (i=styr;i<=endyr;i++)\n      {\n        R_report<< i<< \" \";\n        R_report<< mean(F(k,i)) <<\" \"<< mean(F(k,i))*max(sel_fsh(k,i)) << \" \";\n        R_report<< endl;\n      }\n    }\n\n    for (k=1;k<=nfsh;k++)\n    {\n      R_report << endl<< \"$sel_fsh_\"<<(k)<<\"\" << endl;\n      for (i=styr;i<=endyr;i++)\n        R_report << k <<\"  \"<< i<<\" \"<<sel_fsh(k,i) << endl; \n      R_report   << endl;\n    }\n\n    for (k=1;k<=nind;k++)\n    {\n      R_report << endl<< \"$sel_ind_\"<<(k)<<\"\" << endl;\n      for (i=styr;i<=endyr;i++)\n        R_report << k <<\"  \"<< i<<\" \"<<sel_ind(k,i) << endl;\n        R_report << endl;\n\n    }\n    R_report << endl<< \"$Stock_Rec\"<< endl;\n    for (i=styr_rec;i<=endyr;i++)\n      if (active(log_Rzero))\n        R_report << i<< \" \"<<Sp_Biom(i-rec_age)<< \" \"<< SRecruit(Sp_Biom(i-rec_age))<< \" \"<< mod_rec(i)<<endl;\n      else \n        R_report << i<< \" \"<<Sp_Biom(i-rec_age)<< \" \"<< \" 999\" << \" \"<< mod_rec(i)<<endl;\n        \n        R_report   << endl;\n\n    R_report <<\"$stock_Rec_Curve\"<<endl;\n    R_report <<\"0 0\"<<endl;\n    dvariable stock;\n    for (i=1;i<=30;i++)\n    {\n      stock = double (i) * Bzero /25.;\n      if (active(log_Rzero))\n        R_report << stock <<\" \"<< SRecruit(stock)<<endl;\n      else\n        R_report << stock <<\" 99 \"<<endl;\n    }\n    R_report   << endl;\n\n    R_report   << endl<<\"$Like_Comp\" <<endl;\n    obj_comps(13)= obj_fun - sum(obj_comps) ; // Residual \n    obj_comps(14)= obj_fun ;                  // Total\n    R_report   <<obj_comps<<endl;\n    R_report   << endl;\n    R_report   << endl<<\"$Like_Comp_names\" <<endl;\n    R_report   <<\"catch_like     \"<<endl\n             <<\"age_like_fsh     \"<<endl\n             <<\"length_like_fsh     \"<<endl\n             <<\"sel_like_fsh     \"<<endl\n             <<\"ind_like        \"<<endl\n             <<\"age_like_ind     \"<<endl\n               <<\"length_like_ind  \"<<endl\n             <<\"sel_like_ind     \"<<endl\n             <<\"rec_like         \"<<endl\n             <<\"fpen             \"<<endl\n             <<\"post_priors_indq \"<<endl\n             <<\"post_priors      \"<<endl\n             <<\"residual         \"<<endl\n             <<\"total            \"<<endl;\n    for (k=1;k<=nfsh;k++)\n    {\n      R_report << \"$Sel_Fshry_\"<< (k) <<\"\"<<endl;\n      R_report << sel_like_fsh(k) << endl;\n    }\n    R_report   << endl;\n  \n    for (k=1;k<=nind;k++)\n    {\n      R_report << \"$Survey_Index_\"<< (k) <<\"\" <<endl;\n      R_report<< ind_like(k)<<endl;\n    }\n    R_report   << endl;\n\n    R_report << setw(10)<< setfixed() << setprecision(5) <<endl;\n    for (k=1;k<=nind;k++)\n    {\n      R_report << \"$Age_Survey_\"<< (k) <<\"\" <<endl;\n      R_report << age_like_ind(k)<<endl;\n    }\n    R_report   << endl;\n\n    for (k=1;k<=nind;k++)\n    {\n      R_report << \"$Sel_Survey_\"<< (k) <<\"\"<<endl;\n      R_report<< sel_like_ind(k,1) <<\" \"<<sel_like_ind(k,2)<<\" \"<<sel_like_ind(k,3)<< endl;\n    }\n    R_report   << endl;\n\n    R_report << setw(10)<< setfixed() << setprecision(5) <<endl;\n    R_report   << \"$Rec_Pen\" <<endl<<sigmar<<\"  \"<<rec_like<<endl;\n    R_report   << endl;\n    R_Report(m_sigmar);\n    R_Report(sigmar);\n\n    R_report   << \"$F_Pen\" <<endl;\n    R_report<<fpen(1)<<\"  \"<<fpen(2)<<endl;\n    R_report   << endl;\n    for (k=1;k<=nind;k++)\n    {\n      R_report << \"$Q_Survey_\"<< (k) <<\"\"<<endl\n             << \" \"<<post_priors_indq(k)\n             << \" \"<< q_ind(k,1)\n             << \" \"<< qprior(k)\n             << \" \"<< cvqprior(k)<<endl;\n      R_report << \"$Q_power_Survey_\"<< (k) <<\"\"<<endl\n             << \" \"<<post_priors_indq(k)\n             << \" \"<< q_power_ind(k)\n             << \" \"<< q_power_prior(k)\n             << \" \"<< cvq_power_prior(k)<<endl;\n    }\n             R_report   << endl;\n    R_report << \"$Mest\"<<endl;\n    R_report << \" \"<< post_priors(1)\n             << \" \"<< Mest\n             << \" \"<< natmortprior\n             << \" \"<< cvnatmortprior <<endl;\n    R_report   << endl;\n    R_report << \"$Steep\"<<endl;\n    R_report << \" \"<< post_priors(2)\n             << \" \"<< steepness\n             << \" \"<< steepnessprior\n             << \" \"<< cvsteepnessprior <<endl;\n    R_report   << endl;\n    R_report << \"$Sigmar\"<<endl;\n    R_report << \" \"<< post_priors(3)\n             << \" \"<< sigmar\n             << \" \"<< sigmarprior\n             << \" \"<< cvsigmarprior <<endl;\n    R_report   << endl;\n    R_report<<\"$Num_parameters_Est\"<<endl;\n    R_report<<initial_params::nvarcalc()<<endl;\n    R_report   << endl;\n    \n  R_report<<\"$Steep_Prior\" <<endl;\n  R_report<<steepnessprior<<\" \"<<\n    cvsteepnessprior<<\" \"<<\n    phase_srec<<\" \"<< endl;\n    R_report   << endl;\n\n  R_report<<\"$sigmarPrior \" <<endl;\n  R_report<<sigmarprior<<\" \"<<  cvsigmarprior <<\" \"<<phase_sigmar<<endl;\n  R_report   << endl;\n\n  R_report<<\"$Rec_estimated_in_styr_endyr \" <<endl;\n  R_report<<styr_rec    <<\" \"<<endyr        <<\" \"<<endl;\n  R_report   << endl;\n  R_report<<\"$SR_Curve_fit__in_styr_endyr \" <<endl;\n  R_report<<styr_rec_est<<\" \"<<endyr_rec_est<<\" \"<<endl;\n  R_report   << endl;\n  R_report<<\"$Model_styr_endyr\" <<endl;\n  R_report<<styr        <<\" \"<<endyr        <<\" \"<<endl;\n  R_report   << endl;\n\n  R_report<<\"$M_prior \"<<endl;\n  R_report<< natmortprior<< \" \"<< cvnatmortprior<<\" \"<<phase_M<<endl;\n  R_report   << endl;\n  R_report<<\"$qprior \" <<endl;\n  R_report<< qprior<<\" \"<<cvqprior<<\" \"<< phase_q<<endl;\n  R_report<<\"$q_power_prior \" <<endl;\n  R_report<< q_power_prior<<\" \"<<cvq_power_prior<<\" \"<< phase_q_power<<endl;\n  R_report   << endl;\n\n  R_report<<\"$cv_catchbiomass \" <<endl;\n  R_report<<cv_catchbiomass<<\" \"<<endl;\n  R_report   << endl;\n  R_report<<\"$Projection_years\"<<endl;\n  R_report<< nproj_yrs<<endl;\n  R_report   << endl;\n  \n  R_report << \"$Fsh_sel_opt_fish \"<<endl;\n  for (k=1;k<=nfsh;k++)\n    R_report<<k<<\" \"<<fsh_sel_opt(k)<<\" \"<<sel_change_in_fsh(k)<<endl;\n    R_report   << endl;\n   R_report<<\"$Survey_Sel_Opt_Survey \" <<endl;\n  for (k=1;k<=nind;k++)\n  R_report<<k<<\" \"<<(ind_sel_opt(k))<<endl;\n  R_report   << endl;\n    \n  R_report <<\"$Phase_survey_Sel_Coffs \"<<endl;\n  R_report <<phase_selcoff_ind<<endl;\n  R_report   << endl;\n  R_report <<\"$Fshry_Selages \" << endl;\n  R_report << nselages_in_fsh  <<endl;\n  R_report   << endl;\n  R_report <<\"$Survy_Selages \" <<endl;\n  R_report <<nselages_in_ind <<endl;\n  R_report   << endl;\n\n  R_report << \"$Phase_for_age_spec_fishery\"<<endl;\n  R_report <<phase_selcoff_fsh<<endl;\n  R_report   << endl;\n  R_report << \"$Phase_for_logistic_fishery\"<<endl;\n  R_report <<phase_logist_fsh<<endl;\n  R_report   << endl;\n  R_report << \"$Phase_for_dble_logistic_fishery \"<<endl;\n  R_report <<phase_dlogist_fsh<<endl;\n  R_report   << endl;\n\n  R_report << \"$Phase_for_age_spec_survey  \"<<endl;\n  R_report <<phase_selcoff_ind<<endl;\n  R_report   << endl;\n  R_report << \"$Phase_for_logistic_survey  \"<<endl;\n  R_report <<phase_logist_ind<<endl;\n  R_report   << endl;\n  R_report << \"$Phase_for_dble_logistic_indy \"<<endl;\n  R_report <<phase_dlogist_ind<<endl;\n  R_report   << endl;\n  \n  for (k=1;k<=nfsh;k++)\n  {\n    if (nyrs_fsh_age(k)>0)\n    {\n      R_report << \"$Francis_wt_fsh_age_\"<<k<<endl;\n      double fwtmp;\n      fwtmp = calc_Francis_weights(oac_fsh(k),eac_fsh(k),n_sample_fsh_age(k)) ;\n      R_report << fwtmp <<endl;\n      // cout << fwtmp <<endl;\n      R_report <<\"$EffN_Fsh_\"<<(k)<<\"\"<<endl;\n      for (i=1;i<=nyrs_fsh_age(k);i++)\n      {\n        double sda_tmp = Sd_age(oac_fsh(k,i));\n        R_report << yrs_fsh_age(k,i);\n        R_report << \" \"<<Eff_N(oac_fsh(k,i),eac_fsh(k,i)) ;\n        R_report << \" \"<<Eff_N2(oac_fsh(k,i),eac_fsh(k,i));\n        R_report << \" \"<<mn_age(oac_fsh(k,i));\n        R_report << \" \"<<mn_age(eac_fsh(k,i));\n        R_report << \" \"<<sda_tmp;\n        R_report << \" \"<<mn_age(oac_fsh(k,i)) - sda_tmp *2. / sqrt(n_sample_fsh_age(k,i));\n        R_report << \" \"<<mn_age(oac_fsh(k,i)) + sda_tmp *2. / sqrt(n_sample_fsh_age(k,i));\n        R_report <<endl;\n      }\n    }\n  }\n  \n  for (k=1;k<=nfsh;k++)\n  {\n    if (nyrs_fsh_length(k)>0)\n    {\n      R_report << \"$Francis_wt_fsh_len_\"<<k<<endl;\n      R_report << calc_Francis_weights(olc_fsh(k),elc_fsh(k),n_sample_fsh_length(k)) <<endl;\n      R_report <<\"$EffN_Length_Fsh_\"<<(k)<<\"\"<<endl;\n      for (i=1;i<=nyrs_fsh_length(k);i++)\n      {\n        double sda_tmp = Sd_length(olc_fsh(k,i));\n        R_report << yrs_fsh_length(k,i);\n        R_report << \" \"<<Eff_N(olc_fsh(k,i),elc_fsh(k,i)) ;\n        R_report << \" \"<<Eff_N2_L(olc_fsh(k,i),elc_fsh(k,i));\n        R_report << \" \"<<mn_length(olc_fsh(k,i));\n        R_report << \" \"<<mn_length(elc_fsh(k,i));\n        R_report << \" \"<<sda_tmp;\n        R_report << \" \"<<mn_length(olc_fsh(k,i)) - sda_tmp *2. / sqrt(n_sample_fsh_length(k,i));\n        R_report << \" \"<<mn_length(olc_fsh(k,i)) + sda_tmp *2. / sqrt(n_sample_fsh_length(k,i));\n        R_report <<endl;\n      }\n    }\n  }\n\n\n  for (k=1;k<=nfsh;k++)\n  {\n    R_report <<\"$C_fsh_\" <<(k)<<\"\" << endl; \n    for (i=styr;i<=endyr;i++)\n      R_report <<i<<\" \"<<catage(k,i)<< endl;\n  }\n\n  R_report <<\"$wt_a_pop\" << endl<< wt_pop  <<endl;\n  R_report <<\"$mature_a\" << endl<< maturity<<endl;\n  for (k=1;k<=nfsh;k++)\n  {\n    R_report <<\"$wt_fsh_\"<<(k)<<\"\"<<endl;\n    for (i=styr;i<=endyr;i++)\n      R_report <<i<<\" \"<<wt_fsh(k,i)<< endl;\n  }\n  \n  for (k=1;k<=nind;k++)\n  {\n    R_report <<\"$wt_ind_\"<<(k)<<\"\"<<endl;\n    for (i=styr;i<=endyr;i++)\n      R_report <<i<<\" \"<<wt_ind(k,i)<< endl;\n  }\n  for (k=1;k<=nind;k++)\n  {\n    if (nyrs_ind_age(k)>0)\n    {\n      R_report << \"$Francis_wt_ind_age_\"<<k<<endl;\n      R_report << calc_Francis_weights(oac_ind(k),eac_ind(k),n_sample_ind_age(k)) <<endl;\n      R_report <<\"$EffN_Survey_\"<<(k)<<\"\"<<endl;\n      for (i=1;i<=nyrs_ind_age(k);i++)\n      {\n        double sda_tmp = Sd_age(oac_ind(k,i));\n        R_report << yrs_ind_age(k,i)\n                 << \" \"<<Eff_N(oac_ind(k,i),eac_ind(k,i)) \n                 << \" \"<<Eff_N2(oac_ind(k,i),eac_ind(k,i))\n                 << \" \"<<mn_age(oac_ind(k,i))\n                 << \" \"<<mn_age(eac_ind(k,i))\n                 << \" \"<<sda_tmp\n                 << \" \"<<mn_age(oac_ind(k,i)) - sda_tmp *2. / sqrt(n_sample_ind_age(k,i))\n                 << \" \"<<mn_age(oac_ind(k,i)) + sda_tmp *2. / sqrt(n_sample_ind_age(k,i))\n                 <<endl;\n      }\n    }\n  }\n  for (k=1;k<=nind;k++)\n  {\n    if (nyrs_ind_length(k)>0)\n    {\n      R_report << \"$Francis_wt_ind_len_\"<<k<<endl;\n      R_report << calc_Francis_weights(olc_ind(k),elc_ind(k),n_sample_ind_length(k)) <<endl;\n      R_report <<\"$EffN_Length_Survey_\"<<(k)<<\"\"<<endl;\n      for (i=1;i<=nyrs_ind_length(k);i++)\n      {\n        double sda_tmp = Sd_age(olc_ind(k,i));\n        R_report << yrs_ind_length(k,i)\n                 << \" \"<<Eff_N(olc_ind(k,i),elc_ind(k,i)) \n                 << \" \"<<Eff_N2_L(olc_ind(k,i),elc_ind(k,i))\n                 << \" \"<<mn_length(olc_ind(k,i))\n                 << \" \"<<mn_length(elc_ind(k,i))\n                 << \" \"<<sda_tmp\n                 << \" \"<<mn_length(olc_ind(k,i)) - sda_tmp *2. / sqrt(n_sample_ind_length(k,i))\n                 << \" \"<<mn_length(olc_ind(k,i)) + sda_tmp *2. / sqrt(n_sample_ind_length(k,i))\n                 <<endl;\n      }\n    }\n  }\n  \n  R_report<<\"$msy_mt\"<<endl; \n  dvar_matrix sel_tmp(1,nages,1,nfsh);\n  dvariable sumF;\n  sel_tmp.initialize();\n  for (i=styr;i<=endyr;i++) \n  { \n    sumF=0.;\n    for (k=1;k<=nfsh;k++)\n    {\n      Fratio(k) = sum(F(k,i)) ;\n      sumF += Fratio(k) ;\n    }\n    Fratio /= sumF;\n    sumF /= nages;\n    for (k=1;k<=nfsh;k++)\n      for (j=1;j<=nages;j++)\n        sel_tmp(j,k) = sel_fsh(k,i,j); \n    get_msy(i);\n    // important for time-varying natural mortality...\n    dvariable spr_mt_ft = spr_ratio(sumF,sel_tmp,i)  ;\n    // Yr Fspr 1-Fspr F/Fmsy Fmsy F Fsprmsy MSY MSYL Bmsy Bzero B/Bmsy\n    R_report<< i<<\n            \" \"<< spr_mt_ft                   <<\n            \" \"<< (1.-spr_mt_ft)              << \n            \" \"<< Fcur_Fmsy                   <<\n            \" \"<< Fmsy                        <<\n            \" \"<< sumF                        <<\n            \" \"<< spr_ratio(Fmsy,sel_tmp,i)   <<\n            \" \"<< MSY                         <<\n            \" \"<< MSYL                        <<\n            \" \"<< Bmsy                        <<\n            \" \"<< Bzero                       <<\n            \" \"<< Sp_Biom(i)                  <<\n            \" \"<< Bcur_Bmsy                   <<\n            endl ;\n  }\n  R_report<<\"$age2len\"<<endl; \n  R_report<<P_age2len<<endl;\n  R_report<<\"$msy_m0\"<<endl; \n  sel_tmp.initialize();\n  // NOTE Danger here\n  dvar_matrix mtmp = M;\n  for (i=styr;i<=endyr;i++) \n  { \n    M(i) = M(styr);\n    sumF=0.;\n    for (k=1;k<=nfsh;k++)\n    {\n      Fratio(k) = sum(F(k,i)) ;\n      sumF += Fratio(k) ;\n    }\n    Fratio /= sumF;\n    for (k=1;k<=nfsh;k++)\n      for (j=1;j<=nages;j++)\n        sel_tmp(j,k) = sel_fsh(k,i,j); \n    get_msy(i);\n    sumF /= nages;\n    // important for time-varying natural mortality...\n    dvariable spr_mt_ft = spr_ratio(sumF,sel_tmp,i)  ;\n    dvariable spr_mt_f0 = spr_ratio(0.,sel_tmp,i)  ;\n    R_report<< i<<\n            \" \"<< spr_mt_ft                   <<\n            \" \"<< spr_mt_f0                   <<\n            \" \"<< (1.-spr_mt_f0)/(1-spr_mt_ft)<< \n            \" \"<< Fcur_Fmsy                   <<\n            \" \"<< Fmsy                        <<\n            \" \"<< sumF                        <<\n            \" \"<< spr_ratio(Fmsy,sel_tmp,i)   <<\n            \" \"<< MSY                         <<\n            \" \"<< Bmsy                        <<\n            \" \"<< MSYL                        <<\n            \" \"<< Bcur_Bmsy                   <<\n            endl ;\n  }\n\n  M = mtmp;\n  R_Report(F40_est);\n  R_Report(F35_est);      \n\n  R_report<<\"$sumBiom\"<<endl; \n  for (i=styr;i<=endyr+1;i++) \n  {\n    double lb=value(sumBiom(i)/exp(2.*sqrt(log(1+square(sumBiom.sd(i))/square(sumBiom(i))))));\n    double ub=value(sumBiom(i)*exp(2.*sqrt(log(1+square(sumBiom.sd(i))/square(sumBiom(i))))));\n    R_report<<i<<\" \"<<sumBiom(i)<<\" \"<<sumBiom.sd(i)<<\" \"<<lb<<\" \"<<ub<<endl;\n  }\n  R_Report(tau);      \n\n  R_report.close();\n\n\nFUNCTION double mn_age(const dvector& pobs)\n  // int lb1 = pobs.indexmin();\n  // int ub1 = pobs.indexmax();\n  // dvector av = age_vector(lb1,ub1)  ;\n  // double mobs = value(pobs.shift(rec_age)*age_vector);\n  double mobs = (pobs*age_vector);\n  return mobs;\n\nFUNCTION double mn_age(const dvar_vector& pobs)\n  // int lb1 = pobs.indexmin();\n  // int ub1 = pobs.indexmax();\n  // dvector av = age_vector(lb1,ub1)  ;\n  // double mobs = value(pobs.shift(rec_age)*age_vector);\n  double mobs = value(pobs*age_vector);\n  return mobs;\n\nFUNCTION double Sd_age(const dvector& pobs)\n  // double mobs = (pobs.shift(rec_age)*age_vector);\n  // double stmp = (sqrt(elem_prod(age_vector,age_vector)*pobs.shift(rec_age) - mobs*mobs));\n  double mobs = (pobs*age_vector);\n  double stmp = sqrt((elem_prod(age_vector,age_vector)*pobs) - mobs*mobs);\n  return stmp;\n\nFUNCTION double mn_length(const dvector& pobs)\n  double mobs = (pobs*len_bins);\n  return mobs;\n\nFUNCTION double mn_length(const dvar_vector& pobs)\n  double mobs = value(pobs*len_bins);\n  return mobs;\n\nFUNCTION double Sd_length(const dvector& pobs)\n  double mobs = (pobs*len_bins);\n  double stmp = sqrt((elem_prod(len_bins,len_bins)*pobs) - mobs*mobs);\n  return stmp;\n\nFUNCTION double Eff_N_adj(const double, const dvar_vector& pobs, const dvar_vector& phat)\n  int lb1 = pobs.indexmin();\n  int ub1 = pobs.indexmax();\n  dvector av = age_vector(lb1,ub1)  ;\n  double mobs = value(pobs*av);\n  double mhat = value(phat*av );\n  double rtmp = mobs-mhat;\n  double stmp = value(sqrt(elem_prod(av,av)*pobs - mobs*mobs));\n  return square(stmp)/square(rtmp);\n\nFUNCTION double Eff_N2(const dvector& pobs, const dvar_vector& phat)\n  int lb1 = pobs.indexmin();\n  int ub1 = pobs.indexmax();\n  dvector av = age_vector(lb1,ub1)  ;\n  double mobs =      (pobs*av);\n  double mhat = value(phat*av );\n  double rtmp = mobs-mhat;\n  double stmp = (sqrt(elem_prod(av,av)*pobs - mobs*mobs));\n  return square(stmp)/square(rtmp);\n\nFUNCTION double Eff_N(const dvector& pobs, const dvar_vector& phat)\n  dvar_vector rtmp = elem_div((pobs-phat),sqrt(elem_prod(phat,(1-phat))));\n  double vtmp;\n  vtmp = value(norm2(rtmp)/size_count(rtmp));\n  return 1./vtmp;\n\n /**\n   * @brief Calculate Francis weights\n   * @details this code based on equation TA1.8 in Francis(2011) should be changed so separate weights if by sex\n   *\n   * Produces the new weight that should be used.\n  **/\nFUNCTION double calc_Francis_weights(const dmatrix oac, const dvar_matrix eac, const ivector sam )\n  {\n    int nobs;\n    int i1=oac.rowmin();\n    int i2=oac.rowmax();\n    double lfwt,Var,Pre,Obs;\n    dvector ages(oac.colmin(),nages);\n    for (int i=oac.colmin();i<=nages;i++) \n      ages(i) = double(i)+.5;\n    nobs = oac.rowsize();\n    // cout <<nobs<<endl;\n    dvector resid(i1,i2);\n    resid.initialize();\n    for ( int i = i1; i <= i2; i++ )\n    {\n      // Obs = sum(elem_prod(oac(i), ages+.5));\n      Obs = oac(i) * (ages+.5);\n      // Pre = sum(elem_prod(value(eac(i)), ages+.5));\n      Pre = value(eac(i)) * (ages+.5);\n      Var = value(eac(i)) * square(ages+.5);\n      Var -= square(Pre);\n      resid(i) = (Obs - Pre) / sqrt(Var * 1.0 / (sam(i) ));\n      // cout<<Obs<<\" \"<<Pre<<\" \"<<Var<<\" \"<<resid(i)<<endl;\n    }\n    lfwt = 1.0 / (square(std_dev(resid)) * ((nobs - 1.0) / nobs * 1.0));\n    // lfwt(k) *= lf_lambda(k);\n    // cout <<\"FWt \"<<lfwt<<endl;\n    return lfwt;\n  }\n\nFUNCTION double Eff_N2_L(const dvector& pobs, const dvar_vector& phat)\n  dvector av = len_bins  ;\n  double mobs =      (pobs*av);\n  double mhat = value(phat*av );\n  double rtmp = mobs-mhat;\n  double stmp = (sqrt(elem_prod(av,av)*pobs - mobs*mobs));\n  return square(stmp)/square(rtmp);\n\nFUNCTION double get_AC(const int& indind)\n  // Functions to compute autocorrelation in residuals \n  int i1,i2,iyr;\n  i1 = 1;\n  i2 = nyrs_ind(indind);\n  double actmp;\n  dvector res(1,i2);\n  for (i=1;i<=i2;i++)\n  {\n    iyr = int(yrs_ind(indind,i));\n    cout<<iyr<<\" \"<<obs_ind(indind,i)<<\" \" <<pred_ind(indind,iyr)<<endl;\n    res(i) = log(obs_ind(indind,i)) - value(log(pred_ind(indind,iyr)));\n  }\n  double m1 = (mean(res(i1,i2-1)));\n  double m2 = (mean(res(i1+1,i2))); \n  actmp = mean( elem_prod( ++res(i1,i2-1) - m1, res(i1+1,i2) - m2)) /\n          (sqrt(mean( square(res(i1,i2-1) - m1 )))  * sqrt(mean(square(res(i1+1,i2) - m2 ))) );\n  return(actmp);\n\n \nGLOBALS_SECTION\n  // #include <logistic-normal.h>\n  #include <admodel.h>  \n\t#undef write_SIS_rep \n  /// Writes SIS report objects\n\t#define write_SIS_rep(object) SIS_rep << #object \"\\n\" << object << endl;\n\t#undef truth \n  /// Writes true model values (for OM testing)\n\t#define truth(object) trudat << #object \"\\n\" << object << endl;\n\t#undef REPORT \n  /// Martells report \n\t#define REPORT(object) REPORT << #object \"\\n\" << object << endl;\n\t#undef R_Report \n  /// for R report \n\t#define R_Report(object) R_report << \"$\"#object \"\\n\" << object << endl;\n\t/** Prints name and value of \\a object on ADMB report %ofstream file.  */\n\t#undef log_input\n\t#define log_input(object) write_input_log << \"# \" #object \"\\n\" << object << endl;\n\t#undef log_param\n  // #define log_param(object) for(int i=0;i<initial_params::num_initial_params;i++) {if(withinbound(0,(initial_params::varsptr[i])->phase_start, initial_params::current_phase)) { int sc= (initial_params::varsptr[i])->size_count(); if (sc>0) { write_input_log << \"# \" << initial_params::varsptr[i] ->label() << \"\\n\" << object<<endl; } }}\n  //\n\t#define log_param(object) if (active(object)) write_input_log << \"# \" #object \"\\n\" << object << endl;\n  ofstream write_input_log(\"input.log\");\n  ofstream SIS_rep(\"SIS_out.rep\");\n\n // void get_sel_changes(int& k);\n  adstring_array fshname;\n  adstring_array indname;\n  adstring truname;\n  adstring simname;\n  adstring model_name;\n  adstring projfile_name;\n  adstring datafile_name;\n  adstring cntrlfile_name;\n  adstring tmpstring;\n  adstring repstring;\n  adstring version_info;\n\n \nFUNCTION Write_SIS\n  /** Writes out SIS output format file */\n  SIS_rep << \" # constants ############################ \\n\"\n          << \" # species  \\n\"\n\t\n          << \" # region     (AI AK BOG BSAI EBS GOA)  \\n\" \n\t\n          << \" # assess_year  \\n\"\n  \n          << \" # split_sex (True or false) (1 or 0) (if true, FEMALE, Male, else combined)  \\n\"\n\t\n          << \" # number of fisheries  \\n \"\n\t\n          << \" # list of fisheries (ALL TWL LGL POT FIX FOR DOM ...) separated w/ %  \\n \"\n\t\n          << \" # mulitiplier for recruitment and N at age     (1,1000,1000000)  \\n\" \n\t\n          << \" # mulitiplier for biomass mt, catch mt, and surveybiomass mt    (1,1000,1000000)  \\n\"\n\t\n          << \" # recruitment age used by model  \\n\"\n\t\n          << \" # age+ used for biomass estimate  \\n\"\n\t\n          << \" # number of surveys  \\n \"\n  \n          << \" # list of surveys (longline, trawl, acoustic) separated w/ %  \\n\"\n\n          << \"#YEARS -list all years used in model (starting w/ first year of catch)  \\n\"\n\n          << \"#AGES -list ages used in model  \\n\"\n\n          << \"#RECRUITMENT -Number of recruits by model year (see multiplier above)  \\n\" \n\n          << \"#SPAWNBIOMASS -Spawning biomass by model year (see mt multiplier above)  \\n\"\n\n          << \"#TOTALBIOMASS -Total biomass by year (see mt multiplier above and age+ above)  \\n\"\n\n          << \"#TOTFSHRYMORT -Fishing mortality rate by year  \\n\"\n\n          << \"#TOTALCATCH -Total catch by year (see mt multiplier above)  \\n\"\n\n          << \"#FISHERYMORT -Fishing mortality rates by year (a line for each fishery) only if multiple fisheries  \\n\"\n\n          << \"#FISHERYCATCH -Catches by year (a line for each fishery) only if multiple fisheries  \\n\"\n\n          << \"#MATURITY -Maturity ratio by age  \\n\"\n\n          << \"#SPAWNWT -Average Spawning weight (in kg) by age  \\n\"\n\n          << \"#NATMORT -Natural mortality rate by age (a line for each sex)  \\n\"\n\n          << \"#N_AT_AGE -N at age by age (see number multiplier above)(a line for each sex)  \\n\"\n\n          << \"#FSHRY_WT_KG_SEX1 -Fishery weight at age (in kg)(a line for each fishery)  \\n\"\n\n          << \"#FSHRY_WT_KG_SEX2 -Fishery weight at age (in kg)(a line for each fishery)  \\n\"\n\n          << \"#SELECTIVITY_SEX1 -Fishery selectivity (a line for each fishery)  \\n\"\n\n          << \"#SELECTIVITY_SEX2 -Fishery selectivity (a line for each fishery)  \\n\"\n\n          << \"#SURVEYYEARS - list the survey years (a line for each survey)  \\n\"\n\n          << \"#SURVEYBIOMASS -Survey biomass by survey year (see mt multiplier above)(a line for each survey)  \\n\"\n\n          << endl;\n\nFUNCTION double sdnr(const dvar_vector& pred,const dvector& obs,double m)\n  RETURN_ARRAYS_INCREMENT();\n  double sdnr;\n  dvector pp = value(pred)+0.000001;\n  sdnr = std_dev(elem_div(obs+0.000001-pp,sqrt(elem_prod(pp,(1.-pp))/m)));\n  RETURN_ARRAYS_DECREMENT();\n  return sdnr;\n\n","f2":"//////////////////////////////////////////////////////////////////\n// AMAK--              \n// Naming Conventions:\n//\n//  GENERAL:\n//    styr, endyr begining year and ending year of model (catch data available)\n//    nages       number of age groups considered\n//    nyrs_        number of observations available to specific data set\n//\n//  DATA SPECIFIC:\n\n//    catch_bio   Observed catch biomass\n//    fsh        fishery data\n//\n//  Define indices\n//    nind        number of indices\n//  Index values\n//    nyrs_ind      Number of years of index value (annual)\n//    yrs_ind        Years of index value (annual)\n//    obs_ind        Observed index value (annual)\n//    obs_se_ind    Observed index standard errors (annual)\n//  Age-comp values\n//    nyrs_ind_age  Number of years index age data available\n//    yrs_ind_age   Years of index age value (annual)\n//    oac_ind       Observed age comp from index\n//    n_sample_ind_age    Observed age comp sample sizes from index\n//\n//    eac_ind       Expected age comp from index\n//\n//    sel_ind       selectivity for egg production index\n//\n//    pred_ind ...\n//\n//    oac_fsh      Observed age comp from index\n//    obs_ind_size  Observed size comp from index\n//\n//    pred_fsh_age    Predicted age comp from fishery data\n//    eac_fsh            Expected age comp for fishery data (only years where data available)\n//    eac_ ...\n//\n//    pred_tmp_ind   Predicted index value for trawl index\n//\n//    sel_fsh    selectivity for fishery                \n//  \n//     sel_ch indicates time-varying selectivity change\n//  \n//    Add bit for historical F\n//    Added length part for selectivity\n//\n//////////////////////////////////////////////////////////////////////////////\n // To ADD/FIX:\n //   parameterization of steepness to work the same (wrt prior) for ricker and bholt\n //   splines for selectivity\n //   two projection outputs need consolidation\n//////////////////////////////////////////////////////////////////////////////\n\nDATA_SECTION\n  !!version_info+=\"AMAK;Mar 2020\";\n  int iseed \n  !! iseed=1313;\n  int cmp_no // candidate management procedure\n  int nnodes_tmp;\n  !!CLASS ofstream mceval(\"mceval.dat\")\n  !!CLASS ofstream mceval_sr(\"mceval_sr.dat\")\n  !!CLASS ofstream mceval_R(\"mceval_R.dat\")\n  !!CLASS ofstream mceval_srv(\"mceval_srv.dat\")\n  !!CLASS ofstream mceval_M(\"mceval_M.dat\")\n  !!CLASS ofstream mceval_proj(\"mceval_proj.dat\")\n  !!long int lseed=iseed;\n  !!CLASS random_number_generator rng(iseed);\n  \n  int oper_mod\n  int mcmcmode\n  int mcflag\n\n  !! oper_mod = 0;\n  !! mcmcmode = 0;\n  !! mcflag   = 1;\n LOCAL_CALCS\n  write_input_log<<version_info<<endl;\n  tmpstring=adprogram_name + adstring(\".dat\");\n  int on=0;\n  if ( (on=option_match(argc,argv,\"-ind\"))>-1)\n  {\n    if (on>argc-2 | argv[on+1][0] == '-') \n    { \n      cerr << \"Invalid input data command line option\"\n         \" -- ignored\" << endl;  \n    }\n    else\n    {\n      cntrlfile_name = adstring(argv[on+1]);\n    }\n  }\n  else\n  {\n      cntrlfile_name =   tmpstring;\n  }\n  if ( (on=option_match(argc,argv,\"-om\"))>-1)\n  {\n    oper_mod  = 1;\n    cmp_no = atoi(argv[on+1]);\n    cout<<\"Got to operating model option \"<<oper_mod<<endl;\n  }\n  if ( (on=option_match(argc,argv,\"-mcmc\"))>-1)\n  {\n    mcmcmode = 1;\n  }\n  global_datafile= new cifstream(cntrlfile_name);\n  if (!global_datafile)\n  {\n  }\n  else\n  {\n    if (!(*global_datafile))\n    {\n      delete global_datafile;\n      global_datafile=NULL;\n    }\n  }\n END_CALCS\n // Read in \"name\" of this model...\n  !! *(ad_comm::global_datafile) >>  datafile_name; // First line is datafile (not used by this executable)\n  !! *(ad_comm::global_datafile) >>  model_name; \n  !! ad_comm::change_datafile_name(datafile_name);\n  init_int styr\n  init_int endyr\n  init_int rec_age\n  init_int oldest_age\n  !! log_input(styr);\n  !! log_input(endyr);\n  !! log_input(rec_age);\n  !! log_input(oldest_age);\n//------------LENGTH INTERVALS\n  init_int nlength\n  init_vector len_bins(1,nlength)\n  !! log_input(nlength);\n  !! log_input(len_bins);\n\n  int nages\n  !!  nages = oldest_age - rec_age + 1;\n  int styr_rec\n  int styr_sp\n  int endyr_sp\n  int nyrs\n  !! nyrs          = endyr - styr + 1;\n  int mc_count;\n  !!  mc_count=0;\n  !! styr_rec = (styr - nages) ;     // First year of recruitment\n  !! styr_sp  = styr_rec - rec_age - 1 ;    // First year of spawning biomass  \n  vector yy(styr,endyr);\n  !! yy.fill_seqadd(styr,1) ;\n  vector aa(1,nages);\n  !! aa.fill_seqadd(rec_age,1) ;\n  int junk;\n// Fishery specifics\n  init_int nfsh                                   //Number of fisheries\n  imatrix pfshname(1,nfsh,1,2)\n  init_adstring fshnameread;\n LOCAL_CALCS\n  for(k=1;k<=nfsh;k++) \n  {\n    pfshname(k,1)=1; \n    pfshname(k,2)=1;\n  }    // set whole array to equal 1 in case not enough names are read\n  adstring_array CRLF;   // blank to terminate lines\n  CRLF+=\"\";\n  k=1;\n  for(i=1;i<=strlen(fshnameread);i++)\n  if(adstring(fshnameread(i))==adstring(\"%\")) {\n    pfshname(k,2)=i-1; \n    k++;  \n    pfshname(k,1)=i+1;\n  }\n  pfshname(nfsh,2)=strlen(fshnameread);\n  for(k=1;k<=nfsh;k++)\n  {\n    fshname += fshnameread(pfshname(k,1),pfshname(k,2))+CRLF(1);\n  }\n  log_input(datafile_name);\n  log_input(model_name);\n  log_input(styr);\n  log_input(endyr);\n  log_input(rec_age);\n  log_input(oldest_age);\n  log_input(nfsh);\n  log_input(fshname);\n END_CALCS\n  init_matrix catch_bio_in(1,nfsh,styr,endyr)\n  init_matrix catch_bio_sd_in(1,nfsh,styr,endyr)   // Specify catch-estimation precision\n  // !! for (i=1;i<=nfsh;i++) catch_bio(i) += .01; \n  !! log_input(catch_bio_in);\n  !! log_input(catch_bio_sd_in);\n\n\n//  Define fishery age compositions\n  init_ivector nyrs_fsh_age(1,nfsh)\n  !! log_input(nyrs_fsh_age);\n  init_ivector nyrs_fsh_length(1,nfsh)\n  !! log_input(nyrs_fsh_length);\n  init_imatrix yrs_fsh_age_in(1,nfsh,1,nyrs_fsh_age)\n  !! log_input(yrs_fsh_age_in);\n  init_imatrix yrs_fsh_length_in(1,nfsh,1,nyrs_fsh_length)\n  !! log_input(yrs_fsh_length_in);\n  init_matrix n_sample_fsh_age_in(1,nfsh,1,nyrs_fsh_age)    //Years of index index value (annual)\n  init_matrix n_sample_fsh_length_in(1,nfsh,1,nyrs_fsh_length)    //Years of index index value (annual)\n  !! log_input(n_sample_fsh_length_in);\n  init_3darray oac_fsh_in(1,nfsh,1,nyrs_fsh_age,1,nages)\n  init_3darray olc_fsh_in(1,nfsh,1,nyrs_fsh_length,1,nlength)\n  !! log_input(olc_fsh_in);\n  init_3darray wt_fsh(1,nfsh,styr,endyr,1,nages)  //values of weights at age\n\n//  Define indices\n  init_int nind                                   //number of indices\n  !! log_input(nind);\n  int nfsh_and_ind\n  !! nfsh_and_ind = nfsh+nind;\n  imatrix pindname(1,nind,1,2)\n  init_adstring indnameread;\n LOCAL_CALCS\n  for(int k=1;k<=nind;k++) \n  {\n    pindname(k,1)=1; \n    pindname(k,2)=1;\n  }    // set whole array to equal 1 in case not enough names are read\n  int k=1;\n  for(i=1;i<=strlen(indnameread);i++)\n  if(adstring(indnameread(i))==adstring(\"%\")) {\n    pindname(k,2)=i-1; \n    k++;  \n    pindname(k,1)=i+1;\n  }\n  pindname(nind,2)=strlen(indnameread);\n  for(k=1;k<=nind;k++)\n  {\n    indname += indnameread(pindname(k,1),pindname(k,2))+CRLF(1);\n  }\n  log_input(indname);\n END_CALCS\n\n//  Index values\n  init_ivector nyrs_ind(1,nind)                   //Number of years of index value (annual)\n  init_imatrix yrs_ind_in(1,nind,1,nyrs_ind)         //Years of index value (annual)\n  init_vector mo_ind(1,nind)                      //Month occur \n  init_matrix obs_ind_in(1,nind,1,nyrs_ind)          //values of index value (annual)\n  init_matrix obs_se_ind_in(1,nind,1,nyrs_ind)       //values of indices serrs\n\n  vector ind_month_frac(1,nind)\n  !! log_input(nyrs_ind);\n  !! log_input(yrs_ind_in);\n  !! log_input(mo_ind);\n  !! ind_month_frac = (mo_ind-1.)/12.;\n  !! log_input(obs_ind_in);\n  !! log_input(obs_se_ind_in);\n  matrix        corr_dev(1,nind,1,nyrs_ind) //Index standard errors (for lognormal)\n  matrix        corr_eff(1,nfsh,styr,endyr) //Index standard errors (for lognormal)\n  matrix         act_eff(1,nfsh,styr,endyr) //Index standard errors (for lognormal)\n  vector              ac(1,nind);\n\n  init_ivector nyrs_ind_age(1,nind)               //Number of years of index value (annual)\n  !! log_input(nyrs_ind_age);\n\n  init_ivector nyrs_ind_length(1,nind)\n  !! log_input(nyrs_ind_length);\n\n  init_imatrix yrs_ind_age_in(1,nind,1,nyrs_ind_age)  //Years of index value (annual)\n  !! log_input(yrs_ind_age_in);\n\n  init_imatrix yrs_ind_length_in(1,nind,1,nyrs_ind_length)\n  !! log_input(yrs_ind_length_in);\n\n  init_matrix n_sample_ind_age_in(1,nind,1,nyrs_ind_age)         //Years of index value (annual)\n  !! log_input(yrs_ind_age_in);\n\n  init_matrix n_sample_ind_length_in(1,nind,1,nyrs_ind_length)         //Years of index lengths (annual)\n  !! log_input(n_sample_ind_length_in);\n\n  init_3darray oac_ind_in(1,nind,1,nyrs_ind_age,1,nages);  //values of Index proportions at age\n  init_3darray olc_ind_in(1,nind,1,nyrs_ind_length,1,nlength);\n  !! log_input(olc_ind_in);\n\n  !! log_input(oac_ind_in);\n  init_3darray  wt_ind(1,nind,styr,endyr,1,nages)      //values of Index proportions at age\n  !! log_input(wt_ind);\n\n  vector age_vector(1,nages);\n  !! for (j=1;j<=nages;j++)\n  !!  age_vector(j) = double(j+rec_age-1);\n  init_vector wt_pop(1,nages)\n  !! log_input(wt_pop);\n  init_vector maturity(1,nages)\n  !! log_input(maturity);\n  !! if (max(maturity)>.9) maturity /=2.;\n  vector wt_mature(1,nages);\n  !! wt_mature = elem_prod(wt_pop,maturity) ;\n\n  //Spawning month-----\n  init_number spawnmo\n  !! log_input(spawnmo);\n  number spmo_frac\n  !! spmo_frac = (spawnmo-1)/12.;\n\n  init_matrix age_err(1,nages,1,nages)\n  !! log_input(age_err);\n\n  int k // Index for fishery or index\n  int i // Index for year\n  int j // Index for age\n LOCAL_CALCS\n  // Rename data file to the control data section... \n  ad_comm::change_datafile_name(cntrlfile_name);\n  *(ad_comm::global_datafile) >>  datafile_name; \n  *(ad_comm::global_datafile) >>  model_name; \n  log_input(cntrlfile_name);\n END_CALCS\n  // Matrix of selectivity mappings--row 1 is type (1=fishery, 2=index) and row 2 is index within that type\n  //  e.g., the following for 2 fisheries and 4 indices means that index 3 uses fishery 1 selectivities,\n  //         the other fisheries and indices use their own parameterization\n  //  1 1 2 2 1 2 \n  //  1 2 1 2 1 4\n  init_imatrix sel_map(1,2,1,nfsh_and_ind) \n  // maps fisheries and indices into sequential sel_map for sharing purposes\n  !! write_input_log<< \"# Map shared selectivity: \"<< endl;log_input(sel_map);\n  !! log_input(datafile_name);\n  !! log_input(model_name);\n  !! projfile_name = cntrlfile_name(1,length(cntrlfile_name)-4) + \".prj\";\n\n  \n  init_int    SrType        // 2 Bholt, 1 Ricker\n  !! log_input(SrType);\n  init_int use_age_err      // nonzero value means use...\n  !! log_input(use_age_err);\n  init_int retro            // Retro years to peel off (0 means full dataset)\n  !! log_input(retro);\n  init_number steepnessprior\n  init_number cvsteepnessprior\n  init_int    phase_srec\n\n  init_number sigmarprior\n  number log_sigmarprior\n  init_number cvsigmarprior\n  init_int    phase_sigmar\n  !! log_input(sigmarprior);\n  !! log_input(cvsigmarprior);\n  !! log_input(phase_sigmar);\n  init_int    styr_rec_est\n  init_int    endyr_rec_est\n  !! log_input(styr_rec_est);\n  !! log_input(endyr_rec_est);\n  int nrecs_est;\n\n//-----GROWTH PARAMETERS--------------------------------------------------\n  init_number Linfprior\n  init_number cvLinfprior\n  init_int    phase_Linf\n  number log_Linfprior\n  !! log_Linfprior = log(Linfprior);\n  !! log_input(Linfprior)\n  !! log_input(cvLinfprior)\n\n  init_number kprior\n  init_number cvkprior\n  init_int    phase_k\n  number log_kprior\n  !! log_kprior = log(kprior);\n  !! log_input(kprior)\n  !! log_input(cvkprior)\n\n  init_number Loprior\n  init_number cvLoprior\n  init_int    phase_Lo\n  number log_Loprior\n  !! log_Loprior = log(Loprior);\n  !! log_input(Loprior)\n  !! log_input(cvLoprior)\n\n  init_number sdageprior\n  init_number cvsdageprior\n  init_int    phase_sdage\n  number log_sdageprior\n  !! log_sdageprior = log(sdageprior);\n  !! log_input(sdageprior)\n  !! log_input(cvsdageprior)\n\n//---------------------------------------------------------------------------\n  // Basic M\n  init_number natmortprior\n  init_number cvnatmortprior\n  init_int    phase_M\n  !! log_input(natmortprior);\n  !! log_input(cvnatmortprior);\n  !! log_input(phase_M);\n\n  // age-specific M\n  init_int     npars_Mage\n  init_ivector ages_M_changes(1,npars_Mage)\n  init_vector  Mage_in(1,npars_Mage)\n  init_int     phase_Mage\n  vector       Mage_offset_in(1,npars_Mage)\n  // convert inputs to offsets from prior for initialization purposes\n  !! if (npars_Mage>0) Mage_offset_in = log(Mage_in / natmortprior);\n  !! log_input(npars_Mage);\n  !! log_input(ages_M_changes);\n  !! log_input(Mage_in);\n  !! log_input(Mage_offset_in);\n  !! log_input(phase_Mage);\n\n  // time-varying M\n  init_int    phase_rw_M\n  init_int    npars_rw_M\n  init_ivector  yrs_rw_M(1,npars_rw_M);\n  init_vector sigma_rw_M(1,npars_rw_M)\n LOCAL_CALCS\n  log_input(phase_rw_M);\n  log_input(npars_rw_M);\n  log_input(yrs_rw_M);\n  log_input(sigma_rw_M);\n END_CALCS\n\n  init_vector qprior(1,nind)      \n  vector log_qprior(1,nind)      \n  init_vector cvqprior(1,nind)     \n  init_ivector phase_q(1,nind)\n  init_vector q_power_prior(1,nind)      \n  vector log_q_power_prior(1,nind)      \n  init_vector cvq_power_prior(1,nind)     \n  init_ivector phase_q_power(1,nind)\n  // Random walk definition for indices\n  init_ivector phase_rw_q(1,nind)\n  init_ivector npars_rw_q(1,nind)\n  init_imatrix  yrs_rw_q(1,nind,1,npars_rw_q); // Ragged array\n  init_matrix sigma_rw_q(1,nind,1,npars_rw_q); // Ragged array\n LOCAL_CALCS\n  log_input(qprior);\n  log_input(cvqprior);\n  log_input(phase_q);\n  log_input(q_power_prior);\n  log_input(cvq_power_prior);\n  log_input(phase_q_power);\n\n  log_input(phase_rw_q);\n  log_input(npars_rw_q);\n  log_input(yrs_rw_q);\n  log_input(sigma_rw_q);\n END_CALCS\n\n  init_ivector    q_age_min(1,nind)     // Age that q relates to...\n  init_ivector    q_age_max(1,nind)     // Age that q relates to...\n  !! log_input(q_age_min);\n  !! log_input(q_age_max);\n  // Need to map to age index range...\n  !! for (k=1;k<=nind;k++) {q_age_min(k) =  q_age_min(k) - rec_age + 1; q_age_max(k) = q_age_max(k) - rec_age + 1;}\n  !! log_input(q_age_min);\n  !! log_input(q_age_max);\n\n  init_number cv_catchbiomass\n  number catchbiomass_pen\n  !!catchbiomass_pen= 1./(2*cv_catchbiomass*cv_catchbiomass);\n  init_int nproj_yrs\n\n  int styr_fut\n  int endyr_fut            // LAst year for projections\n  int phase_Rzero\n  int phase_nosr\n  number Steepness_UB\n  !! phase_Rzero =  4;\n  !! phase_nosr  = -3;\n\n  // Selectivity controls\n  // read in options for each fishery\n  // Loop over fisheries and indices to read in data (conditional on sel_options)\n  ivector   fsh_sel_opt(1,nfsh)\n  ivector phase_sel_fsh(1,nfsh)\n  vector   curv_pen_fsh(1,nfsh)\n  matrix   sel_slp_in_fsh(1,nfsh,1,nyrs)\n  matrix   logsel_slp_in_fsh(1,nfsh,1,nyrs)\n  matrix   sel_inf_in_fsh(1,nfsh,1,nyrs)\n  vector   logsel_slp_in_fshv(1,nfsh)\n  vector   sel_inf_in_fshv(1,nfsh)\n\n  matrix   logsel_p1_in_fsh(1,nfsh,1,nyrs)\n  vector   logsel_p1_in_fshv(1,nfsh)\n  matrix   sel_p1_in_fsh(1,nfsh,1,nyrs)\n\n  matrix   sel_p2_in_fsh(1,nfsh,1,nyrs)\n  vector   sel_p2_in_fshv(1,nfsh)\n\n  matrix   logsel_p3_in_fsh(1,nfsh,1,nyrs)\n  vector   logsel_p3_in_fshv(1,nfsh)\n  matrix   sel_p3_in_fsh(1,nfsh,1,nyrs)\n\n  matrix   logsel_dslp_in_fsh(1,nfsh,1,nyrs)\n  matrix   sel_dinf_in_fsh(1,nfsh,1,nyrs)\n\n  vector seldec_pen_fsh(1,nfsh) ;\n  vector nnodes_fsh(1,nfsh) ;\n  int seldecage ;\n  !! seldecage = int(nages/2);\n  ivector nselages_in_fsh(1,nfsh)\n\n  ivector n_sel_ch_fsh(1,nfsh);\n  ivector n_sel_ch_ind(1,nind);\n  imatrix yrs_sel_ch_tmp(1,nind,1,endyr-styr+1);\n  imatrix yrs_sel_ch_tmp_ind(1,nind,1,endyr-styr+1);\n  !! yrs_sel_ch_tmp_ind.initialize();\n\n  ivector   ind_sel_opt(1,nind)\n  ivector phase_sel_ind(1,nind)\n  vector   curv_pen_ind(1,nind)\n  matrix   sel_slp_in_ind(1,nind,1,nyrs)\n  matrix   logsel_slp_in_ind(1,nind,1,nyrs)\n  matrix   sel_inf_in_ind(1,nind,1,nyrs)\n  vector   logsel_slp_in_indv(1,nind)\n  vector   sel_inf_in_indv(1,nind)\n  \n  matrix   logsel_p1_in_ind(1,nind,1,nyrs)\n  vector   logsel_p1_in_indv(1,nind)\n  matrix   sel_p1_in_ind(1,nind,1,nyrs)\n\n  matrix   sel_p2_in_ind(1,nind,1,nyrs)\n  vector   sel_p2_in_indv(1,nind)\n\n  matrix   logsel_p3_in_ind(1,nind,1,nyrs)\n  vector   logsel_p3_in_indv(1,nind)\n  matrix   sel_p3_in_ind(1,nind,1,nyrs)\n  \n  matrix   logsel_dslp_in_ind(1,nind,1,nyrs)\n  matrix   sel_dinf_in_ind(1,nind,1,nyrs)\n\n  //matrix   sel_dslp_in_ind(1,nind,1,nyrs)\n  //vector   logsel_dslp_in_indv(1,nind)\n  //vector   sel_dinf_in_indv(1,nind)\n\n  vector seldec_pen_ind(1,nind) ;\n  matrix sel_change_in_ind(1,nind,styr,endyr);\n  ivector nselages_in_ind(1,nind)\n  matrix sel_change_in_fsh(1,nfsh,styr,endyr);\n  imatrix yrs_sel_ch_fsh(1,nfsh,1,endyr-styr);\n  matrix sel_sigma_fsh(1,nfsh,1,endyr-styr);\n  imatrix yrs_sel_ch_ind(1,nind,1,endyr-styr);\n  matrix sel_sigma_ind(1,nind,1,endyr-styr);\n  !! yrs_sel_ch_fsh.initialize();\n  !! yrs_sel_ch_ind.initialize();\n  !! sel_sigma_fsh.initialize();\n  !! sel_sigma_ind.initialize();\n\n  // Phase of estimation\n  ivector phase_selcoff_fsh(1,nfsh)\n  ivector phase_logist_fsh(1,nfsh)\n  ivector phase_dlogist_fsh(1,nfsh)\n  ivector phase_sel_spl_fsh(1,nfsh)\n\n  ivector phase_selcoff_ind(1,nind)\n  ivector phase_logist_ind(1,nind)\n  ivector phase_dlogist_ind(1,nind)\n  vector  sel_fsh_tmp(1,nages); \n  vector  sel_ind_tmp(1,nages); \n  3darray log_selcoffs_fsh_in(1,nfsh,1,nyrs,1,nages)\n  3darray log_selcoffs_ind_in(1,nind,1,nyrs,1,nages)\n  3darray  log_sel_spl_fsh_in(1,nfsh,1,nyrs,1,nages) // use nages for input to start\n  // 3darray log_selcoffs_ind_in(1,nind,1,nyrs,1,nages)\n\n LOCAL_CALCS\n  logsel_slp_in_fshv.initialize();\n  sel_inf_in_fshv.initialize();\n  logsel_p1_in_fshv.initialize();\n  sel_p2_in_fshv.initialize();\n  logsel_p3_in_fshv.initialize();\n\n  logsel_slp_in_indv.initialize();\n  sel_inf_in_indv.initialize();\n  logsel_p1_in_indv.initialize();\n  sel_p2_in_indv.initialize();\n  logsel_p3_in_indv.initialize();\n  \n  //logsel_dslp_in_indv.initialize();\n  //sel_inf_in_indv.initialize();\n  //sel_dinf_in_indv.initialize();\n\n  phase_selcoff_ind.initialize();\n  phase_logist_ind.initialize();\n  phase_dlogist_ind.initialize();\n  sel_fsh_tmp.initialize() ;\n  sel_ind_tmp.initialize() ;\n  log_selcoffs_fsh_in.initialize();\n  log_selcoffs_ind_in.initialize();\n\n  // nselages_in_fsh.initialize()   ;  \n  // nselages_in_ind.initialize()   ;  \n  nselages_in_fsh = nages-1;\n  nselages_in_ind = nages-1;\n  sel_change_in_fsh.initialize()   ; \n  sel_change_in_ind.initialize()   ;  \n  sel_slp_in_fsh.initialize()   ;  // ji\n  sel_slp_in_ind.initialize()   ;  // ji\n  sel_inf_in_fsh.initialize()   ;  // ji\n  sel_inf_in_ind.initialize()   ;  // ji\n  logsel_slp_in_fsh.initialize();  // ji\n  logsel_slp_in_fshv.initialize(); // ji\n  logsel_dslp_in_fsh.initialize(); // ji\n  logsel_slp_in_ind.initialize();  // ji\n  logsel_slp_in_indv.initialize(); // ji\n  logsel_dslp_in_ind.initialize(); // ji\n   \n  for (k=1;k<=nfsh;k++)\n  {\n    *(ad_comm::global_datafile) >> fsh_sel_opt(k)  ;  \n    log_input(fsh_sel_opt(k));\n    switch (fsh_sel_opt(k))\n    {\n      case 1 : // Selectivity coefficients \n      {\n        *(ad_comm::global_datafile) >> nselages_in_fsh(k)   ;  \n        *(ad_comm::global_datafile) >> phase_sel_fsh(k);  \n        *(ad_comm::global_datafile) >> curv_pen_fsh(k) ;\n        *(ad_comm::global_datafile) >> seldec_pen_fsh(k) ;\n        seldec_pen_fsh(k) *= seldec_pen_fsh(k) ;\n        *(ad_comm::global_datafile) >>  n_sel_ch_fsh(k) ;  \n        n_sel_ch_fsh(k) +=1;\n        yrs_sel_ch_fsh(k,1) = styr; // first year always estimated\n        for (int i=2;i<=n_sel_ch_fsh(k);i++)\n          *(ad_comm::global_datafile) >>  yrs_sel_ch_fsh(k,i) ;  \n        for (int i=2;i<=n_sel_ch_fsh(k);i++)\n          *(ad_comm::global_datafile) >>  sel_sigma_fsh(k,i) ;  \n        log_input(nselages_in_fsh(k)) ;  \n        log_input(phase_sel_fsh(k)) ;  \n        log_input(curv_pen_fsh(k)) ;  \n        log_input(seldec_pen_fsh(k)) ;  \n        log_input(n_sel_ch_fsh(k)) ;  \n        log_input(yrs_sel_ch_fsh(k)) ;  \n        log_input(sel_sigma_fsh(k)) ;  \n        // for (int i=styr;i<=endyr;i++) *(ad_comm::global_datafile) >> sel_change_in_fsh(k,i) ;\n        sel_change_in_fsh(k,styr)=1.; \n       // Number of selectivity changes is equal to the number of vectors (yr 1 is baseline)\n        // This to read in pre-specified selectivity values...\n        sel_fsh_tmp.initialize();\n        log_selcoffs_fsh_in.initialize();\n        for (int j=1;j<=nages;j++) \n          *(ad_comm::global_datafile) >> sel_fsh_tmp(j);  \n        for (int jj=2;jj<=n_sel_ch_fsh(k);jj++) \n        {\n          // Set the selectivity for the oldest group\n          for (int j=nselages_in_fsh(k)+1;j<=nages;j++) \n          {\n            sel_fsh_tmp(j)  = sel_fsh_tmp(nselages_in_fsh(k));  \n          }\n          // Set tmp to actual initial vectors...\n          log_selcoffs_fsh_in(k,jj)(1,nselages_in_fsh(k)) = log((sel_fsh_tmp(1,nselages_in_fsh(k))+1e-7)/mean(sel_fsh_tmp(1,nselages_in_fsh(k))+1e-7) );\n          write_input_log<<\"Sel_in_fsh \"<< mfexp(log_selcoffs_fsh_in(k,jj))<<endl;\n        }\n        // exit(1);\n        phase_selcoff_fsh(k) = phase_sel_fsh(k);\n        phase_logist_fsh(k)  = -1;\n        phase_dlogist_fsh(k) = -1;\n        phase_sel_spl_fsh(k) = -1;\n      }\n        break;\n      case 2 : // Single logistic\n      {\n        *(ad_comm::global_datafile) >> phase_sel_fsh(k);  \n        *(ad_comm::global_datafile) >>  n_sel_ch_fsh(k) ;  \n        n_sel_ch_fsh(k) +=1;\n        yrs_sel_ch_fsh(k,1) = styr;\n        for (int i=2;i<=n_sel_ch_fsh(k);i++)\n          *(ad_comm::global_datafile) >>  yrs_sel_ch_fsh(k,i) ;  \n        for (int i=2;i<=n_sel_ch_fsh(k);i++)\n          *(ad_comm::global_datafile) >>  sel_sigma_fsh(k,i) ;  \n        // This to read in pre-specified selectivity values...\n        *(ad_comm::global_datafile) >> sel_slp_in_fsh(k,1) ;\n        *(ad_comm::global_datafile) >> sel_inf_in_fsh(k,1) ;\n        logsel_slp_in_fsh(k,1)   = log(sel_slp_in_fsh(k,1)) ;\n        for (int jj=2;jj<=n_sel_ch_fsh(k);jj++) \n        {\n          sel_inf_in_fsh(k,jj)    =     sel_inf_in_fsh(k,1) ;\n          logsel_slp_in_fsh(k,jj) = log(sel_slp_in_fsh(k,1)) ;\n        }\n        log_input(phase_sel_fsh(k));\n        log_input(n_sel_ch_fsh(k));\n        log_input(sel_slp_in_fsh(k)(1,n_sel_ch_fsh(k)));\n        log_input(sel_inf_in_fsh(k)(1,n_sel_ch_fsh(k)));\n        log_input(logsel_slp_in_fsh(k)(1,n_sel_ch_fsh(k)));\n        log_input(yrs_sel_ch_fsh(k)(1,n_sel_ch_fsh(k)));\n\n        phase_selcoff_fsh(k) = -1;\n        phase_logist_fsh(k) = phase_sel_fsh(k);\n        phase_dlogist_fsh(k) = -1;\n        phase_sel_spl_fsh(k) = -1;\n\n        logsel_slp_in_fshv(k) = logsel_slp_in_fsh(k,1);\n           sel_inf_in_fshv(k) =    sel_inf_in_fsh(k,1);\n        break;\n      }\n      case 3 : // Double logistic \n      {\n        *(ad_comm::global_datafile) >> nselages_in_fsh(k)   ;  \n        *(ad_comm::global_datafile) >> phase_sel_fsh(k);  \n        *(ad_comm::global_datafile) >>  n_sel_ch_fsh(k) ;  \n        n_sel_ch_fsh(k) +=1;\n        yrs_sel_ch_fsh(k,1) = styr;\n        for (int i=2;i<=n_sel_ch_fsh(k);i++)\n          *(ad_comm::global_datafile) >>  yrs_sel_ch_fsh(k,i) ;  \n        for (int i=2;i<=n_sel_ch_fsh(k);i++)\n          *(ad_comm::global_datafile) >>  sel_sigma_fsh(k,i) ;  \n        // This to read in pre-specified selectivity values...\n        *(ad_comm::global_datafile) >> sel_p1_in_fsh(k,1) ; // asc inflection\n        *(ad_comm::global_datafile) >> sel_p2_in_fsh(k,1) ; // ages to 95% selected (added to p1\n        *(ad_comm::global_datafile) >> sel_p3_in_fsh(k,1) ; // ages to desc infl\n\n        // Put initial param scale here logsel_slp_in_fsh(k,1)   = log(sel_slp_in_fsh(k,1)) ;\n        for (int jj=2;jj<=n_sel_ch_fsh(k);jj++) \n        {\n          sel_p1_in_fsh(k,jj)    =     sel_p1_in_fsh(k,1) ;\n          sel_p2_in_fsh(k,jj)    =     sel_p2_in_fsh(k,1) ;\n          sel_p3_in_fsh(k,jj)    =     sel_p3_in_fsh(k,1) ;\n        }\n        logsel_p1_in_fsh(k) =  log(sel_p1_in_fsh(k)) ;\n        logsel_p3_in_fsh(k) =  log(sel_p3_in_fsh(k)) ;\n\n        log_input(phase_sel_fsh(k));\n        log_input(n_sel_ch_fsh(k));\n        log_input(sel_p1_in_fsh(k)(1,n_sel_ch_fsh(k)));\n        log_input(sel_p2_in_fsh(k)(1,n_sel_ch_fsh(k)));\n        log_input(sel_p3_in_fsh(k)(1,n_sel_ch_fsh(k)));\n        log_input(yrs_sel_ch_fsh(k)(1,n_sel_ch_fsh(k)));\n\n        phase_selcoff_fsh(k) = -1;\n        phase_logist_fsh(k)  = -1;\n        phase_dlogist_fsh(k) = phase_sel_fsh(k);\n        phase_sel_spl_fsh(k) = -1;\n\n        logsel_p1_in_fshv(k) = logsel_p1_in_fsh(k,1);\n           sel_p2_in_fshv(k) =    sel_p2_in_fsh(k,1);\n        logsel_p3_in_fshv(k) = logsel_p3_in_fsh(k,1);\n\n        logsel_slp_in_fshv(k) = logsel_slp_in_fsh(k,1);\n           sel_inf_in_fshv(k) =    sel_inf_in_fsh(k,1);\n        write_input_log << \"Double logistic read in...\"<<endl;\n        break;\n      }\n      case 4 : // Splines         \n      {\n      }\n      break;\n      write_input_log << fshname(k)<<\" fish sel opt \"<<endl<<fsh_sel_opt(k)<<\" \"<<endl<<\"Sel_change\"<<endl<<sel_change_in_fsh(k)<<endl;\n    }\n  }\n  // Indices here..............\n  yrs_sel_ch_ind.initialize() ;  \n  sel_sigma_ind.initialize();\n  for(k=1;k<=nind;k++)\n  {\n    *(ad_comm::global_datafile) >> ind_sel_opt(k)  ;  \n    write_input_log << endl<<\"Survey \"<<indname(k)<<endl;\n    log_input(ind_sel_opt(k));\n    switch (ind_sel_opt(k))\n    {\n      case 1 : // Selectivity coefficients  indices\n      {\n        *(ad_comm::global_datafile) >> nselages_in_ind(k)   ;  \n        *(ad_comm::global_datafile) >> phase_sel_ind(k);  \n        *(ad_comm::global_datafile) >> curv_pen_ind(k) ;\n        *(ad_comm::global_datafile) >> seldec_pen_ind(k) ;\n        seldec_pen_ind(k) *= seldec_pen_ind(k);\n        *(ad_comm::global_datafile) >>  n_sel_ch_ind(k) ;  \n        n_sel_ch_ind(k)+=1;\n        yrs_sel_ch_ind(k,1) = styr;\n        yrs_sel_ch_tmp_ind(k,1) = styr;\n        for (int i=2;i<=n_sel_ch_ind(k);i++)\n          *(ad_comm::global_datafile) >>  yrs_sel_ch_ind(k,i) ;  \n        for (int i=2;i<=n_sel_ch_ind(k);i++)\n          *(ad_comm::global_datafile) >>  sel_sigma_ind(k,i) ;  \n        sel_change_in_ind(k,styr)=1.; \n       // Number of selectivity changes is equal to the number of vectors (yr 1 is baseline)\n        log_input(indname(k));\n        log_input(nselages_in_ind(k));\n        log_input(phase_sel_ind(k));\n        log_input(seldec_pen_ind(k));\n        log_input(n_sel_ch_ind(k));\n        log_input(sel_change_in_ind(k));\n        log_input(n_sel_ch_ind(k));\n        // log_input(yrs_sel_ch_ind(k)(1,n_sel_ch_ind(k)));\n        log_input(yrs_sel_ch_ind(k));\n        // This to read in pre-specified selectivity values...\n        for (j=1;j<=nages;j++) \n          *(ad_comm::global_datafile) >> sel_ind_tmp(j);  \n        log_input(sel_ind_tmp);\n        log_selcoffs_ind_in(k,1)(1,nselages_in_ind(k)) = log((sel_ind_tmp(1,nselages_in_ind(k))+1e-7)/mean(sel_fsh_tmp(1,nselages_in_ind(k))+1e-7) );\n        // set all change selectivity to initial values\n        for (int jj=2;jj<=n_sel_ch_ind(k);jj++) \n        {\n          for (int j=nselages_in_ind(k)+1;j<=nages;j++) // This might be going out of nages=nselages\n          {\n            sel_ind_tmp(j)  = sel_ind_tmp(nselages_in_ind(k));  \n          }\n          // Set tmp to actual initial vectors...\n          log_selcoffs_ind_in(k,jj)(1,nselages_in_ind(k)) = log((sel_ind_tmp(1,nselages_in_ind(k))+1e-7)/mean(sel_fsh_tmp(1,nselages_in_ind(k))+1e-7) );\n          write_input_log<<\"Sel_in_ind \"<< mfexp(log_selcoffs_ind_in(k,jj))<<endl;\n        }\n        phase_selcoff_ind(k) = phase_sel_ind(k);\n        phase_logist_ind(k)  = -2;\n        phase_dlogist_ind(k) = -1;\n      }\n      break;\n      case 2 : // Single logistic\n      {\n        *(ad_comm::global_datafile) >> phase_sel_ind(k);  \n        *(ad_comm::global_datafile) >>  n_sel_ch_ind(k) ;  \n        n_sel_ch_ind(k) +=1;\n        yrs_sel_ch_ind(k,1) = styr; // first year always estimated\n        yrs_sel_ch_tmp_ind(k,1) = styr;\n        for (int i=2;i<=n_sel_ch_ind(k);i++)\n          *(ad_comm::global_datafile) >>  yrs_sel_ch_ind(k,i) ;  \n        for (int i=2;i<=n_sel_ch_ind(k);i++)\n          *(ad_comm::global_datafile) >>  sel_sigma_ind(k,i) ;  \n        sel_change_in_ind(k,styr)=1.; \n\n        log_input(indname(k));\n        log_input(nselages_in_ind(k));\n        log_input(phase_sel_ind(k));\n        log_input(sel_change_in_ind(k));\n        log_input(n_sel_ch_ind(k));\n        log_input(yrs_sel_ch_ind(k)(1,n_sel_ch_ind(k)));\n        // This to read in pre-specified selectivity values...\n       // Number of selectivity changes is equal to the number of vectors (yr 1 is baseline)\n        for (int i=styr+1;i<=endyr;i++) { if(sel_change_in_ind(k,i)>0) { j++; yrs_sel_ch_tmp_ind(k,j) = i; } }\n        // This to read in pre-specified selectivity values...\n        *(ad_comm::global_datafile) >> sel_slp_in_ind(k,1) ;\n        *(ad_comm::global_datafile) >> sel_inf_in_ind(k,1) ;\n        logsel_slp_in_ind(k,1) =   log(sel_slp_in_ind(k,1)) ;\n        for (int jj=2;jj<=n_sel_ch_ind(k);jj++) \n        {\n          sel_inf_in_ind(k,jj)    =     sel_inf_in_ind(k,1) ;\n          logsel_slp_in_ind(k,jj) = log(sel_slp_in_ind(k,1)) ;\n        }\n        log_input(sel_slp_in_ind(k,1));\n        log_input(sel_inf_in_ind(k,1));\n        log_input(logsel_slp_in_ind(k,1));\n\n        phase_selcoff_ind(k) = -1;\n        phase_logist_ind(k) = phase_sel_ind(k);\n        phase_dlogist_ind(k)  = -1;\n\n        logsel_slp_in_indv(k) = logsel_slp_in_ind(k,1);\n           sel_inf_in_indv(k) =    sel_inf_in_ind(k,1);\n        log_input(logsel_slp_in_indv(k));\n      }\n      break;\n      case 3 : // Double logistic \n      {\n        *(ad_comm::global_datafile) >> nselages_in_ind(k); \n        *(ad_comm::global_datafile) >> phase_sel_ind(k);  \n        *(ad_comm::global_datafile) >>  n_sel_ch_ind(k) ;  \n        n_sel_ch_ind(k) +=1;\n        yrs_sel_ch_ind(k,1) = styr; // first year always estimated\n        yrs_sel_ch_tmp_ind(k,1) = styr;\n        for (int i=2;i<=n_sel_ch_ind(k);i++)\n          *(ad_comm::global_datafile) >>  yrs_sel_ch_ind(k,i) ;  \n        for (int i=2;i<=n_sel_ch_ind(k);i++)\n          *(ad_comm::global_datafile) >>  sel_sigma_ind(k,i) ;  \n        sel_change_in_ind(k,styr)=1.; \n        // This to read in pre-specified selectivity values...\n       // Number of selectivity changes is equal to the number of vectors (yr 1 is baseline)\n        for (int i=styr+1;i<=endyr;i++) { if(sel_change_in_ind(k,i)>0) { j++; yrs_sel_ch_tmp_ind(k,j) = i; } }\n        *(ad_comm::global_datafile) >> sel_p1_in_ind(k,1) ; // asc inflection\n        *(ad_comm::global_datafile) >> sel_p2_in_ind(k,1) ; // ages to 95% selected (added to p1\n        *(ad_comm::global_datafile) >> sel_p3_in_ind(k,1) ; // ages to desc infl\n        \n        for (int jj=2;jj<=n_sel_ch_ind(k);jj++) \n        {\n          sel_p1_in_ind(k,jj)    =     sel_p1_in_ind(k,1) ;\n          sel_p2_in_ind(k,jj)    =     sel_p2_in_ind(k,1) ;\n          sel_p3_in_ind(k,jj)    =     sel_p3_in_ind(k,1) ;\n        }\n        logsel_p1_in_ind(k) =  log(sel_p1_in_ind(k)) ;\n        logsel_p3_in_ind(k) =  log(sel_p3_in_ind(k)) ;\n\n        log_input(indname(k));\n        log_input(nselages_in_ind(k));\n        log_input(phase_sel_ind(k));\n        log_input(sel_change_in_ind(k));\n        log_input(n_sel_ch_ind(k));\n        log_input(sel_p1_in_ind(k)(1,n_sel_ch_ind(k)));\n        log_input(sel_p2_in_ind(k)(1,n_sel_ch_ind(k)));\n        log_input(sel_p3_in_ind(k)(1,n_sel_ch_ind(k)));\n        log_input(yrs_sel_ch_ind(k)(1,n_sel_ch_ind(k)));\n        \n        // This to read in pre-specified selectivity values...\n        //*(ad_comm::global_datafile) >> sel_slp_in_ind(k,1) ;\n        //*(ad_comm::global_datafile) >> sel_inf_in_ind(k,1) ;\n        //logsel_slp_in_ind(k,1) =   log(sel_slp_in_ind(k,1)) ;\n        //for (int jj=2;jj<=n_sel_ch_ind(k);jj++) \n        //{\n        //  sel_inf_in_ind(k,jj)    =     sel_inf_in_ind(k,1) ;\n        //  logsel_slp_in_ind(k,jj) = log(sel_slp_in_ind(k,1)) ;\n        //}\n        //log_input(sel_slp_in_ind(k,1));\n        //log_input(sel_inf_in_ind(k,1));\n        //log_input(logsel_slp_in_ind(k,1));\n\n        phase_selcoff_ind(k) = -1;\n        phase_logist_ind(k) = -1;\n        phase_dlogist_ind(k)  = phase_sel_ind(k);\n        \n        logsel_p1_in_indv(k) = logsel_p1_in_ind(k,1);\n        sel_p2_in_indv(k) =    sel_p2_in_ind(k,1);\n        logsel_p3_in_indv(k) = logsel_p3_in_ind(k,1);\n\n        logsel_slp_in_indv(k) = logsel_slp_in_ind(k,1);\n        sel_inf_in_indv(k) =    sel_inf_in_ind(k,1);\n        //log_input(logsel_slp_in_indv(k));\n        write_input_log << \"Double logistic read in...\"<<endl;\n      }\n        break;\n      case 4 : // spline for indices\n      {\n      }\n      break;\n    }\n    write_input_log << indname(k)<<\" ind sel opt \"<<ind_sel_opt(k)<<\" \"<<sel_change_in_ind(k)<<endl;\n  }\n  write_input_log<<\"Phase indices Sel_Coffs: \"<<phase_selcoff_ind<<endl; \n END_CALCS\n  init_number test;\n  !! write_input_log<<\" Test: \"<<test<<endl;\n !! if (test!=123456789) {cerr<<\"Control file not read in correctly... \"<<endl;exit(1);}\n\n\n  ivector nopt_fsh(1,2) // number of options...\n  !! nopt_fsh.initialize();\n  !! for (k=1;k<=nfsh;k++) if(fsh_sel_opt(k)==1) nopt_fsh(1)++;else nopt_fsh(2)++;\n\n  // Fishery selectivity description:\n  // type 1\n  \n  // Number of ages\n\n  !! write_input_log << \"# Fshry Selages: \" << nselages_in_fsh  <<endl;\n  !! write_input_log << \"# Srvy  Selages: \" << nselages_in_ind <<endl;\n\n  !! write_input_log << \"# Phase for age-spec fishery \"<<phase_selcoff_fsh<<endl;\n  !! write_input_log << \"# Phase for logistic fishery \"<<phase_logist_fsh<<endl;\n  !! write_input_log << \"# Phase for dble logistic fishery \"<<phase_dlogist_fsh<<endl;\n\n  !! write_input_log << \"# Phase for age-spec indices  \"<<phase_selcoff_ind<<endl;\n  !! write_input_log << \"# Phase for logistic indices  \"<<phase_logist_ind<<endl;\n  !! write_input_log << \"# Phase for dble logistic ind \"<<phase_dlogist_ind<<endl;\n\n  !! for (k=1;k<=nfsh;k++) if (phase_selcoff_fsh(k)>0) curv_pen_fsh(k) = 1./ (square(curv_pen_fsh(k))*2.);\n  !! write_input_log<<\"# Curv_pen_fsh: \"<<endl<<curv_pen_fsh<<endl;\n  !! for (k=1;k<=nind;k++) if (phase_selcoff_ind(k)>0) curv_pen_ind(k) = 1./ (square(curv_pen_ind(k))*2.);\n  !! write_input_log<<\"# Curv_pen_ind: \"<<endl<<curv_pen_ind<<endl;\n\n  int  phase_fmort;\n  int  phase_proj;\n  ivector   nselages_fsh(1,nfsh);\n  matrix xnodes_fsh(1,nfsh,1,nnodes_fsh)\n  matrix xages_fsh(1,nfsh,1,nages)\n\n  ivector   nselages_ind(1,nind);\n  //Resetting data here for retrospectives////////////////////////////////////////////\n LOCAL_CALCS\n  for (int k=1;k<=nfsh;k++) \n  {\n    if ((endyr-retro)<=yrs_sel_ch_fsh(k,n_sel_ch_fsh(k))) \n\t\t{\n\t\t\tint itmp=1;\n\t\t\twhile ((endyr-retro) > yrs_sel_ch_fsh(k,itmp))\n\t\t\t{\n\t\t\t  n_sel_ch_fsh(k) = itmp ;  \n      cout<<\"yrs_ch \"<<yrs_sel_ch_fsh(k)(1,n_sel_ch_fsh(k))<<endl;\n\t\t\t  itmp++;\n\t\t\t}\n\t\t}\n    for (int i=1;i<=retro;i++) \n    {\n      cout<<\"here\"<<max(yrs_fsh_age_in(k)(1,nyrs_fsh_age(k)))<<endl;\n      if (max(yrs_fsh_age_in(k)(1,nyrs_fsh_age(k)))>=(endyr-retro)) \n      {\n         nyrs_fsh_age(k) -= 1;\n          if (max(yrs_fsh_age_in(k)(1,nyrs_fsh_age(k)))>=(endyr-retro)) \n             nyrs_fsh_age(k) -= 1;\n      }\n    }\n    if (nyrs_fsh_length(k) >0)\n    {\n      for (int i=1;i<=retro;i++) \n      {\n       //  cout<<\"Here \"<<max(yrs_fsh_length_in(k)(1,nyrs_fsh_length(k)))<<endl;\n        if (nyrs_fsh_length(k) >0)\n          if (max(yrs_fsh_length_in(k)(1,nyrs_fsh_length(k)))>=(endyr-retro)) \n           nyrs_fsh_length(k) -= 1;\n      }\n    }\n  }\n  // now for indices\n  for (int k=1;k<=nind;k++) \n  {\n    if ((endyr-retro)<=yrs_sel_ch_ind(k,n_sel_ch_ind(k))) n_sel_ch_ind(k)-=retro ;  \n    for (int i=1;i<=retro;i++) \n    {\n      // index values\n      if (max(yrs_ind_in(k)(1,nyrs_ind(k)))>(endyr-retro)) \n        nyrs_ind(k) -= 1;\n      // Ages (since they can be different than actual index years)\n      if (max(yrs_ind_age_in(k)(1,nyrs_ind_age(k)))>=(endyr-retro)) \n         nyrs_ind_age(k) -= 1;\n    }\n  }\n  endyr_rec_est = endyr_rec_est - retro;\n  endyr         = endyr - retro;\n  styr_fut      = endyr+1;\n  endyr_fut     = endyr + nproj_yrs; \n  endyr_sp      = endyr   - rec_age - 1;// endyr year of (main) spawning biomass\n  log_input(styr_fut);\n  log_input(endyr_fut);\n  log_input(nyrs_fsh_age);\n END_CALCS\n // now use redimensioned data for retro\n  matrix catch_bio(1,nfsh,styr,endyr)         //Catch biomass \n  matrix catch_bio_sd(1,nfsh,styr,endyr)      //Catch biomass standard errors \n  matrix catch_bio_lsd(1,nfsh,styr,endyr)     //Catch biomass standard errors (for lognormal)\n  matrix catch_bio_lva(1,nfsh,styr,endyr)     //Catch biomass variance (for lognormal)\n  matrix catch_bioT(styr,endyr,1,nfsh)\n  vector catch_lastyr(1,nfsh);\n  imatrix yrs_fsh_age(1,nfsh,1,nyrs_fsh_age)\n  imatrix yrs_fsh_length(1,nfsh,1,nyrs_fsh_length)\n  matrix  n_sample_fsh_age(1,nfsh,1,nyrs_fsh_age)    //Years of index index value (annual)\n  matrix n_sample_fsh_length(1,nfsh,1,nyrs_fsh_length)    //Years of index index value (annual)\n  3darray oac_fsh(1,nfsh,1,nyrs_fsh_age,1,nages)\n  3darray olc_fsh(1,nfsh,1,nyrs_fsh_length,1,nlength)\n\n  imatrix yrs_ind(1,nind,1,nyrs_ind)         //Years of index value (annual)\n  matrix obs_ind(1,nind,1,nyrs_ind)          //values of index value (annual)\n  matrix obs_se_ind(1,nind,1,nyrs_ind)       //values of indices serrs\n\n  imatrix yrs_ind_age(1,nind,1,nyrs_ind_age)  //Years of index value (annual)\n  imatrix yrs_ind_length(1,nind,1,nyrs_ind_length)\n  matrix n_sample_ind_age(1,nind,1,nyrs_ind_age)         //Years of index value (annual)\n  matrix n_sample_ind_length(1,nind,1,nyrs_ind_length)    //Years of index index value (annual)\n  3darray oac_ind(1,nind,1,nyrs_ind_age,1,nages)  //values of Index proportions at age\n  3darray olc_ind(1,nind,1,nyrs_ind_length,1,nlength)\n\n  matrix     obs_lse_ind(1,nind,1,nyrs_ind) //Index standard errors (for lognormal)\n  matrix     obs_lva_ind(1,nind,1,nyrs_ind) //Index standard errors (for lognormal)\n LOCAL_CALCS\n  for (int k=1;k<=nfsh;k++)\n  {\n    catch_bio(k) = catch_bio_in(k)(styr,endyr);\n    catch_bio_sd(k) = catch_bio_sd_in(k)(styr,endyr);\n    if (nyrs_fsh_age(k))\n    {\n      yrs_fsh_age(k) = yrs_fsh_age_in(k)(1,nyrs_fsh_age(k));\n      n_sample_fsh_age(k) = n_sample_fsh_age_in(k)(1,nyrs_fsh_age(k));\n    }\n    if (nyrs_fsh_length(k))\n    {\n      yrs_fsh_length(k) = yrs_fsh_length_in(k)(1,nyrs_fsh_length(k));\n      n_sample_fsh_length(k) = n_sample_fsh_length_in(k)(1,nyrs_fsh_length(k));\n    }\n    for (int i=1;i<=nyrs_fsh_age(k);i++)\n      oac_fsh(k,i) = oac_fsh_in(k,i) ;\n    for (int i=1;i<=nyrs_fsh_length(k);i++)\n      olc_fsh(k,i) = olc_fsh_in(k,i) ;\n  }\n  catch_bio_lsd = sqrt(log(square(catch_bio_sd) + 1.));\n  catch_bio_lva = log(square(catch_bio_sd) + 1.);\n  catch_bioT    = trans(catch_bio);\n  catch_lastyr  = catch_bioT(endyr);\n  for (int k=1;k<=nind;k++)\n  {\n    yrs_ind(k)  = yrs_ind_in(k)(1,nyrs_ind(k));\n    obs_ind(k)  = obs_ind_in(k)(1,nyrs_ind(k));\n    obs_se_ind(k)  = obs_se_ind_in(k)(1,nyrs_ind(k));\n\n    if (nyrs_ind_age(k)>0)\n    {\n      yrs_ind_age(k) = yrs_ind_age_in(k)(1,nyrs_ind_age(k));\n      n_sample_ind_age(k) = n_sample_ind_age_in(k)(1,nyrs_ind_age(k));\n    }\n    if (nyrs_ind_length(k)>0)\n    {\n      yrs_ind_length(k) = yrs_ind_length_in(k)(1,nyrs_ind_length(k));\n      n_sample_ind_length(k) = n_sample_ind_length_in(k)(1,nyrs_ind_length(k));\n  }\n    for (int i=1;i<=nyrs_ind_age(k);i++)\n      oac_ind(k,i) = oac_ind_in(k,i) ;\n    for (int i=1;i<=nyrs_ind_length(k);i++)\n      olc_ind(k,i) = olc_ind_in(k,i) ;\n  }\n  log_input(nyrs_fsh_age);\n  log_input(yrs_fsh_age);\n  log_input(n_sample_fsh_age);\n  log_input(oac_fsh);\n  log_input(olc_fsh);\n  log_input(wt_fsh);\n\n  log_input(nyrs_ind_age);\n  log_input(yrs_ind_age);\n  log_input(n_sample_ind_age);\n  log_input(oac_ind);\n  log_input(olc_ind);\n  obs_lse_ind = elem_div(obs_se_ind,obs_ind);\n  obs_lse_ind = sqrt(log(square(obs_lse_ind) + 1.));\n  log_input(obs_lse_ind);\n  obs_lva_ind = square(obs_lse_ind);\n END_CALCS\n\n  ////////////////////////////////////////////////////////////////////////////////////\n LOCAL_CALCS\n  for (k=1; k<=nfsh;k++)\n  {\n    // xages_fsh increments from 0-1 by number of ages, say\n    xages_fsh.initialize();\n    log_input(xages_fsh);\n    xages_fsh(k).fill_seqadd(0.,1.0/(nages-1));\n    log_input(xages_fsh);\n    //  xnodes increments from 0-1 by number of nodes\n    xnodes_fsh.initialize();\n    xnodes_fsh(k).fill_seqadd(0.,1.0/(nnodes_fsh(k)-1));\n    log_input(xnodes_fsh);\n    // xages_fsh(k).fill_seqadd(0,1.0/(nselages_in_fsh(k)-1)); //prefer to use nselages but need 3d version to work\n  }\n  write_input_log<<\"Yrs fsh_sel change: \"<<yrs_sel_ch_fsh<<endl;\n  // for (k=1; k<=nind;k++) yrs_sel_ch_ind(k) = yrs_sel_ch_tmp_ind(k)(1,n_sel_ch_ind(k));\n  write_input_log<<\"Yrs ind_sel change: \"<<yrs_sel_ch_ind<<endl;\n    log_sigmarprior = log(sigmarprior);\n    log_input(steepnessprior);\n    log_input(sigmarprior);\n    nrecs_est = endyr_rec_est-styr_rec_est+1;\n    nrecs_est = endyr_rec_est-styr_rec_est+1;\n    write_input_log<<\"#  SSB estimated in styr endyr: \" <<styr_sp    <<\" \"<<endyr_sp      <<\" \"<<endl;\n    write_input_log<<\"#  Rec estimated in styr endyr: \" <<styr_rec    <<\" \"<<endyr        <<\" \"<<endl;\n    write_input_log<<\"#  SR Curve fit  in styr endyr: \" <<styr_rec_est<<\" \"<<endyr_rec_est<<\" \"<<endl;\n    write_input_log<<\"#             Model styr endyr: \" <<styr        <<\" \"<<endyr        <<\" \"<<endl;\n    log_qprior = log(qprior);\n    log_input(qprior);\n    log_q_power_prior = log(q_power_prior);\n    write_input_log<<\"# q_power_prior \" <<endl<<q_power_prior<<\" \"<<endl;\n    write_input_log<<\"# cv_catchbiomass \" <<endl<<cv_catchbiomass<<\" \"<<endl;\n    write_input_log<<\"# CatchbiomassPen \" <<endl<<catchbiomass_pen<<\" \"<<endl;\n    write_input_log<<\"# Number of projection years \" <<endl<<nproj_yrs<<\" \"<<endl;// cin>>junk;\n\n END_CALCS\n  number R_guess;\n\n  vector offset_ind(1,nind)\n  vector offset_fsh(1,nfsh)\n  vector offset_lfsh(1,nfsh)\n  vector offset_lind(1,nind)\n\n  int do_fmort;\n  !! do_fmort=0;\n  int Popes;\n LOCAL_CALCS\n  Popes=0; // option to do Pope's approximation (not presently flagged outside of code)\n  if (Popes) \n    phase_fmort = -2;\n  else\n    phase_fmort = 1;\n\n  phase_proj  =  5;\n\n  Steepness_UB = .9999; // upper bound of steepness\n  offset_ind.initialize();\n  offset_fsh.initialize();\n  offset_lfsh.initialize();\n  offset_lind.initialize();\n  double sumtmp;\n  for (k=1;k<=nfsh;k++)\n    for (i=1;i<=nyrs_fsh_age(k);i++)\n    {\n      oac_fsh(k,i) /= sum(oac_fsh(k,i)); // Normalize to sum to one\n      offset_fsh(k) -= n_sample_fsh_age(k,i)*(oac_fsh(k,i) + 0.001) * log(oac_fsh(k,i) + 0.001 ) ;\n    }\n  for (k=1;k<=nfsh;k++)\n    for (i=1;i<=nyrs_fsh_length(k);i++)\n    {\n      olc_fsh(k,i) /= sum(olc_fsh(k,i)); // Normalize to sum to one\n      offset_lfsh(k) -= n_sample_fsh_length(k,i)*(olc_fsh(k,i) + 0.001) * log(olc_fsh(k,i) + 0.001 ) ;\n    }\n\n  for (k=1;k<=nind;k++)\n  {\n    for (i=1;i<=nyrs_ind_age(k);i++)\n    {\n      oac_ind(k,i) /= sum(oac_ind(k,i)); // Normalize to sum to one\n      offset_ind(k) -= n_sample_ind_age(k,i)*(oac_ind(k,i) + 0.001) * log(oac_ind(k,i) + 0.001 ) ;\n    }\n    for (i=1;i<=nyrs_ind_length(k);i++)\n    {\n      olc_ind(k,i) /= sum(olc_ind(k,i)); // Normalize to sum to one\n      offset_lind(k) -= n_sample_ind_length(k,i)*(olc_ind(k,i) + 0.001) * log(olc_ind(k,i) + 0.001 ) ;\n    }\n  }\n  log_input(offset_fsh); \n  log_input(offset_ind); \n\n  if (ad_comm::argc > 1) // Command line argument to profile Fishing mortality rates...\n  {\n    int on=0;\n    if ( (on=option_match(ad_comm::argc,ad_comm::argv,\"-uFmort\"))>-1)\n      do_fmort=1;\n  }\n\n  // Compute an initial Rzero value based on exploitation \n   double btmp=0.;\n   double ctmp=0.;\n   dvector ntmp(1,nages);\n   ntmp(1) = 1.;\n   for (int a=2;a<=nages;a++)\n     ntmp(a) = ntmp(a-1)*exp(-natmortprior-.05);\n   btmp = wt_pop * ntmp;\n   write_input_log << \"Mean Catch\"<<endl;\n   ctmp = mean(catch_bio);\n   write_input_log << ctmp <<endl;\n   R_guess = log((ctmp/.02 )/btmp) ;\n   write_input_log << \"R_guess \"<<endl;\n   write_input_log << R_guess <<endl;\n END_CALCS\n // vector len_bins(1,nlength)\n // !! len_bins.fill_seqadd(stlength,binlength);\n\nPARAMETER_SECTION\n // Biological Parameters\n  init_bounded_number tau(0.01,3.,-3)\n  init_bounded_number Mest(.02,4.8,phase_M)\n  init_bounded_vector Mage_offset(1,npars_Mage,-3,3,phase_Mage)\n  vector Mage(1,nages)\n  init_bounded_vector  M_rw(1,npars_rw_M,-10,10,phase_rw_M)\n  vector natmort(styr,endyr)\n  matrix  natage(styr,endyr+1,1,nages)\n  matrix N_NoFsh(styr,endyr_fut,1,nages);\n  // vector Sp_Biom(styr_sp,endyr)\n  vector pred_rec(styr_rec,endyr)\n  vector mod_rec(styr_rec,endyr) // As estimated by model\n  matrix  M(styr,endyr,1,nages)\n  matrix  Z(styr,endyr,1,nages)\n  matrix  S(styr,endyr,1,nages)\n\n\n //-----GROWTH PARAMETERS--------------------------------------------------\n  init_number log_Linf(phase_Linf);\n  init_number log_k(phase_k);\n  init_number log_Lo(phase_Lo);\n  init_number log_sdage(phase_sdage);\n//---------------------------------------------------------------------------\n\n\n // Stock rectuitment params\n  init_number mean_log_rec(1); \n  init_bounded_number steepness(0.21,Steepness_UB,phase_srec)\n  init_number log_Rzero(phase_Rzero)  \n  // OjO\n  // init_bounded_vector initage_dev(2,nages,-15,15,4)\n  init_bounded_vector rec_dev(styr_rec,endyr,-15,15,2)\n  // init_vector rec_dev(styr_rec,endyr,2)\n  init_number log_sigmar(phase_sigmar);\n  number m_sigmarsq  \n  number m_sigmar\n  number sigmarsq  \n  number sigmar\n  number alpha   \n  number beta   \n  number Bzero   \n  number Rzero   \n  number phizero\n  number avg_rec_dev   \n\n // Fishing mortality parameters\n  // init_vector         log_avg_fmort(1,nfsh,phase_fmort)\n  // init_bounded_matrix fmort_dev(1,nfsh,styr,endyr,-15,15.,phase_fmort)\n  init_bounded_matrix fmort(1,nfsh,styr,endyr,0.00,15.,phase_fmort)\n  vector Fmort(styr,endyr);  // Annual total Fmort\n  number hrate\n  number catch_tmp\n  number Fnew \n\n  !! for (k=1;k<=nfsh;k++) nselages_fsh(k)=nselages_in_fsh(k); // Sets all elements of a vector to one scalar value...\n  !! for (k=1;k<=nind;k++) nselages_ind(k)=nselages_in_ind(k); // Sets all elements of a vector to one scalar value...\n\n //  init_3darray log_selcoffs_fsh(1,nfsh,1,n_sel_ch_fsh,1,nselages_fsh,phase_selcoff_fsh)\n  init_matrix_vector log_selcoffs_fsh(1,nfsh,1,n_sel_ch_fsh,1,nselages_fsh,phase_selcoff_fsh) // 3rd dimension out...\n  // option to estimate smoother for selectivity penalty\n  // init_number_vector logSdsmu_fsh(1,nfsh,1,phase_selcoff_fsh) \n  !! if (fsh_sel_opt(1)==4) nnodes_tmp=nnodes_fsh(1);  // NOTE THIS won't work in general\n  //init_matrix_vector  log_sel_spl_fsh(1,nfsh,1,n_sel_ch_fsh,1,nnodes_tmp,phase_sel_spl_fsh)\n  init_matrix_vector  log_sel_spl_fsh(1,nfsh,1,n_sel_ch_fsh,1,4,phase_sel_spl_fsh)\n\n  !! log_input(nfsh);\n  !! log_input(n_sel_ch_fsh);\n  !! log_input(nselages_fsh);\n  !! log_input(phase_selcoff_fsh);\n  init_vector_vector logsel_slope_fsh(1,nfsh,1,n_sel_ch_fsh,phase_logist_fsh)\n  matrix                sel_slope_fsh(1,nfsh,1,n_sel_ch_fsh)\n  init_vector_vector     sel50_fsh(1,nfsh,1,n_sel_ch_fsh,phase_logist_fsh)\n\t// Case 3 double logistic, 3 parameter\n  init_vector_vector logsel_p1_fsh(1,nfsh,1,n_sel_ch_fsh,phase_dlogist_fsh)\n  matrix                sel_p1_fsh(1,nfsh,1,n_sel_ch_fsh)\n  init_vector_vector    sel_p2_fsh(1,nfsh,1,n_sel_ch_fsh,phase_dlogist_fsh)\n  init_vector_vector logsel_p3_fsh(1,nfsh,1,n_sel_ch_fsh,phase_dlogist_fsh)\n  matrix                sel_p3_fsh(1,nfsh,1,n_sel_ch_fsh)\n  // init_vector_vector logsel_dslope_fsh(1,nfsh,1,n_sel_ch_fsh,phase_dlogist_fsh)\n  // matrix                sel_dslope_fsh(1,nfsh,1,n_sel_ch_fsh)\n   !! int lb_d50=nages/2;\n  // init_bounded_vector_vector     seld50_fsh(1,nfsh,1,n_sel_ch_fsh,lb_d50,nages,phase_dlogist_fsh)\n\n  // !!exit(1);\n  3darray log_sel_fsh(1,nfsh,styr,endyr,1,nages)\n  3darray sel_fsh(1,nfsh,styr,endyr,1,nages)\n  matrix avgsel_fsh(1,nfsh,1,n_sel_ch_fsh);\n\n  matrix  Ftot(styr,endyr,1,nages)\n  3darray F(1,nfsh,styr,endyr,1,nages)\n  3darray eac_fsh(1,nfsh,1,nyrs_fsh_age,1,nages)\n//-----------------------------------------------NEW--------\n  3darray elc_fsh(1,nfsh,1,nyrs_fsh_length,1,nlength)\n  3darray elc_ind(1,nind,1,nyrs_ind_length,1,nlength)\n//----------------------------------------------------------\n  matrix  pred_catch(1,nfsh,styr,endyr)\n  3darray catage(1,nfsh,styr,endyr,1,nages)\n  matrix catage_tot(styr,endyr,1,nages)\n  matrix expl_biom(1,nfsh,styr,endyr)\n\n // Parameters for computing SPR rates \n  vector F50(1,nfsh)\n  vector F40(1,nfsh)\n  vector F35(1,nfsh)\n\n // Stuff for SPR and yield projections\n  number sigmar_fut\n  vector f_tmp(1,nfsh)\n  number SB0\n  number SBF50\n  number SBF40\n  number SBF35\n  vector Fratio(1,nfsh)\n  !! Fratio = 1;\n  !! Fratio /= sum(Fratio);\n\n  matrix Nspr(1,4,1,nages)\n \n  matrix nage_future(styr_fut,endyr_fut,1,nages)\n\n  init_vector rec_dev_future(styr_fut,endyr_fut,phase_proj);\n  vector Sp_Biom_future(styr_fut-rec_age,endyr_fut);\n  3darray F_future(1,nfsh,styr_fut,endyr_fut,1,nages);\n  matrix Z_future(styr_fut,endyr_fut,1,nages);\n  matrix S_future(styr_fut,endyr_fut,1,nages);\n  matrix catage_future(styr_fut,endyr_fut,1,nages);\n  number avg_rec_dev_future\n  vector avg_F_future(1,5)\n\n // Survey Observation parameters\n  init_number_vector log_q_ind(1,nind,phase_q) \n  init_number_vector log_q_power_ind(1,nind,phase_q_power) \n  init_vector_vector log_rw_q_ind(1,nind,1,npars_rw_q,phase_rw_q) \n  init_matrix_vector log_selcoffs_ind(1,nind,1,n_sel_ch_ind,1,nselages_ind,phase_selcoff_ind)\n\n  init_vector_vector logsel_slope_ind(1,nind,1,n_sel_ch_ind,phase_logist_ind) // Need to make positive or reparameterize\n  //init_vector_vector logsel_slope_ind(1,nind,1,n_sel_ch_ind,phase_logist_ind+1) // Need to make positive or reparameterize\n  matrix                sel_slope_ind(1,nind,1,n_sel_ch_ind)\n  init_bounded_vector_vector        sel50_ind(1,nind,1,n_sel_ch_ind,0,nages,phase_logist_ind)\n  \n  init_vector_vector logsel_p1_ind(1,nind,1,n_sel_ch_ind,phase_dlogist_ind)\n  matrix                sel_p1_ind(1,nind,1,n_sel_ch_ind)\n  init_vector_vector    sel_p2_ind(1,nind,1,n_sel_ch_ind,phase_dlogist_ind)\n  init_vector_vector logsel_p3_ind(1,nind,1,n_sel_ch_ind,phase_dlogist_ind)\n  matrix                sel_p3_ind(1,nind,1,n_sel_ch_ind)\n\n  //init_vector_vector  logsel_dslope_ind(1,nind,1,n_sel_ch_ind,phase_dlogist_ind) // Need to make positive or reparameterize\n  //init_bounded_vector_vector seld50_ind(1,nind,1,n_sel_ch_ind,lb_d50,nages,phase_dlogist_ind)\n  //matrix                sel_dslope_ind(1,nind,1,n_sel_ch_ind)\n\n  3darray log_sel_ind(1,nind,styr,endyr,1,nages)\n  3darray sel_ind(1,nind,styr,endyr,1,nages)\n  matrix avgsel_ind(1,nind,1,n_sel_ch_ind);\n\n  matrix pred_ind(1,nind,1,nyrs_ind)\n  3darray eac_ind(1,nind,1,nyrs_ind_age,1,nages)\n\n // Likelihood value names         \n  number sigma\n  vector rec_like(1,4)\n  vector catch_like(1,nfsh)\n  vector age_like_fsh(1,nfsh)\n//---------------------------------NEW\n  vector length_like_fsh(1,nfsh)\n  vector length_like_ind(1,nind)\n//---------------------------------NEW\n\n  vector age_like_ind(1,nind)\n  matrix sel_like_fsh(1,nfsh,1,4)       \n  matrix sel_like_ind(1,nind,1,4)       \n  vector ind_like(1,nind)\n  vector fpen(1,6)    \n  vector post_priors(1,8)\n  vector post_priors_indq(1,nind)\n  objective_function_value obj_fun\n  vector obj_comps(1,14)\n  init_number repl_F(5)\n\n  sdreport_number repl_yld\n  sdreport_number repl_SSB\n  sdreport_number B100\n  number F50_est\n  number F40_est\n  number F35_est\n  matrix q_ind(1,nind,1,nyrs_ind)\n  vector q_power_ind(1,nind)\n  // sdreport_vector q_ind(1,nind)\n  sdreport_vector totbiom(styr,endyr+1)\n  sdreport_vector totbiom_NoFish(styr,endyr)\n  sdreport_vector Sp_Biom(styr_sp,endyr+1)\n  sdreport_vector Sp_Biom_NoFish(styr_sp,endyr)\n  sdreport_vector Sp_Biom_NoFishRatio(styr+1,endyr)\n  sdreport_number ABCBiom;\n  sdreport_vector recruits(styr_rec,endyr+1)\n  // vector recruits(styr,endyr+1)\n  sdreport_number depletion\n  sdreport_number depletion_dyn\n  sdreport_number MSY;\n  sdreport_number MSYL;\n  sdreport_number Fmsy;\n  sdreport_number lnFmsy;\n  sdreport_number Fcur_Fmsy;\n  sdreport_number Rmsy;\n  sdreport_number Bmsy;\n  sdreport_number Bcur_Bmsy;\n  sdreport_vector pred_ind_nextyr(1,nind);\n  sdreport_number OFL;\n  // NOTE TO DAVE: Need to have a phase switch for sdreport variables(\n  matrix catch_future(1,4,styr_fut,endyr_fut); // Note, don't project for F=0 (it will bomb)\n  sdreport_matrix SSB_fut(1,5,styr_fut,endyr_fut)\n  !! write_input_log <<\"logRzero \"<<log_Rzero<<endl;\n  !! write_input_log <<\"logmeanrec \"<<mean_log_rec<<endl;\n  !! write_input_log<< \"exp(log_sigmarprior \"<<exp(log_sigmarprior)<<endl;\n  sdreport_vector sumBiom(styr,endyr+1)\n\n\n\n\n//-----GROWTH PARAMETERS--------------------------------------------------\n number Linf;\n number k_coeff;\n number Lo;\n number sdage;\n vector mu_age(1,nages);\n vector sigma_age(1,nages);\n matrix P1(1,nages,1,nlength);\n matrix P2(1,nages,1,nlength);\n matrix P3(1,nages,1,nlength);\n vector Ones_length(1,nlength);\n matrix P_age2len(1,nages,1,nlength);\n\n//-----------------------------------------------------------------------\n // Initialize coefficients (if needed)\n LOCAL_CALCS\n  for (k=1;k<=nfsh;k++) \n  {\n    write_input_log<<\"Fish sel phase: \"<<phase_selcoff_fsh(k)<<\" \"<<fshname(k)<<endl;\n    switch (fsh_sel_opt(k))\n    {\n      case 1 : // Selectivity coefficients \n      {\n        if(phase_selcoff_fsh(k)<0)\n        {\n          write_input_log<<\"Initial fixing fishery sel to\"<<endl<<n_sel_ch_fsh(k)<<endl;\n          for (int jj=1;jj<=n_sel_ch_fsh(k);jj++) \n          {\n            log_selcoffs_fsh(k,jj)(1,nselages_in_fsh(k)) = log_selcoffs_fsh_in(k,jj)(1,nselages_in_fsh(k));\n            write_input_log <<\"Init coef:\"<<endl<<exp(log_selcoffs_fsh(k,jj)(1,nselages_in_fsh(k))) <<endl;\n          }\n        }\n      }\n        break;\n      case 2 : // Single logistic\n      {\n        if(phase_logist_fsh(k)<0)\n        {\n          logsel_slope_fsh(k,1) = logsel_slp_in_fsh(k,1)  ;\n          write_input_log<<\"Fixing fishery sel to\"<<endl<<n_sel_ch_fsh(k)<<endl;\n          for (int jj=1;jj<=n_sel_ch_fsh(k);jj++) \n          {\n            logsel_slope_fsh(k,jj) = logsel_slp_in_fsh(k,jj)  ;\n            sel50_fsh(k,jj)        =    sel_inf_in_fsh(k,jj)  ;\n          }\n        }\n      }\n      case 3 : // Double logistic \n      {\n        if(phase_dlogist_fsh(k)<0)\n        {\n          write_input_log<<\"Fixing fishery sel to\"<<endl<<n_sel_ch_fsh(k)<<endl;\n          for (int jj=1;jj<=n_sel_ch_fsh(k);jj++) \n          {\n            logsel_slope_fsh(k,jj) = logsel_slp_in_fsh(k,jj)  ;\n            sel50_fsh(k,jj)        =    sel_inf_in_fsh(k,jj)  ;\n            \n            \n          }\n        }\n      }\n      case 4 : // Selectivity spline initialize \n      /* {\n        if(phase_sel_spl_fsh(k)<0)\n        {\n          write_input_log<<\"Initial fishery spline to\"<<endl<<n_sel_ch_fsh(k)<<endl;\n          for (int jj=1;jj<=n_sel_ch_fsh(k);jj++) \n          {\n            log_sel_spl_fsh(k,jj)(1,nnodes_tmp) = log_sel_spl_fsh_in(k,jj)(1,nnodes_tmp);\n            // write_input_log <<\"Init coef:\"<<endl<<exp(log_sel_spl_fsh(k,jj)(1,nselages_in_fsh(k))) <<endl;\n          }\n          log_input(log_sel_spl_fsh);\n        }\n       }*/\n     break;\n    }\n  }\n  for (k=1;k<=nind;k++) \n  {\n    write_input_log<<\"Srvy sel phase: \"<<phase_selcoff_ind(k)<<endl;\n    if(phase_selcoff_ind(k)<0)\n    {\n      write_input_log<<\"Fixing \"<<indname(k)<<\" indices sel to\"<<endl<<n_sel_ch_ind(k)<<endl;\n      for (int jj=1;jj<=n_sel_ch_ind(k);jj++) \n      {\n        log_selcoffs_ind(k,jj)(1,nselages_in_ind(k)) = log_selcoffs_ind_in(k,jj)(1,nselages_in_ind(k));\n        // write_input_log <<\"Init coef:\"<<endl<<exp(log_selcoffs_ind(k,jj)(1,nselages_in_ind(k))) <<endl;\n      }\n    }\n    if(phase_logist_ind(k)<0)\n    {\n      write_input_log<<\"Fixing index sel to\"<<endl<<n_sel_ch_ind(k)<<endl;\n      for (int jj=1;jj<=n_sel_ch_ind(k);jj++) \n      {\n        logsel_slope_ind(k,jj) = logsel_slp_in_ind(k,jj)  ;\n        // logsel_slope_ind(k,jj)    = 0.   ;\n        sel50_ind(k,jj)           = sel_inf_in_ind(k,jj)  ;\n      }\n    }\n  }\n  log_input( logsel_slp_in_indv);\n  write_input_log <<\"Leaving parameter init secton\"<<endl;\n END_CALCS\n\nPRELIMINARY_CALCS_SECTION\n  tau=0.2;\n  // Initialize age-specific changes in M if they are specified\n  M(styr) = Mest;\n  if (npars_Mage>0)\n  {\n    Mage_offset = Mage_offset_in;\n    int jj=1;\n    for (j=1;j<=nages;j++)\n    {\n     if (j==ages_M_changes(jj))\n      {\n        // M(styr,j) = M(styr,1)*mfexp(Mage_offset(jj));\n        M(styr,j) = Mest*mfexp(Mage_offset(jj));\n        jj++;\n        if (npars_Mage < jj) jj=npars_Mage;\n      }\n      else\n        if(j>1) \n          M(styr,j) = M(styr,j-1);\n    }\n  }\n  //Initialize matrix of M\n  for (i=styr+1;i<=endyr;i++)\n    M(i) = M(i-1);\n  log_input(M);\n  Get_Age2length();\n\nINITIALIZATION_SECTION\n  Mest natmortprior; \n  steepness steepnessprior\n  log_sigmar log_sigmarprior;\n\n  log_Rzero    R_guess;\n  mean_log_rec R_guess;\n  \n  log_Linf    log_Linfprior\n  log_k       log_kprior\n  log_Lo      log_Loprior\n  log_sdage   log_sdageprior\n\n  // log_avg_fmort -2.065\n  log_q_ind log_qprior; \n  log_q_power_ind log_q_power_prior; \n  repl_F .1;\n\n  sel50_fsh sel_inf_in_fshv \n\n  // logsel_dslope_fsh logsel_dslp_in_fshv ;\n  // seld50_fsh sel_dinf_in_fshv \n  logsel_p1_fsh   logsel_p1_in_fshv ;\n  sel_p2_fsh         sel_p2_in_fshv ;\n  logsel_p3_fsh   logsel_p3_in_fshv ;\n  logsel_p1_ind   logsel_p1_in_indv ;\n  sel_p2_ind         sel_p2_in_indv ;\n  logsel_p3_ind   logsel_p3_in_indv ;\n\n  logsel_slope_ind logsel_slp_in_indv ;\n  sel50_ind sel_inf_in_indv ;\n\n  //logsel_dslope_ind logsel_dslp_in_indv ;\n  //seld50_ind sel_dinf_in_indv ;\n\n //+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+=+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==\nPROCEDURE_SECTION\n  fpen.initialize();\n  for (k=1;k<=nind;k++) \n  {\n    q_ind(k) = mfexp(log_q_ind(k) );\n    q_power_ind(k) = mfexp(log_q_power_ind(k) );\n  }\n\n  // Main model calcs---------------------\n  if(active(log_Linf)||active(log_k)||active(log_sdage))\n    Get_Age2length();\n  Get_Selectivity();\n  Get_Mortality();\n  Get_Bzero();\n  Get_Numbers_at_Age();\n\n  Get_Survey_Predictions();\n  Get_Fishery_Predictions();\n  // Objective function calcs------------\n  evaluate_the_objective_function();\n  if (last_phase())\n    Get_Replacement_Yield();\n\n  // Output calcs-------------------------\n  if (sd_phase())\n  {\n    compute_spr_rates();\n    Calc_Dependent_Vars();\n    if (mcmcmode)\n    {\n      // Calc_Dependent_Vars();\n      mcflag   = 0;\n      mcmcmode = 0;\n    }\n    else\n    {\n      // if (mcflag)\n      //   Calc_Dependent_Vars();\n    }\n  }\n  // Other calcs-------------------------\n  if (mceval_phase())\n  {\n    Calc_Dependent_Vars();\n    if (oper_mod)\n      Oper_Model();\n    else\n    {\n      compute_spr_rates();\n      write_mceval();\n    }\n  }\n  if (do_fmort) Profile_F();\n //+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==\n\nFUNCTION write_mceval\n  if (mcmcmode != 3)\n    write_mceval_hdr();\n  mcmcmode = 3;\n  mc_count++;\n    mceval_sr <<\"curve 0 0\"<<endl;\n    dvariable stock;\n    for (i=1;i<=30;i++)\n    {\n      stock = double (i) * Bzero /25.;\n      if (active(log_Rzero))\n        mceval_sr << \"curve \"<<stock <<\" \"<< SRecruit(stock)<<endl;\n      else\n        mceval_sr << \"curve \"<<stock <<\" 99 \"<<endl;\n    }\n    for (k=1;k<=5;k+=4)\n\t\t{\n      for (i=styr_fut;i<=endyr_fut;i++)\n\t\t  {\n\t\t   if (int(i-rec_age)<styr_fut)\n        mceval_R<<k<<\" \"<< i <<\" \"<< natage(i-rec_age,1) <<endl;     \n\t\t   else\n        mceval_R<<k<<\" \"<< i <<\" \"<< SRecruit( SSB_fut(k,i-rec_age) ) * mfexp(rec_dev_future(i)) <<endl;     \n      }\n    }\n    for (i=1;i<=nyrs_ind(1);i++)\n    {\n      // iyr = int(yrs_ind(k,i));\n      mceval_srv<<yrs_ind(1,i)<<\" \"<<obs_ind(1,i)<<\" \"<< pred_ind(1,i) <<\" \"<< mc_count<<endl;\n\t\t}\n    for (k=1;k<=5;k++)\n    for (i=styr;i<=endyr;i++)\n\t\t{\n      // mceval_srv  <<i<<\" \"<< (i-rec_age-1)<<\" \"<<natage(i,1)<< endl;\n      // ind_like(k) += square(log(obs_ind(k,i)) - log(pred_ind(k,i)) ) / \n      mceval_sr   <<\"est \"<< Sp_Biom(i-rec_age-1)<<\" \"<<natage(i,1)<< endl;\n      mceval_M<<i <<\" \"<< M(i,2) <<\" \"<<M(i,4)<<endl;\n    }\n\t\tdvariable Rtmp;\n    for (k=1;k<=5;k++)\n\t\t{\n      for (i=styr_fut;i<=endyr_fut;i++)\n\t\t  {\n\t\t   if (int(i-rec_age)<styr_fut)\n        Rtmp = natage(i-rec_age,1) ;     \n\t\t   else\n        Rtmp = SRecruit( SSB_fut(k,i-rec_age) ) * mfexp(rec_dev_future(i)) ;     \n\t\t\t\tif (k!=5)\n          mceval_proj<<mc_count<<\" \"<<k<<\" \"<<i <<\" \"<<SSB_fut(k,i)<<\" \"<<catch_future(k,i)<<\" \"<< Rtmp <<endl;\n\t\t\t\telse\n          mceval_proj<<mc_count<<\" \"<<k<<\" \"<<i <<\" \"<<SSB_fut(k,i)<<\" 0 \"<< Rtmp <<endl;\n      }\n    }\n    \n  // styr_sp  = styr_rec - rec_age - 1 ;    // First year of spawning biomass  \n  //sdreport_vector recruits(styr,endyr+1)\n  //sdreport_vector Sp_Biom(styr_sp,endyr+1)\n\n  mceval<< model_name         << \" \"  ;\n  mceval<< obj_fun            << \" \"  ;\n\n  // mceval<< rec_dev_future << \" \"  ;\n  // mceval<<endl;\n  get_msy();\n  Future_projections();\n  // Calc_Dependent_Vars();\n  mceval<<\n  B100        << \" \"<< \n  q_ind(1,1)  << \" \"<< \n  M(endyr)    << \" \"<< \n  steepness << \" \"<< \n  depletion << \" \"<< \n  MSY       << \" \"<< \n  MSYL      << \" \"<< \n  Fmsy      << \" \"<< \n  Fcur_Fmsy << \" \"<< \n  Bcur_Bmsy << \" \"<< \n  Bmsy      << \" \"<< \n  ABCBiom   << \" \"<< \n  F35       << \" \"<<\n  F40       << \" \"<<\n  F50       << \" \"<<\n  SSB_fut(1,endyr_fut) << \" \"<< \n  SSB_fut(2,endyr_fut) << \" \"<< \n  SSB_fut(3,endyr_fut) << \" \"<< \n  SSB_fut(4,endyr_fut) << \" \"<< \n  SSB_fut(5,endyr_fut) << \" \"<< \n  catch_future(1,styr_fut)    << \" \"<<  \n  catch_future(2,styr_fut)    << \" \"<<  \n  catch_future(3,styr_fut)    << \" \"<<  \n  catch_future(4,styr_fut)    << \" \"<<  endl;\n\n\n//-----TRANSFORMATION FUNCION AGE->LENGTH--------------------------------------------------\nFUNCTION Get_Age2length\n // This subroutine allows convert an age composition to length composition. For example: if there is a matrix C(1,nyears,1,nages), \n // the vectorial operation: Cl=C*Prob_length,  returns a matrix Cl(1,nyears,1,nlength) whose sum over all the lengths is the same \n // the sum over all age groups..\n // (Cristian Canales)\n // by default values\n  // Linf=Linfprior;// Asymptotic length\n  // k_coeff=kprior;\n  // Lo=Loprior;// first length (corresponds to first age-group)\n  // sdage=sdageprior;// coefficient of variation of length-at-age\n // if some of these are estimated.\n  Linf    = mfexp(log_Linf);\n  k_coeff = mfexp(log_k);\n  Lo      = mfexp(log_Lo);\n  sdage   = mfexp(log_sdage);\n  int i, j;\n  mu_age(1)=Lo; // first length (modal)\n  for (i=2;i<=nages;i++)\n    mu_age(i) = Linf*(1.-exp(-k_coeff))+exp(-k_coeff)*mu_age(i-1); // the mean length by age group\n  sigma_age=sdage*mu_age; // standard deviation of length-at-age\n  P_age2len = ALK( mu_age, sigma_age, len_bins);\n\nFUNCTION dvar_matrix ALK(dvar_vector& mu, dvar_vector& sig, dvector& x)\n  //RETURN_ARRAYS_INCREMENT();\n  int i, j;\n  dvariable z1;\n  dvariable z2;\n  int si,ni; si=mu.indexmin(); ni=mu.indexmax();\n  int sj,nj; sj=x.indexmin(); nj=x.indexmax();\n  dvar_matrix pdf(si,ni,sj,nj);\n  double xs;\n  pdf.initialize();\n  for(i=si;i<=ni;i++) //loop over ages\n  {\n    for(j=sj;j<=nj;j++) //loop over length bins\n    {\n      if (j<nj)\n        xs=0.5*(x[sj+1]-x[sj]);  // accounts for variable bin-widths...?\n      z1=((x(j)-xs)-mu(i))/sig(i);\n      z2=((x(j)+xs)-mu(i))/sig(i);\n      pdf(i,j)=cumd_norm(z2)-cumd_norm(z1);\n    }//end nbins\n    pdf(i)/=sum(pdf(i));\n  }//end nage\n  //RETURN_ARRAYS_DECREMENT();\n  return(pdf);\n\n//---------------------------------------------------------------------------\n\n\nFUNCTION Get_Replacement_Yield\n  // compute next year's yield and SSB and add penalty to ensure F gives same SSB... \n  dvar_vector ntmp(1,nages);\n  ntmp = natage(endyr+1);\n  dvariable SSBnext;\n  dvar_matrix Ftmp(1,nfsh,1,nages);\n  dvar_vector Ctmp(1,nages);\n  dvar_vector Ztmp(1,nages);\n  dvar_vector Stmp(1,nages);\n  Ctmp.initialize();\n  Ztmp  = M(endyr);\n  dvariable sumF=0.;\n  for (k=1;k<=nfsh;k++)\n    sumF += sum(F(k,endyr));\n  for (k=1;k<=nfsh;k++)\n  {\n    Ftmp(k) = repl_F*sum(F(k,endyr)) / sumF;\n    Ztmp   += Ftmp(k);\n  }\n  Stmp = mfexp(-Ztmp);\n  for (k=1;k<=nfsh;k++)\n    Ctmp += elem_prod(wt_fsh(k,endyr),elem_prod(elem_div(Ftmp(k),Ztmp),elem_prod(1.-Stmp,ntmp)) );\n  repl_yld = sum(Ctmp) ;\n  ntmp(2,nages) = ++elem_prod(Stmp(1,nages-1),ntmp(1,nages-1));\n  ntmp(nages)  += ntmp(nages)*Stmp(nages);\n  ntmp(1)       = mean(mod_rec);\n  repl_SSB  = elem_prod(ntmp, pow(Stmp,spmo_frac)) * wt_mature; \n  obj_fun  += 200.*square(log(Sp_Biom(endyr))-log(repl_SSB));\n  \nFUNCTION Get_Selectivity\n  // Calculate the logistic selectivity (Only if being used...)   \n  for (k=1;k<=nfsh;k++)\n  {\n    switch (fsh_sel_opt(k))\n    {\n      case 1 : // Selectivity coefficients \n      //---Calculate the fishery selectivity from the sel_coffs (Only if being used...)   \n      {\n        int isel_ch_tmp = 1 ;\n        dvar_vector sel_coffs_tmp(1,nselages_fsh(k));\n        for (i=styr;i<=endyr;i++)\n        {\n          if (i==yrs_sel_ch_fsh(k,isel_ch_tmp)) \n          {\n            sel_coffs_tmp.initialize();\n            sel_coffs_tmp = log_selcoffs_fsh(k,isel_ch_tmp);\n            avgsel_fsh(k,isel_ch_tmp)              = log(mean(mfexp(sel_coffs_tmp)));\n            // Increment if there is still space to do so...\n            if (isel_ch_tmp<n_sel_ch_fsh(k))\n              isel_ch_tmp++;\n          }\n         // Need to flag for changing selectivity....XXX\n          log_sel_fsh(k,i)(1,nselages_fsh(k))        = sel_coffs_tmp;\n          log_sel_fsh(k,i)(nselages_fsh(k),nages)    = log_sel_fsh(k,i,nselages_fsh(k));\n          log_sel_fsh(k,i)                                  -= log(mean(mfexp(log_sel_fsh(k,i) )));\n        }\n      }\n      break;\n      case 2 : // Single logistic\n      {\n        sel_slope_fsh(k) = mfexp(logsel_slope_fsh(k));\n        int isel_ch_tmp = 1 ;\n        dvariable sel_slope_tmp = sel_slope_fsh(k,isel_ch_tmp);\n        dvariable sel50_tmp     = sel50_fsh(k,isel_ch_tmp);\n        for (i=styr;i<=endyr;i++)\n        {\n          if (i==yrs_sel_ch_fsh(k,isel_ch_tmp)) \n          {\n            sel_slope_tmp = sel_slope_fsh(k,isel_ch_tmp);\n            sel50_tmp     =     sel50_fsh(k,isel_ch_tmp);\n            if (isel_ch_tmp<n_sel_ch_fsh(k))\n              isel_ch_tmp++;\n          }\n          log_sel_fsh(k,i)(1,nselages_fsh(k))     = -1.*log( 1.0 + mfexp(-1.*sel_slope_tmp * \n                                                ( age_vector(1,nselages_fsh(k)) - sel50_tmp) ));\n          log_sel_fsh(k,i)(nselages_fsh(k),nages) = log_sel_fsh(k,i,nselages_fsh(k));\n        }\n    }\n    break;\n    case 3 : // Double logistic\n    {\n      sel_p1_fsh(k)  = mfexp(logsel_p1_fsh(k));\n      sel_p3_fsh(k)  = mfexp(logsel_p3_fsh(k));\n      int isel_ch_tmp = 1 ;\n      dvariable p1 = sel_p1_fsh(k,isel_ch_tmp);\n      dvariable p2 = sel_p2_fsh(k,isel_ch_tmp);\n      dvariable p3 = sel_p3_fsh(k,isel_ch_tmp);\n\t\t\tdvariable i1 = p1 + p2;\n\t\t\tdvariable i2 = p1 + i1 + p3;\n\t\t\t\n      for (i=styr;i<=endyr;i++)\n      {\n        if (i==yrs_sel_ch_fsh(k,isel_ch_tmp)) \n        {\n          p1 = sel_p1_fsh(k,isel_ch_tmp);\n          p2 = sel_p2_fsh(k,isel_ch_tmp);\n          p3 = sel_p3_fsh(k,isel_ch_tmp);\n\t\t\t    i1 = p1 + p2;\n\t\t\t    i2 = p1 + i1 + p3;\n          if (isel_ch_tmp<n_sel_ch_fsh(k))\n            isel_ch_tmp++;\n        }\n        log_sel_fsh(k,i)(1,nselages_fsh(k))     = ( -log(1.0 + mfexp(-2.9444389792/p1 * ( age_vector(1,nselages_fsh(k)) - i1) )) +\n               log(1. - 1./(1.0 + mfexp(-2.9444389792/p3 * ( age_vector(1,nselages_fsh(k)) - i2))) ) )+0.102586589 ; // constant at end is log(0.95*0.95)\n\n\t\t\t// cout << p1 << \" \"<<p2<<\" \"<<p3<<endl<<i1<<\" \"<<i2<<endl<<age_vector<<endl<<sel_fsh(k,i)<<endl;exit(1);\n  // OjO, still has nselages as part of configuration option...\n        log_sel_fsh(k,i)(nselages_fsh(k),nages) = log_sel_fsh(k,i,nselages_fsh(k));\n        \n        //log_sel_fsh(k,i) -= max(log_sel_fsh(k,i));\n        // sel_fsh(k,i) /= 0.9025 ; // Simply 95th %ile squared as normalizing  \n      }\n    }\n    break;\n    //---Calculate the fishery selectivity from the sel_spl from nodes...\n    case 4 : // Splines\n     break;\n    } // End of switch for fishery selectivity type\n  } // End of fishery loop\n  // Survey specific---\n  for (k=1;k<=nind;k++)\n  {\n    switch (ind_sel_opt(k))\n    {\n      case 1 : // Selectivity coefficients\n      //---Calculate the fishery selectivity from the sel_coffs (Only if being used...)   \n      {\n        int isel_ch_tmp = 1 ;\n        dvar_vector sel_coffs_tmp(1,nselages_ind(k));\n        for (i=styr;i<=endyr;i++)\n        {\n          if (i==yrs_sel_ch_ind(k,isel_ch_tmp)) \n          {\n            sel_coffs_tmp.initialize();\n            sel_coffs_tmp = log_selcoffs_ind(k,isel_ch_tmp);\n            avgsel_ind(k,isel_ch_tmp)              = log(mean(mfexp(sel_coffs_tmp)));\n            if (isel_ch_tmp<n_sel_ch_ind(k))\n              isel_ch_tmp++;\n          }\n          log_sel_ind(k,i)(1,nselages_ind(k))        = sel_coffs_tmp;\n          log_sel_ind(k,i)(nselages_ind(k),nages)    = log_sel_ind(k,i,nselages_ind(k));\n          log_sel_ind(k,i)                                  -= log(mean(mfexp(log_sel_ind(k,i)(q_age_min(k),q_age_max(k))))); \n        }\n      }\n  \n        break;\n      case 2 : // Asymptotic logistic\n        {\n          sel_slope_ind(k) = mfexp(logsel_slope_ind(k));\n          int isel_ch_tmp = 1 ;\n          dvariable sel_slope_tmp = sel_slope_ind(k,isel_ch_tmp);\n          dvariable sel50_tmp     = sel50_ind(k,isel_ch_tmp);\n          for (i=styr;i<=endyr;i++)\n          {\n            if (i==yrs_sel_ch_ind(k,isel_ch_tmp)) \n            {\n              sel_slope_tmp = sel_slope_ind(k,isel_ch_tmp);\n              sel50_tmp     =     sel50_ind(k,isel_ch_tmp);\n              if (isel_ch_tmp<n_sel_ch_ind(k))\n                isel_ch_tmp++;\n            }\n            log_sel_ind(k,i) = - log( 1.0 + mfexp(-sel_slope_tmp * ( age_vector - sel50_tmp) ));\n            // log_sel_ind(k,i)                                  -= log(mean(mfexp(log_sel_ind(k,i)(q_age_min(k),q_age_max(k))))); \n          }\n        }\n        break;\n      case 3 : // Double logistic\n        {\n          sel_p1_ind(k)  = mfexp(logsel_p1_ind(k));\n          sel_p3_ind(k)  = mfexp(logsel_p3_ind(k));\n          int isel_ch_tmp = 1 ;\n          dvariable p1 = sel_p1_ind(k,isel_ch_tmp);\n          dvariable p2 = sel_p2_ind(k,isel_ch_tmp);\n          dvariable p3 = sel_p3_ind(k,isel_ch_tmp);\n          dvariable i1 = p1 + p2;\n          dvariable i2 = p1 + i1 + p3;\n          \n          for (i=styr;i<=endyr;i++)\n          {\n            if (i==yrs_sel_ch_ind(k,isel_ch_tmp)) \n            {\n              p1 = sel_p1_ind(k,isel_ch_tmp);\n              p2 = sel_p2_ind(k,isel_ch_tmp);\n              p3 = sel_p3_ind(k,isel_ch_tmp);\n              i1 = p1 + p2;\n              i2 = p1 + i1 + p3;\n              if (isel_ch_tmp<n_sel_ch_ind(k))\n                isel_ch_tmp++;\n            }\n            log_sel_ind(k,i)(1,nselages_ind(k))     = ( -log(1.0 + mfexp(-2.9444389792/p1 * ( age_vector(1,nselages_ind(k)) - i1) )) +\n                                                          log(1. - 1./(1.0 + mfexp(-2.9444389792/p3 * ( age_vector(1,nselages_ind(k)) - i2))) ) )+0.102586589 ; // constant at end is log(0.95*0.95)\n            \n            // cout << p1 << \" \"<<p2<<\" \"<<p3<<endl<<i1<<\" \"<<i2<<endl<<age_vector<<endl<<sel_ind(k,i)<<endl;exit(1);\n            // OjO, still has nselages as part of configuration option...\n            log_sel_ind(k,i)(nselages_ind(k),nages) = log_sel_ind(k,i,nselages_ind(k));\n            \n            //log_sel_ind(k,i) -= max(log_sel_ind(k,i));\n            // sel_ind(k,i) /= 0.9025 ; // Simply 95th %ile squared as normalizing  \n          }\n        }\n      break;\n    }// end of swtiches for indices selectivity\n  } // End of indices loop\n\n  // Map selectivities across fisheries and indices as needed.\n  for (k=1;k<=nfsh;k++)\n    if (sel_map(2,k)!=k)  // If 2nd row shows a different fishery then use that fishery\n      log_sel_fsh(k) = log_sel_fsh(sel_map(2,k));\n\n  for (k=1+nfsh;k<=nfsh_and_ind;k++)\n    if (sel_map(1,k)!=2) \n      log_sel_ind(k-nfsh) = log_sel_fsh(sel_map(2,k));\n    else if (sel_map(2,k)!=(k-nfsh)) \n      log_sel_ind(k-nfsh) = log_sel_ind(sel_map(2,k));\n\n  sel_fsh = mfexp(log_sel_fsh);\n  sel_ind = mfexp(log_sel_ind);\n\nFUNCTION Get_NatMortality\n  natmort = Mest;\n\tif (active(Mest)) \n\t\tM(styr) = Mest;\n  // Age varying part\n  if (npars_Mage>0 )\n  {\n    int jj=1;\n    for (j=1;j<=nages;j++)\n    {\n      if (j==ages_M_changes(jj))\n      {\n        // M(styr,j) = M(styr,1)*mfexp(Mage_offset(jj));\n        M(styr,j) = Mest*mfexp(Mage_offset(jj));\n        jj++;\n        if (npars_Mage < jj) jj=npars_Mage;\n      }\n      else\n        if(j>1) \n          M(styr,j) = M(styr,j-1);\n    }\n  }\n\n  // Time varying part\n  if (npars_rw_M>0 && active(M_rw))\n  {\n    int ii=1;\n    for (i=styr+1;i<=endyr;i++)\n    {\n      if (i==yrs_rw_M(ii))\n      {\n        M(i) = M(i-1)*mfexp(M_rw(ii));\n        ii++;\n        if (npars_rw_M < ii) ii=npars_rw_M;\n      }\n      else\n        M(i) = M(i-1);\n    }\n  }\n  else\n    for (i=styr+1;i<=endyr;i++)\n      M(i) = M(i-1);\n\nFUNCTION Get_Mortality2\n  Get_NatMortality();\n  Z       = M;\n  for (k=1;k<=nfsh;k++)\n  {\n    F(k)   = elem_div(catage(k),natage);\n    Z     += F(k);\n  }\n  S = mfexp(-1.*Z);\n\nFUNCTION Get_Mortality\n  Get_NatMortality();\n  Z = M; \n  if (!Popes)\n  {\n    Fmort.initialize();\n    for (k=1;k<=nfsh;k++)\n    {\n      Fmort +=  fmort(k);\n      for (i=styr;i<=endyr;i++)\n      {\n        F(k,i)   =  fmort(k,i) * sel_fsh(k,i) ;\n        Z(i)    += F(k,i);\n      }\n    }\n    S  = mfexp(-1.*Z);\n  }\n  \n\nFUNCTION Get_Numbers_at_Age\n  // natage(styr,1) = mfexp(mean_log_rec + rec_dev(styr)); \n  // Recruitment in subsequent years\n  for (i=styr+1;i<=endyr;i++)\n    natage(i,1)=mfexp(mean_log_rec+rec_dev(i));\n\n  mod_rec(styr)  = natage(styr,1);\n\n  for (i=styr;i<=endyr;i++)\n  {\n    if (Popes)\n    {\n      dvariable  t1=mfexp(-natmort(i)*0.5);\n      dvariable  t2=mfexp(-natmort(i));\n      Catch_at_Age(i);\n      // Pope's approximation //   Next year N     =   This year x NatSurvivl - catch\n      natage(i+1)(2,nages) = ++(natage(i)(1,nages-1)*t2 - catage_tot(i)(1,nages-1)*t1);\n      Ftot(i)(1,nages-1) = log(natage(i)(1,nages-1)) - --log(natage(i+1)(2,nages)) - natmort(i);\n      natage(i+1,nages)   += natage(i,nages)*t2 - catage_tot(i,nages)*t1;\n      // Approximation to \"F\" continuous form for computing within-year sp biomass\n      Ftot(i,nages)      = log(natage(i,nages-1)+natage(i,nages)) -log(natage(i+1,nages)) -natmort(i);\n      // write_input_log <<i<<\" \"<<Ftot(i)(nages-4,nages)<<endl; // cout <<i<<\" \"<<natage(i)<<endl; // cout <<i<<\" \"<<natage(i+1)<<endl;\n      dvariable ctmp=sum(catage_tot(i));\n      for (k=1;k<=nfsh;k++)\n      {\n        F(k,i)  = Ftot(i) * sum(catage(k,i))/ctmp;\n      }\n      Z(i)    = Ftot(i)+natmort(i);\n      S(i)    = mfexp(-Z(i));\n    }\n    else // Baranov\n    {\n      // get_Fs( i ); //ojo, add switch here for different catch equation XX\n      // if (i!=endyr)\n      // {\n        natage(i+1)(2,nages) = ++elem_prod(natage(i)(1,nages-1),S(i)(1,nages-1));\n        natage(i+1,nages)   +=natage(i,nages)*S(i,nages);\n      // }\n    }\n    Catch_at_Age(i);\n    Sp_Biom(i)  = elem_prod(natage(i),pow(S(i),spmo_frac)) * wt_mature; \n    if (i<endyr) mod_rec(i+1)  = natage(i+1,1);\n  }\n\nFUNCTION Get_Survey_Predictions\n  // Survey computations------------------\n  dvariable sum_tmp;\n  sum_tmp.initialize();\n  int ii;\n  int iyr;\n  for (k=1;k<=nind;k++)\n  {\n    // Set rest of q's in time series equal to the random walk for current (avoids tricky tails...)\n    for (i=2;i<=(1+npars_rw_q(k));i++)\n    {\n      // get index for the number of observations (can be different than number of q's)\n      ii = yrs_rw_q(k,i-1) - yrs_ind(k,1) + 1;  \n      q_ind(k,ii)  = q_ind(k,ii-1)*mfexp(log_rw_q_ind(k,i-1));\n      for (iyr=ii+1;iyr<=nyrs_ind(k);iyr++)\n        q_ind(k,iyr)  = q_ind(k,ii);\n    }\n    for (i=1;i<=nyrs_ind(k);i++)\n    {        \n      iyr=yrs_ind(k,i);\n      pred_ind(k,i) = q_ind(k,i) * pow(elem_prod(natage(iyr),pow(S(iyr),ind_month_frac(k))) * \n                                     elem_prod(sel_ind(k,iyr) , wt_ind(k,iyr)),q_power_ind(k));\n    }\n    for (i=1;i<=nyrs_ind_age(k);i++)\n    {        \n      iyr = yrs_ind_age(k,i); \n      dvar_vector tmp_n   = elem_prod(pow(S(iyr),ind_month_frac(k)),elem_prod(sel_ind(k,iyr),natage(iyr)));  \n      sum_tmp             = sum(tmp_n);\n      if (use_age_err)\n        eac_ind(k,i)      = age_err * tmp_n/sum_tmp;\n      else\n        eac_ind(k,i)      = tmp_n/sum_tmp;\n    }\n    dvar_vector tmp_n(1,nages);\n    for (i=1;i<=nyrs_ind_length(k);i++)\n    {        \n      iyr          = yrs_ind_length(k,i); \n      tmp_n        = elem_prod(pow(S(iyr),ind_month_frac(k)),elem_prod(sel_ind(k,iyr),natage(iyr)));  \n      sum_tmp      = sum(tmp_n);\n      tmp_n       /= sum_tmp;\n      elc_ind(k,i) = tmp_n * P_age2len ;\n    }\n    iyr=yrs_ind(k,nyrs_ind(k));\n    dvar_vector natagetmp = elem_prod(S(endyr),natage(endyr));\n    natagetmp(2,nages) = ++natagetmp(1,nages-1);\n    natagetmp(1)       = SRecruit(Sp_Biom(endyr+1-rec_age));\n    natagetmp(nages)  += natage(endyr,nages)*S(endyr,nages);\n    // Assume same survival in 1st part of next year as same as first part of current\n    pred_ind_nextyr(k) = q_ind(k,nyrs_ind(k)) * pow(elem_prod(natagetmp,pow(S(endyr),ind_month_frac(k))) * \n                                     elem_prod(sel_ind(k,endyr) , wt_ind(k,endyr)),q_power_ind(k));\n  }\n\nFUNCTION Get_Fishery_Predictions\n  for (k=1;k<=nfsh;k++)\n  {\n    for (i=1; i<=nyrs_fsh_age(k); i++)\n    {\n      if (use_age_err)\n        eac_fsh(k,i) = age_err * catage(k,yrs_fsh_age(k,i))/sum(catage(k,yrs_fsh_age(k,i)));\n      else\n        eac_fsh(k,i) = catage(k,yrs_fsh_age(k,i))/sum(catage(k,yrs_fsh_age(k,i)));\n      eac_fsh(k,i) /= sum(eac_fsh(k,i));\n    }\n\n // predicted length compositions !!\n    for (i=1; i<=nyrs_fsh_length(k); i++)\n    {\n      elc_fsh(k,i) = catage(k,yrs_fsh_length(k,i))*P_age2len;\n      elc_fsh(k,i) /= sum(elc_fsh(k,i));\n    }\n  }\n\nFUNCTION Calc_Dependent_Vars\n  get_msy();\n\n  if (phase_proj>0) \n\t\tFuture_projections();\n  N_NoFsh.initialize();\n  N_NoFsh(styr) = natage(styr);\n  for (i=styr_sp;i<=styr;i++)\n    Sp_Biom_NoFish(i) = Sp_Biom(i);\n  for (i=styr;i<=endyr;i++)\n  {                 \n    recruits(i)  = natage(i,1);\n    if (i>styr)\n    {\n      N_NoFsh(i,1)        = recruits(i);\n      N_NoFsh(i,1)       *= SRecruit(Sp_Biom_NoFish(i-rec_age)) / SRecruit(Sp_Biom(i-rec_age));\n      N_NoFsh(i)(2,nages) = ++elem_prod(N_NoFsh(i-1)(1,nages-1),exp(-M(i-1)(1,nages-1)));\n      N_NoFsh(i,nages)   += N_NoFsh(i-1,nages)*exp(-M(i-1,nages));\n    }\n    totbiom_NoFish(i) = N_NoFsh(i)*wt_pop;\n    totbiom(i)        = natage(i)*wt_pop;\n    sumBiom(i)        = natage(i)(3,nages)*wt_pop(3,nages);\n    Sp_Biom_NoFish(i) = N_NoFsh(i)*elem_prod(pow(exp(-M(i)),spmo_frac) , wt_mature); \n    if (i>styr)\n\t\t  Sp_Biom_NoFishRatio(i) = Sp_Biom(i) / Sp_Biom_NoFish(i) ;\n    depletion         = totbiom(endyr)/totbiom(styr);\n    depletion_dyn     = totbiom(endyr)/totbiom_NoFish(endyr);\n  }\n  B100 = phizero * mean(recruits(styr_rec_est, endyr_rec_est));\n  dvar_vector Nnext(1,nages);\n  Nnext(2,nages) = ++elem_prod(natage(endyr)(1,nages-1),S(endyr)(1,nages-1));\n  Nnext(nages)  += natage(endyr,nages)*S(endyr,nages);\n  // Compute SSB in next year using mean recruits for age 1 and same survival as in endyr\n  Nnext(1)       = mfexp(mean_log_rec+rec_dev_future(endyr+1));\n  Sp_Biom(endyr+1)  = elem_prod(Nnext,pow(S(endyr),spmo_frac)) * wt_mature; \n  // Nnext(1)       = SRecruit(Sp_Biom(endyr+1-rec_age));\n  ABCBiom       = Nnext*wt_pop;\n  sumBiom(endyr+1) = Nnext(3,nages)*wt_pop(3,nages);\n  recruits(endyr+1) = Nnext(1);\n  totbiom(endyr+1)  = ABCBiom;\n  // Now do OFL for next year...\n  dvar_matrix seltmp(1,nfsh,1,nages);\n  dvar_matrix Fatmp(1,nfsh,1,nages);\n  dvar_vector Ztmp(1,nages);\n  seltmp.initialize();\n  Fatmp.initialize();\n  Ztmp.initialize();\n  for (k=1;k<=nfsh;k++)\n    seltmp(k) = (sel_fsh(k,endyr));\n  Ztmp = (M(styr));\n  for (k=1;k<=nfsh;k++)\n  { \n    Fatmp(k) = (Fratio(k) * Fmsy * seltmp(k));\n    Ztmp    += Fatmp(k);\n  } \n  dvar_vector survmsy = exp(-Ztmp);\n  dvar_vector ctmp(1,nages);\n  ctmp.initialize();\n  OFL=0.;\n  for (k=1;k<=nfsh;k++)\n  {\n      for ( j=1 ; j <= nages; j++ )\n        ctmp(j)      = Nnext(j) * Fatmp(k,j) * (1. - survmsy(j)) / Ztmp(j);\n      OFL  += wt_fsh(k,endyr) * ctmp;\n  }\n\nFUNCTION void Catch_at_Age(const int& i)\n  dvariable vbio=0.;\n  dvariable pentmp;\n  dvar_vector Nmid(1,nages);\n  dvar_vector Ctmp(1,nages);\n  catage_tot(i).initialize();\n  if (Popes)\n  {\n    Nmid = elem_prod(natage(i),mfexp(-M(i)/2) ); \n  }\n  for (k=1;k<=nfsh;k++)\n  {\n    if (Popes)\n    {\n      pentmp=0.;\n      Ctmp = elem_prod(Nmid,sel_fsh(k,i));\n      vbio = Ctmp*wt_fsh(k,i);\n      //Kludge to go here...\n      // dvariable SK = posfun( (.98*vbio - catch_bio(k,i))/vbio , 0.1 , pentmp );\n      dvariable SK = posfun( (vbio - catch_bio(k,i))/vbio , 0.1 , pentmp );\n      catch_tmp    = vbio - SK*vbio; \n      hrate        = catch_tmp / vbio;\n      fpen(4) += pentmp;\n      Ctmp *= hrate;                          \n      if (hrate>1) {cout << catch_tmp<<\" \"<<vbio<<endl;exit(1);}\n      catage_tot(i) += Ctmp;                      \n      catage(k,i)    = Ctmp;                      \n      if (last_phase())\n        pred_catch(k,i) = Ctmp*wt_fsh(k,i);\n    }\n    else\n    {\n      catage(k,i) = elem_prod(elem_div(F(k,i),Z(i)),elem_prod(1.-S(i),natage(i)));\n      pred_catch(k,i) = catage(k,i)*wt_fsh(k,i);\n    }\n  }\n  //+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==\nFUNCTION evaluate_the_objective_function\n  // if (active(fmort_dev))   \n  if (active(fmort))   \n  {\n    Cat_Like();\n    Fmort_Pen();\n  }\n  Rec_Like();\n  if (active(rec_dev))\n    Age_Like();\n  Srv_Like();\n  Sel_Like();\n  Compute_priors();\n  if (active(log_Rzero)) // OjO\n    obj_fun += .5 * square(log_Rzero-mean_log_rec); // A slight penalty to keep Rzero in reality...\n\n  obj_comps.initialize();\n  obj_comps(1)  = sum(catch_like);\n  obj_comps(2)  = sum(age_like_fsh);\n//------------------------------------------NEW-------------\n  obj_comps(3)  = sum(length_like_fsh);\n//-----------------------------------------------------------\n  obj_comps(4)  = sum(sel_like_fsh);\n  obj_comps(5)  = sum(ind_like);\n  obj_comps(6)  = sum(age_like_ind);\n  obj_comps(7)  = sum(length_like_ind);\n  obj_comps(8)  = sum(sel_like_ind);\n  obj_comps(9)  = sum(rec_like);\n  obj_comps(10) = sum(fpen);\n  obj_comps(11) = sum(post_priors_indq);\n  obj_comps(12) = sum(post_priors);\n  obj_fun     += sum(obj_comps);\n\nFUNCTION Cat_Like\n  // Eases into the catch-biomass likelihoods.  If too far off to start, full constraint to fit can be too aggressive\n  catch_like.initialize();\n  dvariable catch_pen;\n  switch (current_phase())\n  {\n    case 1:\n      catch_pen = .1;\n      break;\n    case 2:\n      catch_pen = .5;\n      break;\n    case 3:\n      catch_pen = .8;\n      break;\n    case 4:\n      catch_pen = 1.0;\n      break;\n    case 5:\n      catch_pen = 1;\n      break;\n    default:\n      catch_pen = 1;\n      break;\n  }\n  if (current_phase()>3)\n  {\n    for (k=1;k<=nfsh;k++)\n      for (i=styr;i<=endyr;i++)\n         catch_like(k) += .5*square(log(catch_bio(k,i)+.0001) - log(pred_catch(k,i)+.0001) )/catch_bio_lva(k,i);\n  }\n  else\n  {\n    for (k=1;k<=nfsh;k++)\n      catch_like(k) += catchbiomass_pen * norm2(log(catch_bio(k)   \n                      +.000001) - log(pred_catch(k) +.000001));\n  }\n\n  catch_like *= catch_pen;\n\nFUNCTION Rec_Like\n  rec_like.initialize();\n  if (active(rec_dev))\n  {\n    sigmar     =  mfexp(log_sigmar);\n    sigmarsq   =  square(sigmar);\n    if (current_phase()>2)\n    {\n      if (last_phase())\n        pred_rec = SRecruit(Sp_Biom(styr_rec-rec_age,endyr-rec_age).shift(styr_rec)(styr_rec,endyr));\n      else \n        pred_rec = .1+SRecruit(Sp_Biom(styr_rec-rec_age,endyr-rec_age).shift(styr_rec)(styr_rec,endyr));\n\n      dvariable SSQRec;\n      SSQRec.initialize();\n      dvar_vector chi(styr_rec_est,endyr_rec_est);\n      chi = log(mod_rec(styr_rec_est,endyr_rec_est)) - log(pred_rec(styr_rec_est,endyr_rec_est));\n      SSQRec   = norm2( chi ) ;\n      m_sigmarsq =  SSQRec/nrecs_est;\n      m_sigmar   =  sqrt(m_sigmarsq);\n\n      if (current_phase()>4||last_phase())\n        rec_like(1) = (SSQRec+ m_sigmarsq/2.)/(2*sigmarsq) + nrecs_est*log_sigmar; \n      else\n        rec_like(1) = .1*(SSQRec+ m_sigmarsq/2.)/(2*sigmarsq) + nrecs_est*log_sigmar; \n    }\n\n    // Variance term for the parts not estimated by sr curve\n    if (last_phase())\n    {\n      rec_like(4) += .5*norm2( rec_dev(styr_rec,styr_rec_est) )/sigmarsq + (styr_rec_est-styr_rec)*log(sigmar) ; \n      if ( endyr > endyr_rec_est)\n        rec_like(4) += .5*norm2( rec_dev(endyr_rec_est,endyr  ) )/sigmarsq + (endyr-endyr_rec_est)*log(sigmar) ; \n    }\n    else // JNI comment next line\n       rec_like(2) += norm2( rec_dev(styr_rec,endyr) ) ;\n\n    // rec_like(2) += norm2( rec_dev(styr_rec_est,endyr) ) ;\n\n    if (active(rec_dev_future))\n    {\n      // Future recruitment variability (based on past)\n      sigmar_fut   = sigmar ;\n      rec_like(3) += norm2(rec_dev_future)/(2*square(sigmar_fut))+ size_count(rec_dev_future)*log(sigmar_fut);\n    }\n  }\n\nFUNCTION Compute_priors\n  post_priors.initialize();\n  post_priors_indq.initialize();\n  for (k=1;k<=nind;k++)\n  {\n    if (active(log_q_ind(k)))\n      post_priors_indq(k) += square(log(q_ind(k,1)/qprior(k)))/(2.*cvqprior(k)*cvqprior(k)); \n    if (active(log_q_power_ind(k)))\n      post_priors_indq(k) += square(log(q_power_ind(k)/q_power_prior(k)))/(2.*cvq_power_prior(k)*cvq_power_prior(k)); \n    if (active(log_rw_q_ind(k)))\n      for (int i=1;i<=npars_rw_q(k);i++)\n      {\n        post_priors_indq(k) += square(log_rw_q_ind(k,i))/ (2.*sigma_rw_q(k,i)*sigma_rw_q(k,i)) ;\n      }\n     //  -q_power_prior(k))/(2*cvq_power_prior(k)*cvq_power_prior(k)); \n  }\n\n  if (active(Mest))\n    post_priors(1) += square(log(Mest/natmortprior))/(2.*cvnatmortprior*cvnatmortprior); \n\n  if (active(Mage_offset))  \n    post_priors(1) += norm2(Mage_offset)/(2.*cvnatmortprior*cvnatmortprior); \n\n  if (active(M_rw))\n    for (int i=1;i<=npars_rw_M;i++)\n      post_priors(1) +=  square(M_rw(i))/ (2.*sigma_rw_M(i)*sigma_rw_M(i)) ;\n\n  if (active(steepness))\n    post_priors(2) += square(log(steepness/steepnessprior))/(2*cvsteepnessprior*cvsteepnessprior); \n\n  if (active(log_sigmar))\n    post_priors(3) += square(log(sigmar/sigmarprior))/(2*cvsigmarprior*cvsigmarprior); \n\n\n//--------------------------NEW------------------------------------\n  if (active(log_Linf))\n    post_priors(4) += square(log_Linf-log_Linfprior)/(2*cvLinfprior*cvLinfprior); \n\n  if (active(log_k))\n    post_priors(5) += square(log_k-log_kprior)/(2*cvkprior*cvkprior); \n\n  if (active(log_Lo))\n    post_priors(6) += square(log_Lo-log_Loprior)/(2*cvLoprior*cvLoprior); \n\n  if (active(log_sdage))\n    post_priors(7) += square(log_sdage-log_sdageprior)/(2*cvsdageprior*cvsdageprior); \n\nFUNCTION Fmort_Pen\n  // Phases less than 3, penalize High F's---------------------------------\n  if (current_phase()<3)\n    fpen(1) += 1.* norm2(F - .2);\n  else \n    fpen(1) += 0.0001*norm2(F - .2); \n\n  // for (k=1;k<=nfsh;k++)  fpen(2) += 20.*square(mean(fmort_dev(k)) ); // this is just a normalizing constraint (fmort_devs sum to zero) }\n    \nFUNCTION Sel_Like \n  sel_like_fsh.initialize();\n  sel_like_ind.initialize();\n  for (k=1;k<=nfsh;k++)\n  {\n    if (active(logsel_p1_fsh(k))||active(logsel_slope_fsh(k)))\n    {\n      sel_like_fsh(k,3)    += .1*square( logsel_p1_fsh(k,1) )  ;\n      sel_like_fsh(k,3)    += .1*square(    sel_p2_fsh(k,1) )  ;\n      sel_like_fsh(k,3)    += .1*square( logsel_p3_fsh(k,1) )  ;\n      for (i=2;i<=n_sel_ch_fsh(k);i++)\n      {\n          int iyr = yrs_sel_ch_fsh(k,i) ;\n          dvariable var_tmp = square(sel_sigma_fsh(k,i));\n\n          sel_like_fsh(k,2)    += .5*norm2( log_sel_fsh(k,iyr-1) - log_sel_fsh(k,iyr) ) / var_tmp ;\n          sel_like_fsh(k,3)    += .1*square( logsel_p1_fsh(k,i) )  ;\n          sel_like_fsh(k,3)    += .1*square(    sel_p2_fsh(k,i) )  ;\n          sel_like_fsh(k,3)    += .1*square( logsel_p3_fsh(k,i) )  ;\n      }\n    }\n\n    if (active(log_selcoffs_fsh(k)))\n    {\n      for (i=1;i<=n_sel_ch_fsh(k);i++)\n      {\n        int iyr = yrs_sel_ch_fsh(k,i) ;\n        // If curvature penalty is assumed....\n        sel_like_fsh(k,1) += curv_pen_fsh(k)*norm2(first_difference( first_difference(log_sel_fsh(k,iyr))));\n        // If curvature penalty (sigma) is estimated....\n        // dvariable var=mfexp(2.0*logSdsmu_fsh(k));\n        // sel_like_fsh(k,1) += 0.5*(size.count(log_sel_fsh(k,iyr))*log(var) +  norm2(first_difference( first_difference(log_sel_fsh(k,iyr)))) /var);\n        if (i>1)\n        {\n          // This part is the penalty on the change itself--------------\n          dvariable var_tmp = square(sel_sigma_fsh(k,i));\n          sel_like_fsh(k,2)    += .5*norm2( log_sel_fsh(k,iyr-1) - log_sel_fsh(k,iyr) ) / var_tmp ;\n        }\n        int nagestmp = nselages_fsh(k);\n        for (j=seldecage;j<=nagestmp;j++)\n        {\n          dvariable difftmp = log_sel_fsh(k,iyr,j-1)-log_sel_fsh(k,iyr,j) ;\n          if (difftmp > 0.)\n            sel_like_fsh(k,3)    += .5*square( difftmp ) / seldec_pen_fsh(k);\n        }\n        obj_fun            += 20 * square(avgsel_fsh(k,i)); // To normalize selectivities\n      }\n    }\n  }\n  for (k=1;k<=nind;k++)\n  {\n    if (active(logsel_p1_ind(k))||active(logsel_slope_ind(k)))\n    {\n      sel_like_ind(k,3)    += .1*square( logsel_p1_ind(k,1) )  ;\n      sel_like_ind(k,3)    += .1*square(    sel_p2_ind(k,1) )  ;\n      sel_like_ind(k,3)    += .1*square( logsel_p3_ind(k,1) )  ;\n      for (i=2;i<=n_sel_ch_ind(k);i++)\n      {\n        int iyr = yrs_sel_ch_ind(k,i) ;\n        dvariable var_tmp = square(sel_sigma_ind(k,i));\n        \n        sel_like_ind(k,2)    += .5*norm2( log_sel_ind(k,iyr-1) - log_sel_ind(k,iyr) ) / var_tmp ;\n        sel_like_ind(k,3)    += .1*square( logsel_p1_ind(k,i) )  ;\n        sel_like_ind(k,3)    += .1*square(    sel_p2_ind(k,i) )  ;\n        sel_like_ind(k,3)    += .1*square( logsel_p3_ind(k,i) )  ;\n      }\n    }\n    if (active(log_selcoffs_ind(k)))\n    {\n      int nagestmp = nselages_ind(k);\n      for (i=1;i<=n_sel_ch_ind(k);i++)\n      {\n        int iyr = yrs_sel_ch_ind(k,i) ;\n        sel_like_ind(k,1) += curv_pen_ind(k)*norm2(first_difference( first_difference(log_sel_ind(k,iyr))));\n        // This part is the penalty on the change itself--------------\n        if (i>1)\n        {\n          dvariable var_tmp = square(sel_sigma_ind(k,i));\n          sel_like_ind(k,2)    += .5*norm2( log_sel_ind(k,iyr-1) - log_sel_ind(k,iyr) ) / var_tmp ;\n        }\n        for (j=seldecage;j<=nagestmp;j++)\n        {\n          dvariable difftmp = log_sel_ind(k,iyr,j-1)-log_sel_ind(k,iyr,j) ;\n          if (difftmp > 0.)\n            sel_like_ind(k,3)    += .5*square( difftmp ) / seldec_pen_ind(k);\n        }\n        obj_fun            += 20. * square(avgsel_ind(k,i));  // To normalize selectivities\n      }\n    }\n  }\n\nFUNCTION Srv_Like\n  // Fit to indices (log-Normal) -------------------------------------------\n  ind_like.initialize();\n  int iyr;\n  for (k=1;k<=nind;k++)\n    for (i=1;i<=nyrs_ind(k);i++)\n    {\n      // iyr = int(yrs_ind(k,i));\n      ind_like(k) += square(log(obs_ind(k,i)) - log(pred_ind(k,i)) ) / \n                                   (2.*obs_lse_ind(k,i)*obs_lse_ind(k,i));\n    }\n  /* normal distribution option to add someday...\n    for (i=1;i<=nyrs_ind(k);i++)\n      ind_like(k) += square(obs_ind(k,i) - pred_ind(k,yrs_ind(k,i)) ) / \n                                   (2.*obs_se_ind(k,i)*obs_se_ind(k,i));\n  */\n\nFUNCTION Age_Like\n  age_like_fsh.initialize();\n\tdvariable nsamtheta;\n  for (k=1;k<=nfsh;k++)\n    for (int i=1;i<=nyrs_fsh_age(k);i++)\n      age_like_fsh(k) -= n_sample_fsh_age(k,i)*(oac_fsh(k,i) + 0.001) * log(eac_fsh(k,i) + 0.001 ) ;\n  age_like_fsh -= offset_fsh;\n  /*\n  logistic_normal cMyAgeComp(oac_fsh(1),eac_fsh(1));\n  age_like_fsh = cMyAgeComp.negative_loglikelihood(tau);\n        // dirichlet-multinomial\n  for (k=1;k<=nfsh;k++)\n    for (int i=1;i<=nyrs_fsh_age(k);i++)\n\t\t{\n\t\t\t nsamtheta = n_sample_fsh_age(k,i)*theta ;\n       age_like_fsh(k) -= lgamma( nsamtheta );\n       age_like_fsh(k) += lgamma( n_sample_fsh_age(k,i) + nsamtheta );\n       for(j=1; j<=nages; j++)\n\t\t\t {\n         age_like_fsh(k) -= lgamma( AgeComp_at(AgeI,YearI) + \n\t\t\t\t            theta*n_samp(YearI)*(Cn_at(AgeI,YearI)/tmp_sum*0.9999 + 0.0001/(AgeMax+1)) );\n         age_like_fsh(k) += lgamma( theta*n_samp(YearI)*(Cn_at(AgeI,YearI)/tmp_sum*0.9999 + 0.0001/(AgeMax+1)) );\n       }\n       n_effective(YearI) = 1/(1+theta) + n_samp(YearI)*(theta/(1+theta));\n     }\n\t\n  */\n\n//-----------------------------------NEW-----------------------\n  length_like_fsh.initialize();\n  for (k=1;k<=nfsh;k++)\n    for (int i=1;i<=nyrs_fsh_length(k);i++)\n      length_like_fsh(k) -= n_sample_fsh_length(k,i)*(olc_fsh(k,i) + 0.001) * log(elc_fsh(k,i) + 0.001 ) ;\n  length_like_fsh -= offset_lfsh;\n//----------------------------------------------------------\n  length_like_ind.initialize();\n  for (k=1;k<=nind;k++)\n    for (int i=1;i<=nyrs_ind_length(k);i++)\n      length_like_ind(k) -= n_sample_ind_length(k,i)*(olc_ind(k,i) + 0.001) * log(elc_ind(k,i) + 0.001 ) ;\n  length_like_ind -= offset_lind;\n//----------------------------------------------------------\n  age_like_ind.initialize();\n  for (k=1;k<=nind;k++)\n    for (int i=1;i<=nyrs_ind_age(k);i++)\n      age_like_ind(k) -= n_sample_ind_age(k,i)*(oac_ind(k,i) + 0.001) * log(eac_ind(k,i) + 0.001 ) ;\n  age_like_ind -= offset_ind;\n\nFUNCTION Oper_Model\n // Initialize things used here only\n  mc_count++;\n  get_msy();\n  Write_SimDatafile();\n  Write_Datafile();\n  dmatrix new_ind(1,nind,1,nyrs_ind);\n  new_ind.initialize();\n\n  int nsims;\n  ifstream sim_in(\"nsims.dat\");\n  sim_in >> nsims; sim_in.close();\n\n  dvector ran_ind_vect(1,nind);\n  ofstream SaveOM(\"Om_Out.dat\",ios::app);\n  double C_tmp;\n  dvariable Fnow;\n  // Initialize recruitment in first year\n  for (i=styr_fut-rec_age;i<styr_fut;i++)\n    Sp_Biom_future(i) = Sp_Biom(i);\n  nage_future(styr_fut)(2,nages)              = ++elem_prod(natage(endyr)(1,nages-1),S(endyr)(1,nages-1));\n  nage_future(styr_fut,nages)                += natage(endyr,nages)*S(endyr,nages);\n\n  // assume survival same as in last year...\n  Sp_Biom_future(styr_fut) = elem_prod(nage_future(styr_fut),pow(S(endyr),spmo_frac)) * wt_mature; \n  for (int isim=1;isim<=nsims;isim++)\n  {\n    cout<<isim<<\" \"<<cmp_no<<\" \"<<mc_count<<\" \"<<endl;\n    // Copy file to get mean for Mgt Strategies\n    system(\"init_stuff.bat\");\n    for (i=styr_fut;i<=endyr_fut;i++)\n    {\n      // Some unit normals...for generating data\n      ran_ind_vect.fill_randn(rng);\n      cout<<ran_ind_vect<<endl;\n      // Create new indices observations\n      // for (k = 1 ; k<= nind ; k++) new_ind(k) = mfexp(ran_ind_vect(k)*.2)*value(nage_future(i)*q_ind(k,nyrs_ind(k))*sel_ind(k,endyr)); // use value function since converts to a double\n      // new_ind(1) = mfexp(ran_ind_vect(1)*0.2)*value(sum(nage_future(i)*q_ind(1,nyrs_ind(1))));\n      if(styr_fut==i)\n        new_ind(1) = mfexp(ran_ind_vect(1)*0.2)*value(wt_ind(1,endyr)*(natage(i-1)));\n      else\n        new_ind(1) = mfexp(ran_ind_vect(1)*0.2)*value(wt_ind(1,endyr)*(nage_future(i-1)));\n      // now for Selecting which MP to use\n      // Append new indices observation to datafile\n      ifstream tacin(\"ctac.dat\");\n      int nobstmp;\n      tacin >> nobstmp ;\n      dvector t_tmp(1,nobstmp);\n      tacin >> t_tmp;\n      tacin.close();\n      ofstream octac(\"ctac.dat\");\n      octac<<nobstmp+1<<endl;\n      octac<<t_tmp<<endl;\n      octac<<new_ind(1)<<endl;\n      octac.close();\n      system(\"ComputeTAC.bat \" + (itoa(cmp_no,10))); // commandline function to get TAC (catchnext.dat)\n     // Now read in TAC (actual catch)\n     ifstream CatchNext(\"CatchNext.dat\");\n     CatchNext >> C_tmp; \n     CatchNext.close();\n     //if (cmp_no==5) C_tmp=value((natmort(styr))*mean(t_tmp(nobstmp-2,nobstmp)));\n     //if (cmp_no==6) C_tmp=value((natmort(styr))*.75*mean(t_tmp(nobstmp-2,nobstmp)));\n     if (cmp_no==5) \n     {\n       C_tmp = min(C_tmp*1.1,value((natmort(styr)*t_tmp(nobstmp))));\n       ofstream cnext(\"CatchNext.dat\");\n       cnext <<C_tmp<<endl;\n       cnext.close();\n     }\n     if (cmp_no==6) \n     {\n       C_tmp = min(C_tmp*1.1,value(natmort(styr)*.75*t_tmp(nobstmp)));\n       ofstream cnext(\"CatchNext.dat\");\n       cnext <<C_tmp<<endl;\n       cnext.close();\n     }\n\n     Fnow = SolveF2(endyr,nage_future(i), C_tmp);\n\n      F_future(1,i) = sel_fsh(1,endyr) * Fnow;\n      //Z_future(i)   = F_future(1,i) + max(natmort);\n      Z_future(i)   = F_future(1,i) + mean(M);\n      S_future(i)   = mfexp(-Z_future(i));\n      nage_future(i,1)  = SRecruit( Sp_Biom_future(i-rec_age) ) * mfexp(rec_dev_future(i)) ;     \n      Sp_Biom_future(i) = wt_mature * elem_prod(nage_future(i),pow(S_future(i),spmo_frac)) ;\n      // Now graduate for the next year....\n      if (i<endyr_fut)\n      {\n        nage_future(i+1)(2,nages) = ++elem_prod(nage_future(i)(1,nages-1),S_future(i)(1,nages-1));\n        nage_future(i+1,nages)   += nage_future(i,nages)*S_future(i,nages);\n      }\n      catage_future(i) = 0.; \n      for (k = 1 ; k<= nfsh ; k++)\n        catage_future(i) += elem_prod(nage_future(i) , elem_prod(F_future(k,i) , elem_div( ( 1.- S_future(i) ) , Z_future(i))));\n  \n      SaveOM << model_name       <<\n        \" \"  << cmp_no           <<\n        \" \"  << mc_count         <<\n        \" \"  << isim             <<\n        \" \"  << i                <<\n        \" \"  << Fnow             <<\n        \" \"  << Fnow/Fmsy        <<\n        \" \"  << Sp_Biom_future(i-rec_age)                       <<\n        \" \"  << nage_future(i)                                  <<\n        \" \"  << catage_future(i)*wt_fsh(1,endyr)                <<\n        \" \"  << mean(M)                                   <<\n        \" \"  << t_tmp(nobstmp)                                  <<\n      endl;\n    }\n  }\n  // if (mc_count>5) exit(1);\n  SaveOM.close();\n  if (!mceval_phase())\n    exit(1);\n\nFUNCTION void get_future_Fs(const int& i,const int& iscenario)\n    f_tmp.initialize();\n    dvar_matrix F_fut_tmp(1,nfsh,1,nages);\n    for (k=1;k<=nfsh;k++) F_fut_tmp(k) =F(k,endyr);\n    switch (iscenario)\n    {\n      case 1:\n        // f_tmp = F35;\n        for (int k=1;k<=nfsh;k++) f_tmp(k) = mean(F(k,endyr));\n        // for (int k=1;k<=nfsh;k++) f_tmp(k) = SolveF2(endyr,nage_future(i), 1.0  * catch_lastyr(k));\n        break;\n      case 2:\n        // for (int k=1;k<=nfsh;k++) f_tmp(k) = Fratio(k)*Fmsy; // mean(F(k,endyr));\n        for (int k=1;k<=nfsh;k++) f_tmp(k) = mean(F(k,endyr));\n        f_tmp *= 0.75;\n        break;\n      case 3:\n        for (int k=1;k<=nfsh;k++) f_tmp(k) = mean(F(k,endyr));\n        f_tmp *= 0.5;\n        break;\n      case 4:\n        // for (int k=1;k<=nfsh;k++) f_tmp(k) = .25*mean(F(k,endyr));\n        // F_fut_tmp *= 0.25;\n        for (int k=1;k<=nfsh;k++) f_tmp(k) = mean(F(k,endyr));\n        f_tmp *= 0.25;\n      case 5:\n        f_tmp = 0.0;\n        F_fut_tmp = 0.0;\n        break;\n    }\n    Z_future(i) = M(endyr);\n    for (k=1;k<=nfsh;k++)\n    {\n      F_future(k,i) = sel_fsh(k,endyr) * f_tmp(k);\n      Z_future(i)  += F_future(k,i);\n    }\n    S_future(i) = mfexp(-Z_future(i));\n\nFUNCTION Future_projections\n  // Need to check on treatment of Fratio--whether it should be included or not\n  SSB_fut.initialize();\n  catch_future.initialize();\n  for (int iscen=1;iscen<=5;iscen++)\n  {\n   // Future Sp_Biom set equal to estimated Sp_Biom w/ right lag\n    // Sp_Biom_future(styr_fut-rec_age,styr_fut-1) = Sp_Biom(endyr-rec_age+1,endyr);\n    for (i=styr_fut-rec_age;i<styr_fut;i++)\n      Sp_Biom_future(i) = wt_mature * elem_prod(natage(i),pow(S(i),spmo_frac)) ;\n\n    nage_future(styr_fut)(2,nages) = ++elem_prod(natage(endyr)(1,nages-1),S(endyr)(1,nages-1));\n    nage_future(styr_fut,nages)   += natage(endyr,nages)*S(endyr,nages);\n    Sp_Biom_future(styr_fut)       = wt_mature * elem_prod(nage_future(i),pow(S_future(i),spmo_frac)) ;\n    // Future Recruitment (and Sp_Biom)\n    for (i=styr_fut;i<endyr_fut;i++)\n    {\n      nage_future(i,1)  = SRecruit( Sp_Biom_future(i-rec_age) ) * mfexp(rec_dev_future(i)) ;     \n      get_future_Fs(i,iscen);\n      // Now graduate for the next year....\n      nage_future(i+1)(2,nages) = ++elem_prod(nage_future(i)(1,nages-1),S_future(i)(1,nages-1));\n      nage_future(i+1,nages)   += nage_future(i,nages)*S_future(i,nages);\n      Sp_Biom_future(i) = wt_mature * elem_prod(nage_future(i),pow(S_future(i),spmo_frac)) ;\n    }\n    nage_future(endyr_fut,1)  = SRecruit( Sp_Biom_future(endyr_fut-rec_age) ) * mfexp(rec_dev_future(endyr_fut)) ;     \n    get_future_Fs(endyr_fut,iscen);\n    Sp_Biom_future(endyr_fut)  = wt_mature * elem_prod(nage_future(endyr_fut),pow(S_future(endyr_fut),spmo_frac)) ;\n    /*\n\t\tif (iscen==1)\n    {\n      for (i=endyr+1;i<=endyr_fut;i++)\n      {                   \n        N_NoFsh(i,1)        = nage_future(i,1);\n        // Adjustment for no-fishing recruits (ratio of R_nofish/R_fish)\n        N_NoFsh(i,1)       *= SRecruit(Sp_Biom_NoFish(i-rec_age)) / SRecruit(Sp_Biom_future(i-rec_age));\n        N_NoFsh(i)(2,nages) = ++N_NoFsh(i-1)(1,nages-1)*exp(-mean(natmort));\n        N_NoFsh(i,nages)   +=   N_NoFsh(i-1,nages)*exp(-mean(natmort));\n        Sp_Biom_NoFish(i)   = (N_NoFsh(i)*pow(exp(-mean(natmort)),spmo_frac) * wt_mature); \n        // Sp_Biom_NoFishRatio(i)  = Sp_Biom_future(i) / Sp_Biom_NoFish(i) ;\n      }\n    }\n    */\n    // Now get catch at future ages\n    dvar_vector catage_tmp(1,nages);\n    for (i=styr_fut; i<=endyr_fut; i++)\n    {\n      catage_future(i).initialize();\n      if (iscen!=5) \n      {\n        for (k = 1 ; k<= nfsh ; k++)\n        {\n          catage_tmp.initialize();\n          catage_tmp = elem_prod(nage_future(i) , elem_prod(F_future(k,i) , \n                                elem_div( ( 1.- S_future(i) ) , Z_future(i))));\n          catage_future(i) += catage_tmp;\n          catch_future(iscen,i)  += catage_tmp*wt_fsh(k,endyr);\n        }\n      }\n      SSB_fut(iscen,i) = Sp_Biom_future(i);\n    }\n  }   //End of loop over F's\n  Sp_Biom(endyr+1) = Sp_Biom_future(endyr+1);\n\nFUNCTION get_msy\n  /** Function calculates used in calculating MSY and MSYL for a designated component of the\n  population, given values for stock recruitment and selectivity...  \n  Fmsy is the trial value of MSY example of the use of \"funnel\" to reduce the amount of storage for derivative calculations \n  */\n\n  dvariable sumF=0.;\n  for (k=1;k<=nfsh;k++)\n    sumF += sum(F(k,endyr));\n  for (k=1;k<=nfsh;k++)\n    Fratio(k) = sum(F(k,endyr)) / sumF;\n\n  dvariable Stmp;\n  dvariable Rtmp;\n  double df=1.e-05;\n  dvariable F1;\n  F1.initialize();\n  F1 = (0.8*natmortprior);\n  dvariable F2;\n  dvariable F3;\n  dvariable yld1;\n  dvariable yld2;\n  dvariable yld3;\n  dvariable dyld;\n  dvariable dyldp;\n  int breakout=0;\n  // Newton Raphson stuff to go here\n  for (int ii=1;ii<=8;ii++)\n  {\n    if (mceval_phase()&&(F1>5||F1<0.01)) \n    {\n      ii=8;\n      if (F1>5) F1=5.0; \n      else      F1=0.001; \n      breakout    = 1;\n    }\n    F2     = F1 + df*.5;\n    F3     = F2 - df;\n    // yld1   = yield(Fratio,F1, Stmp,Rtmp); // yld2   = yield(Fratio,F2,Stmp,Rtmp); // yld3   = yield(Fratio,F3,Stmp,Rtmp);\n    yld1   = yield(Fratio,F1);\n    yld2   = yield(Fratio,F2);\n    yld3   = yield(Fratio,F3);\n    dyld   = (yld2 - yld3)/df;                          // First derivative (to find the root of this)\n    dyldp  = (yld2 + yld3 - 2.*yld1)/(.25*df*df);       // Second derivative (for Newton Raphson)\n    if (breakout==0)\n    {\n      F1    -= dyld/dyldp;\n    }\n    else\n    {\n      if (F1>5) \n        cout<<\"Fmsy v. high \"<< endl;// yld1<<\" \"<< yld2<<\" \"<< yld3<<\" \"<< F1<<\" \"<< F2<<\" \"<< F3<<\" \"<< endl;\n      else      \n        cout<<\"Fmsy v. low \"<< endl;// yld1<<\" \"<< yld2<<\" \"<< yld3<<\" \"<< F1<<\" \"<< F2<<\" \"<< F3<<\" \"<< endl;\n    }\n  }\n  {\n    dvar_vector ttt(1,5);\n    ttt      = yld(Fratio,F1);\n    Fmsy     = F1;\n    Rtmp     = ttt(3);\n    MSY      = ttt(2);\n    Bmsy     = ttt(1);\n    MSYL     = ttt(1)/Bzero;\n    lnFmsy   = log(MSY/ttt(5)); // Exploitation fraction relative to total biomass\n    Bcur_Bmsy= Sp_Biom(endyr)/Bmsy;\n\n    dvariable FFtmp;\n    FFtmp.initialize();\n    for (k=1;k<=nfsh;k++)\n      FFtmp += mean(F(k,endyr));\n    Fcur_Fmsy= FFtmp/Fmsy;\n    Rmsy     = Rtmp;\n  }\n\nFUNCTION void get_msy(int iyr)\n  /** Function calculates used in calculating MSY and MSYL for a designated component of the\n  population, given values for stock recruitment and selectivity...  \n  Fmsy is the trial value of MSY example of the use of \"funnel\" to reduce the amount of storage for derivative calculations */\n\n  dvariable sumF=0.;\n  for (k=1;k<=nfsh;k++)\n    sumF += sum(F(k,iyr));\n  for (k=1;k<=nfsh;k++)\n    Fratio(k) = sum(F(k,iyr)) / sumF;\n\n  dvariable Stmp;\n  dvariable Rtmp;\n  double df=1.e-05;\n  dvariable F1;\n  F1.initialize();\n  F1 = (0.8*natmortprior);\n  dvariable F2;\n  dvariable F3;\n  dvariable yld1;\n  dvariable yld2;\n  dvariable yld3;\n  dvariable dyld;\n  dvariable dyldp;\n  int breakout=0;\n  // Newton Raphson stuff to go here\n  for (int ii=1;ii<=8;ii++)\n  {\n    if (mceval_phase()&&(F1>5||F1<0.01)) \n    {\n      ii=8;\n      if (F1>5) F1=5.0; \n      else      F1=0.001; \n      breakout    = 1;\n    }\n    F2     = F1 + df*.5;\n    F3     = F2 - df;\n    // yld1   = yield(Fratio,F1, Stmp,Rtmp); // yld2   = yield(Fratio,F2,Stmp,Rtmp); // yld3   = yield(Fratio,F3,Stmp,Rtmp);\n    yld1   = yield(Fratio,F1,iyr);\n    yld2   = yield(Fratio,F2,iyr);\n    yld3   = yield(Fratio,F3,iyr);\n    dyld   = (yld2 - yld3)/df;                          // First derivative (to find the root of this)\n    dyldp  = (yld2 + yld3 - 2.*yld1)/(.25*df*df);   // Second derivative (for Newton Raphson)\n    if (breakout==0)\n    {\n      F1    -= dyld/dyldp;\n    }\n    else\n    {\n      if (F1>5) \n        cout<<\"Fmsy v. high \"<< endl;// yld1<<\" \"<< yld2<<\" \"<< yld3<<\" \"<< F1<<\" \"<< F2<<\" \"<< F3<<\" \"<< endl;\n      else      \n        cout<<\"Fmsy v. low \"<< endl;// yld1<<\" \"<< yld2<<\" \"<< yld3<<\" \"<< F1<<\" \"<< F2<<\" \"<< F3<<\" \"<< endl;\n    }\n  }\n  {\n    dvar_vector ttt(1,5);\n    ttt      = yld(Fratio,F1,iyr);\n    Fmsy     = F1;\n    Rtmp     = ttt(3);\n    MSY      = ttt(2);\n    Bmsy     = ttt(1);\n    MSYL     = ttt(1)/Bzero;\n    lnFmsy   = log(MSY/ttt(5)); // Exploitation fraction relative to total biomass\n    Bcur_Bmsy= Sp_Biom(iyr)/Bmsy;\n\n    dvariable FFtmp;\n    FFtmp.initialize();\n    for (k=1;k<=nfsh;k++)\n      FFtmp += mean(F(k,iyr));\n    Fcur_Fmsy= FFtmp/Fmsy;\n    Rmsy     = Rtmp;\n  }\n\nFUNCTION dvar_vector yld(const dvar_vector& Fratio, const dvariable& Ftmp,int iyr)\n  RETURN_ARRAYS_INCREMENT();\n  /*dvariable utmp=1.-mfexp(-(Ftmp)); dvariable Ntmp; dvariable Btmp; dvariable yield; dvariable survtmp=exp(-1.*natmort); dvar_vector seltmp=sel_fsh(endyr); Ntmp = 1.; Btmp = Ntmp*wt(1)*seltmp(1); Stmp = .5*Ntmp*wt(1)*maturity(1); yield= 0.; for ( j=1 ; j < nages ; j++ ) { Ntmp  *= (1.-utmp*seltmp(j))*survtmp; Btmp  += Ntmp*wt(j+1)*seltmp(j+1); Stmp  += .5 * Ntmp *wt(j+1)*maturity(j+1); } //Max Age - 1 yr yield   += utmp * Btmp; Ntmp    /= (1-survtmp*(1.-utmp*seltmp(nages))); Btmp    += Ntmp*wt(nages)*seltmp(nages); Stmp    += 0.5 *wt(nages)* Ntmp *maturity(nages); yield   += utmp * Btmp; //cout<<yield<<\" \"<<Stmp<<\" \"<<Btmp<<\" \";*/\n  dvar_vector msy_stuff(1,5);\n  dvariable phi;\n  dvar_vector Ntmp(1,nages);\n  dvar_vector Ctmp(1,nages);\n  msy_stuff.initialize();\n\n  dvar_matrix seltmp(1,nfsh,1,nages);\n  for (k=1;k<=nfsh;k++)\n   seltmp(k) = sel_fsh(k,iyr); // NOTE uses last-year of fishery selectivity for projections.\n\n  dvar_matrix Fatmp(1,nfsh,1,nages);\n  dvar_vector Ztmp(1,nages);\n\n  Ztmp = M(iyr);\n  for (k=1;k<=nfsh;k++)\n  { \n    Fatmp(k) = Fratio(k) * Ftmp * seltmp(k);\n    Ztmp    += Fatmp(k);\n  } \n  dvar_vector survtmp = mfexp(-Ztmp);\n\n  Ntmp(1) = 1.;\n  for ( j=1 ; j < nages; j++ )\n    Ntmp(j+1)  =   Ntmp(j) * survtmp(j); // Begin numbers in the next year/age class\n  Ntmp(nages)  /= (1.- survtmp(nages)); \n\n  for (k=1;k<=nfsh;k++)\n  {\n    Ctmp.initialize();\n    for ( j=1 ; j <= nages; j++ )\n      Ctmp(j)      = Ntmp(j) * Fatmp(k,j) * (1. - survtmp(j)) / Ztmp(j);\n\n    msy_stuff(2)  += wt_fsh(k,iyr) * Ctmp;\n  }\n  phi    = elem_prod( Ntmp , pow(survtmp,spmo_frac ) ) * wt_mature;\n  // Req    = Requil(phi) * exp(sigmarsq/2);\n  msy_stuff(5)  = Ntmp * wt_pop;      \n  msy_stuff(4)  = phi/phizero ;       // SPR\n  msy_stuff(3)  = Requil(phi) ;       // Eq Recruitment\n  msy_stuff(5) *= msy_stuff(3);       // BmsyTot\n  msy_stuff(2) *= msy_stuff(3);       // MSY\n  msy_stuff(1)  = phi*(msy_stuff(3)); // Bmsy\n  RETURN_ARRAYS_DECREMENT();\n  return msy_stuff;\n\n //+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+ \nFUNCTION dvar_vector yld(const dvar_vector& Fratio, const dvariable& Ftmp)\n  RETURN_ARRAYS_INCREMENT();\n  /*dvariable utmp=1.-mfexp(-(Ftmp)); dvariable Ntmp; dvariable Btmp; dvariable yield; dvariable survtmp=exp(-1.*natmort); dvar_vector seltmp=sel_fsh(endyr); Ntmp = 1.; Btmp = Ntmp*wt(1)*seltmp(1); Stmp = .5*Ntmp*wt(1)*maturity(1); yield= 0.; for ( j=1 ; j < nages ; j++ ) { Ntmp  *= (1.-utmp*seltmp(j))*survtmp; Btmp  += Ntmp*wt(j+1)*seltmp(j+1); Stmp  += .5 * Ntmp *wt(j+1)*maturity(j+1); } //Max Age - 1 yr yield   += utmp * Btmp; Ntmp    /= (1-survtmp*(1.-utmp*seltmp(nages))); Btmp    += Ntmp*wt(nages)*seltmp(nages); Stmp    += 0.5 *wt(nages)* Ntmp *maturity(nages); yield   += utmp * Btmp; //cout<<yield<<\" \"<<Stmp<<\" \"<<Btmp<<\" \";*/\n  dvar_vector msy_stuff(1,5);\n  dvariable phi;\n  dvar_vector Ntmp(1,nages);\n  dvar_vector Ctmp(1,nages);\n  msy_stuff.initialize();\n\n  dvar_matrix seltmp(1,nfsh,1,nages);\n  for (k=1;k<=nfsh;k++)\n   seltmp(k) = sel_fsh(k,endyr); // NOTE uses last-year of fishery selectivity for projections.\n\n  dvar_matrix Fatmp(1,nfsh,1,nages);\n  dvar_vector Ztmp(1,nages);\n\n  Ztmp = M(styr);\n  for (k=1;k<=nfsh;k++)\n  { \n    Fatmp(k) = Fratio(k) * Ftmp * seltmp(k);\n    Ztmp    += Fatmp(k);\n  } \n  dvar_vector survtmp = mfexp(-Ztmp);\n\n  Ntmp(1) = 1.;\n  for ( j=1 ; j < nages; j++ )\n    Ntmp(j+1)  =   Ntmp(j) * survtmp(j); // Begin numbers in the next year/age class\n  Ntmp(nages)  /= (1.- survtmp(nages)); \n\n  for (k=1;k<=nfsh;k++)\n  {\n    Ctmp.initialize();\n    for ( j=1 ; j <= nages; j++ )\n      Ctmp(j)      = Ntmp(j) * Fatmp(k,j) * (1. - survtmp(j)) / Ztmp(j);\n\n    msy_stuff(2)  += wt_fsh(k,endyr) * Ctmp;\n  }\n  phi    = elem_prod( Ntmp , pow(survtmp,spmo_frac ) ) * wt_mature;\n  // Req    = Requil(phi) * exp(sigmarsq/2);\n  msy_stuff(5)  = Ntmp * wt_pop;      \n  msy_stuff(4)  = phi/phizero ;       // SPR\n  msy_stuff(3)  = Requil(phi) ;       // Eq Recruitment\n  msy_stuff(5) *= msy_stuff(3);       // BmsyTot\n  msy_stuff(2) *= msy_stuff(3);       // MSY\n  msy_stuff(1)  = phi*(msy_stuff(3)); // Bmsy\n  RETURN_ARRAYS_DECREMENT();\n  return msy_stuff;\n\nFUNCTION dvariable yield(const dvar_vector& Fratio, const dvariable& Ftmp,int iyr)\n  RETURN_ARRAYS_INCREMENT();\n  /*dvariable utmp=1.-mfexp(-(Ftmp)); dvariable Ntmp; dvariable Btmp; dvariable yield; dvariable survtmp=exp(-1.*natmort); dvar_vector seltmp=sel_fsh(endyr); Ntmp = 1.; Btmp = Ntmp*wt(1)*seltmp(1); Stmp = .5*Ntmp*wt(1)*maturity(1); yield= 0.; for ( j=1 ; j < nages ; j++ ) { Ntmp  *= (1.-utmp*seltmp(j))*survtmp; Btmp  += Ntmp*wt(j+1)*seltmp(j+1); Stmp  += .5 * Ntmp *wt(j+1)*maturity(j+1); } //Max Age - 1 yr yield   += utmp * Btmp; Ntmp    /= (1-survtmp*(1.-utmp*seltmp(nages))); Btmp    += Ntmp*wt(nages)*seltmp(nages); Stmp    += 0.5 *wt(nages)* Ntmp *maturity(nages); yield   += utmp * Btmp; //cout<<yield<<\" \"<<Stmp<<\" \"<<Btmp<<\" \";*/\n  dvariable phi;\n  dvariable Req;\n  dvar_vector Ntmp(1,nages);\n  dvar_vector Ctmp(1,nages);\n  dvariable   yield;\n  yield.initialize();\n\n  dvar_matrix seltmp(1,nfsh,1,nages);\n  for (k=1;k<=nfsh;k++)\n   seltmp(k) = sel_fsh(k,iyr); // NOTE uses last-year of fishery selectivity for projections.\n\n  dvar_matrix Fatmp(1,nfsh,1,nages);\n  dvar_vector Ztmp(1,nages);\n\n  Ztmp = M(iyr);\n  for (k=1;k<=nfsh;k++)\n  { \n    Fatmp(k) = Fratio(k) * Ftmp * seltmp(k);\n    Ztmp    += Fatmp(k);\n  } \n  dvar_vector survtmp = mfexp(-Ztmp);\n\n  Ntmp(1) = 1.;\n  for ( j=1 ; j < nages; j++ )\n    Ntmp(j+1)  =   Ntmp(j) * survtmp(j); // Begin numbers in the next year/age class\n  Ntmp(nages)  /= (1.- survtmp(nages)); \n\n  for (k=1;k<=nfsh;k++)\n  {\n    Ctmp.initialize();\n    for ( j=1 ; j <= nages; j++ )\n      Ctmp(j)      = Ntmp(j) * Fatmp(k,j) * (1. - survtmp(j)) / Ztmp(j);\n\n    yield  += wt_fsh(k,iyr) * Ctmp;\n  }\n  phi    = elem_prod( Ntmp , pow(survtmp,spmo_frac ) )* wt_mature;\n  // Req    = Requil(phi) * mfexp(sigmarsq/2);\n  Req    = Requil(phi) ;\n  yield *= Req;\n\n  RETURN_ARRAYS_DECREMENT();\n  return yield;\n\nFUNCTION dvariable yield(const dvar_vector& Fratio, const dvariable& Ftmp)\n  RETURN_ARRAYS_INCREMENT();\n  /*dvariable utmp=1.-mfexp(-(Ftmp)); dvariable Ntmp; dvariable Btmp; dvariable yield; dvariable survtmp=exp(-1.*natmort); dvar_vector seltmp=sel_fsh(endyr); Ntmp = 1.; Btmp = Ntmp*wt(1)*seltmp(1); Stmp = .5*Ntmp*wt(1)*maturity(1); yield= 0.; for ( j=1 ; j < nages ; j++ ) { Ntmp  *= (1.-utmp*seltmp(j))*survtmp; Btmp  += Ntmp*wt(j+1)*seltmp(j+1); Stmp  += .5 * Ntmp *wt(j+1)*maturity(j+1); } //Max Age - 1 yr yield   += utmp * Btmp; Ntmp    /= (1-survtmp*(1.-utmp*seltmp(nages))); Btmp    += Ntmp*wt(nages)*seltmp(nages); Stmp    += 0.5 *wt(nages)* Ntmp *maturity(nages); yield   += utmp * Btmp; //cout<<yield<<\" \"<<Stmp<<\" \"<<Btmp<<\" \";*/\n  dvariable phi;\n  dvariable Req;\n  dvar_vector Ntmp(1,nages);\n  dvar_vector Ctmp(1,nages);\n  dvariable   yield;\n  yield.initialize();\n\n  dvar_matrix seltmp(1,nfsh,1,nages);\n  for (k=1;k<=nfsh;k++)\n   seltmp(k) = sel_fsh(k,endyr); // NOTE uses last-year of fishery selectivity for projections.\n\n  dvar_matrix Fatmp(1,nfsh,1,nages);\n  dvar_vector Ztmp(1,nages);\n\n  Ztmp = M(styr);\n  for (k=1;k<=nfsh;k++)\n  { \n    Fatmp(k) = Fratio(k) * Ftmp * seltmp(k);\n    Ztmp    += Fatmp(k);\n  } \n  dvar_vector survtmp = mfexp(-Ztmp);\n\n  Ntmp(1) = 1.;\n  for ( j=1 ; j < nages; j++ )\n    Ntmp(j+1)  =   Ntmp(j) * survtmp(j); // Begin numbers in the next year/age class\n  Ntmp(nages)  /= (1.- survtmp(nages)); \n\n  for (k=1;k<=nfsh;k++)\n  {\n    Ctmp.initialize();\n    for ( j=1 ; j <= nages; j++ )\n      Ctmp(j)      = Ntmp(j) * Fatmp(k,j) * (1. - survtmp(j)) / Ztmp(j);\n\n    yield  += wt_fsh(k,endyr) * Ctmp;\n  }\n  phi    = elem_prod( Ntmp , pow(survtmp,spmo_frac ) )* wt_mature;\n  // Req    = Requil(phi) * mfexp(sigmarsq/2);\n  Req    = Requil(phi) ;\n  yield *= Req;\n\n  RETURN_ARRAYS_DECREMENT();\n  return yield;\n\nFUNCTION dvariable yield(const dvar_vector& Fratio, dvariable& Ftmp, dvariable& Stmp,dvariable& Req)\n  RETURN_ARRAYS_INCREMENT();\n  dvariable phi;\n  dvar_vector Ntmp(1,nages);\n  dvar_vector Ctmp(1,nages);\n  dvariable   yield   = 0.;\n\n  dvar_matrix seltmp(1,nfsh,1,nages);\n  for (k=1;k<=nfsh;k++)\n   seltmp(k) = sel_fsh(k,endyr); // NOTE uses last-year of fishery selectivity for projections.\n\n  dvar_matrix Fatmp(1,nfsh,1,nages);\n  dvar_vector Ztmp(1,nages);\n\n  Ztmp = M(styr);\n  for (k=1;k<=nfsh;k++)\n  { \n    Fatmp(k) = Fratio(k) * Ftmp * seltmp(k);\n    Ztmp    += Fatmp(k);\n  } \n  dvar_vector survtmp = mfexp(-Ztmp);\n\n  Ntmp(1) = 1.;\n  for ( j=1 ; j < nages; j++ )\n    Ntmp(j+1)  =   Ntmp(j) * survtmp(j); // Begin numbers in the next year/age class\n  Ntmp(nages)  /= (1.- survtmp(nages)); \n  for (k=1;k<=nfsh;k++)\n  {\n    Ctmp.initialize();\n    for ( j=1 ; j <= nages; j++ )\n      Ctmp(j)      = Ntmp(j) * Fatmp(k,j) * (1. - survtmp(j)) / Ztmp(j);\n    yield  += wt_fsh(k,endyr) * Ctmp;\n  }\n  phi    = elem_prod( Ntmp , pow(survtmp,spmo_frac ) )* wt_mature;\n  // Req    = Requil(phi) * exp(sigmarsq/2);\n  Req    = Requil(phi) ;\n  yield *= Req;\n  Stmp   = phi*Req;\n\n  RETURN_ARRAYS_DECREMENT();\n  return yield;\n\nFUNCTION Profile_F\n  /** NOTE THis will need to be conditional on SrType too Function calculates \n  used in calculating MSY and MSYL for a designated component of the\n  population, given values for stock recruitment and selectivity...  \n  Fmsy is the trial value of MSY example of the use of \"funnel\" to \n  reduce the amount of storage for derivative calculations \n  */\n  cout << \"Doing a profile over F....\"<<endl;\n  ofstream prof_F(\"Fprof.yld\");\n dvariable sumF=0.;\n  for (k=1;k<=nfsh;k++)\n    sumF += sum(F(k,endyr));\n  for (k=1;k<=nfsh;k++)\n    Fratio(k) = sum(F(k,endyr)) / sumF;\n  dvariable Stmp;\n  dvariable Rtmp;\n  double df=1.e-7;\n  dvariable F1=.05;\n  dvariable F2;\n  dvariable F3;\n  dvariable yld1;\n  dvariable yld2;\n  dvariable yld3;\n  dvariable dyld;\n  dvariable dyldp;\n  prof_F <<\"Profile of stock, yield, and recruitment over F\"<<endl;\n  prof_F << model_name<<\" \"<<datafile_name<<endl;\n  prof_F <<endl<<endl<<\"F  Stock  Yld  Recruit SPR\"<<endl;\n  prof_F <<0.0<<\" \"<< Bzero <<\" \"<<0.0<<\" \"<<Rzero<< \" 1.00\"<<endl; \n  dvar_vector ttt(1,5);\n  for (int ii=1;ii<=500;ii++)\n  {\n    F1    = double(ii)/500;\n    yld1  = yield(Fratio,F1,Stmp,Rtmp);\n    ttt   = yld(Fratio,F1);\n    prof_F <<F1<<\" \"<< ttt << endl; \n  } \n\nFUNCTION dvar_vector SRecruit(const dvar_vector& Stmp)\n  RETURN_ARRAYS_INCREMENT();\n  dvar_vector RecTmp(Stmp.indexmin(),Stmp.indexmax());\n  switch (SrType)\n  {\n    case 1:\n      RecTmp = elem_prod((Stmp / phizero) , mfexp( alpha * ( 1. - Stmp / Bzero ))) ; //Ricker form from Dorn\n      break;\n    case 2:\n      RecTmp = elem_prod(Stmp , 1. / ( alpha + beta * Stmp));        //Beverton-Holt form\n      break;\n    case 3:\n      RecTmp = mfexp(mean_log_rec);                    //Avg recruitment\n      break;\n    case 4:\n      RecTmp = elem_prod(Stmp , mfexp( alpha  - Stmp * beta)) ; //Old Ricker form\n      break;\n  }\n  RETURN_ARRAYS_DECREMENT();\n  return RecTmp;\n\nFUNCTION dvariable SRecruit(const double& Stmp)\n  RETURN_ARRAYS_INCREMENT();\n  dvariable RecTmp;\n  switch (SrType)\n  {\n    case 1:\n      RecTmp = (Stmp / phizero) * mfexp( alpha * ( 1. - Stmp / Bzero )) ; //Ricker form from Dorn\n      break;\n    case 2:\n      RecTmp = Stmp / ( alpha + beta * Stmp);        //Beverton-Holt form\n      break;\n    case 3:\n      RecTmp = mfexp(mean_log_rec);                    //Avg recruitment\n      break;\n    case 4:\n      RecTmp = Stmp * mfexp( alpha  - Stmp * beta) ; //old Ricker form\n      break;\n  }\n  RETURN_ARRAYS_DECREMENT();\n  return RecTmp;\n\nFUNCTION dvariable SRecruit(const dvariable& Stmp)\n  RETURN_ARRAYS_INCREMENT();\n  dvariable RecTmp;\n  switch (SrType)\n  {\n    case 1:\n      RecTmp = (Stmp / phizero) * mfexp( alpha * ( 1. - Stmp / Bzero )) ; //Ricker form from Dorn\n      break;\n    case 2:\n      RecTmp = Stmp / ( alpha + beta * Stmp);        //Beverton-Holt form\n      break;\n    case 3:\n      RecTmp = mfexp(mean_log_rec );                    //Avg recruitment\n      break;\n    case 4:\n      RecTmp = Stmp * mfexp( alpha  - Stmp * beta) ; //old Ricker form\n      break;\n  }\n  RETURN_ARRAYS_DECREMENT();\n  return RecTmp;\n\nFUNCTION Get_Bzero\n  /** Get the value of B zero */ \n  Bzero.initialize();\n  Rzero    =  mfexp(log_Rzero); \n\n  dvar_vector survtmp(1,nages);\n  survtmp = mfexp(-M(styr));\n\n  dvar_matrix natagetmp(styr_rec,styr,1,nages);\n  natagetmp.initialize();\n\n  natagetmp(styr_rec,1) = Rzero;\n  for (j=2; j<=nages; j++)\n    natagetmp(styr_rec,j) = natagetmp(styr_rec,j-1) * survtmp(j-1);\n  natagetmp(styr_rec,nages) /= (1.-survtmp(nages)); \n\n  Bzero = elem_prod(wt_mature , pow(survtmp,spmo_frac))*natagetmp(styr_rec) ;\n  phizero = Bzero/Rzero;\n\n  switch (SrType)\n  {\n    case 1:\n      alpha = log(-4.*steepness/(steepness-1.));\n      break;\n    case 2:\n    {\n      alpha  =  Bzero * (1. - (steepness - 0.2) / (0.8*steepness) ) / Rzero;\n      beta   = (5. * steepness - 1.) / (4. * steepness * Rzero);\n    }\n    break;\n    case 4:\n    {\n      beta  = log(5.*steepness)/(0.8*Bzero) ;\n      alpha = log(Rzero/Bzero)+beta*Bzero;\n    }\n      break;\n  }\n  Sp_Biom.initialize();\n  Sp_Biom(styr_sp,styr_rec-1) = Bzero;\n  for (i=styr_rec;i<styr;i++)\n  {\n    Sp_Biom(i) = elem_prod(natagetmp(i),pow(survtmp,spmo_frac)) * wt_mature; \n    // natagetmp(i,1)          = mfexp(rec_dev(i) + log_Rzero); // OjO numbers a function of mean not SR curve...\n\t\trecruits(i)             = mfexp(rec_dev(i) + mean_log_rec);\n    natagetmp(i,1)          = recruits(i);\n    natagetmp(i+1)(2,nages) = ++elem_prod(natagetmp(i)(1,nages-1),mfexp(-M(styr)(1,nages-1)) );\n    natagetmp(i+1,nages)   += natagetmp(i,nages)*mfexp(-M(styr,nages));\n  }\n  // This sets first year recruitment as deviation from mean recruitment (since SR curve can\n  // be defined for different periods and is treated semi-independently)\n  natagetmp(styr,1)   = mfexp(rec_dev(styr) + mean_log_rec);\n  mod_rec(styr_rec,styr) = column(natagetmp,1);\n  natage(styr)  = natagetmp(styr); // OjO\n  Sp_Biom(styr) = elem_prod(natagetmp(styr),pow(survtmp,spmo_frac)) * wt_mature; \n\nFUNCTION dvariable Requil(dvariable& phi)\n  RETURN_ARRAYS_INCREMENT();\n  dvariable RecTmp;\n  switch (SrType)\n  {\n    case 1:\n      RecTmp =  Bzero * (alpha + log(phi) - log(phizero) ) / (alpha*phi);\n      break;\n    case 2:\n      RecTmp =  (phi-alpha)/(beta*phi);\n      break;\n    case 3:\n      RecTmp =  mfexp(mean_log_rec);\n      break;\n    case 4:\n      RecTmp =  (log(phi)+alpha) / (beta*phi); //RecTmp =  (log(phi)/alpha + 1.)*beta/phi;\n      break;\n  }\n  // Req    = Requil(phi) * exp(sigmarsq/2);\n  // return RecTmp* exp(sigmarsq/2);\n  RETURN_ARRAYS_DECREMENT();\n  return RecTmp;\n\nFUNCTION write_mceval_hdr\n    for (k=1;k<=nind;k++)\n      mceval<< \" model Obj_Fun q_ind_\"<< k<< \" \";\n    mceval<<\"M steepness depletion MSY MSYL Fmsy Fcur_Fmsy Bcur_Bmsy Bmsy totbiom_\"<<endyr<<\" \"<< \n    \" F35          \"<< \n    \" F40          \"<< \n    \" F50          \"<< \n    \" fut_SPB_Fmsy_\"<< endyr_fut<<\" \"<< \n    \" fut_SPB_F50%_\"<< endyr_fut<<\" \"<< \n    \" fut_SPB_F40%_\"<< endyr_fut<<\" \"<< \n    \" fut_SPB_F35%_\"<< endyr_fut<<\" \"<< \n    \" fut_SPB_F0_\"  << endyr_fut<<\" \"<< \n    \" fut_catch_Fmsy_\"<<styr_fut<<\" \"<<  \n    \" fut_catch_F50%_\"<<styr_fut<<\" \"<<  \n    \" fut_catch_F40%_\"<<styr_fut<<\" \"<<  \n    \" fut_catch_F35%_\"<<styr_fut<<\" \"<<  endl;\n\n//+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+ \nREPORT_SECTION\n  if (last_phase())\n  {\n    save_gradients(gradients);\n    int nvar1=initial_params::nvarcalc(); // get the number of active parameters\n    int ndvar=stddev_params::num_stddev_calc();\n    int offset=1;\n    dvector param_values(1,nvar1+ndvar);\n    initial_params::copy_all_values(param_values,offset);\n    for (int i=0;i<initial_params::num_initial_params;i++)\n    {\n      // cout << \"# \" << initial_params::varsptr[i]->label() << \"\\n\" << endl; \n      if (withinbound(0,(initial_params::varsptr[i])->phase_start, initial_params::current_phase))\n      {\n        int sc = (initial_params::varsptr[i])->size_count();\n        if (sc>0)\n        {\n          // write_input_log << \"# \" << initial_params::varsptr[i]->label() << endl<<param_values(i)<<\"\\n\" << endl; \n        } \n      }\n    }\n  //--------------------------------------------------------\n  //  Write cumulative likelihoods for main data parts\n  // Count up number of columns\n\tint icum  = 0;\n\tint ncols = 0;\n  for (k=1;k<=nind;k++)\n\t{\n\t\tif (nyrs_ind(k)>0)\n\t\t  ncols++;\n    for (i=1;i<=nyrs_ind(k);i++)\n\t    icum++;\n\t}\n  for (k=1;k<=nfsh;k++)\n\t{\n\t\tif (nyrs_fsh_age(k)>0)\n\t\t  ncols++;\n    for (int i=1;i<=nyrs_fsh_age(k);i++)\n\t    icum++;\n\t}\n  for (k=1;k<=nind;k++)\n\t{\n\t\tif (nyrs_ind_length(k)>0)\n\t\t  ncols++;\n    for (int i=1;i<=nyrs_ind_length(k);i++)\n\t    icum++;\n\t\tif (nyrs_ind_age(k)>0)\n\t\t  ncols++;\n    for (int i=1;i<=nyrs_ind_age(k);i++)\n\t    icum++;\n\t}\n  //--------------------------------------------------------\n  dmatrix cum_NLL(styr,endyr,1,ncols);\n  cum_NLL.initialize();\n\n  // Fit to indices (log-Normal) -------------------------------------------\n\tfor (int iyr=styr+1; iyr<=endyr;iyr++)\n\t{\n\t\tint icol=0;\n    for (k=1;k<=nind;k++)\n\t\t{\n\t\t\ticol++;\n      for (i=1;i<=nyrs_ind(k);i++)\n      {\n        if( iyr == yrs_ind(k,i) )\n          cum_NLL(iyr,icol) += value(square(log(obs_ind(k,i)) - log(pred_ind(k,i)) ) / \n                                     (2.*obs_lse_ind(k,i)*obs_lse_ind(k,i)) );\n      }\n    }\n  \n    for (k=1;k<=nfsh;k++)\n\t\t{\n\t\t\tif(nyrs_fsh_age(k)>0)\n\t\t\t{\n\t\t\t\ticol++;\n        for (int i=1;i<=nyrs_fsh_age(k);i++)\n          if( iyr == yrs_fsh_age(k,i))\n\t\t\t\t\t{\n            cum_NLL(iyr,icol) -= value(n_sample_fsh_age(k,i)*(oac_fsh(k,i) + 0.001) * log(eac_fsh(k,i) + 0.001 )  );\n            cum_NLL(iyr,icol) +=      (n_sample_fsh_age(k,i)*(oac_fsh(k,i) + 0.001) * log(oac_fsh(k,i) + 0.001 )  );\n\t\t\t\t\t}\n      }\n    }\n  \n    for (k=1;k<=nfsh;k++)\n\t\t\tif(nyrs_fsh_length(k)>0)\n\t\t\t{\n\t\t\t  icol++;\n        for (int i=1;i<=nyrs_fsh_length(k);i++)\n          if( iyr == yrs_fsh_length(k,i))\n\t\t\t\t\t{\n            cum_NLL(iyr,icol) -= value(n_sample_fsh_length(k,i)*(olc_fsh(k,i) + 0.001) * log(elc_fsh(k,i) + 0.001 ) );\n            cum_NLL(iyr,icol) +=      (n_sample_fsh_length(k,i)*(olc_fsh(k,i) + 0.001) * log(olc_fsh(k,i) + 0.001 ) );\n\t\t\t    }\n\t\t\t}\n    //----------------------------------------------------------\n    for (k=1;k<=nind;k++)\n\t\t{\n\t\t\tif(nyrs_ind_length(k)>0)\n\t\t\t{\n\t\t\t  icol++;\n        for (int i=1;i<=nyrs_ind_length(k);i++)\n          if( iyr == yrs_ind_length(k,i))\n\t\t\t\t\t{\n            cum_NLL(iyr,icol) -= value(n_sample_ind_length(k,i)*(olc_ind(k,i) + 0.001) * log(elc_ind(k,i) + 0.001 ) );\n            cum_NLL(iyr,icol) +=      (n_sample_ind_length(k,i)*(olc_ind(k,i) + 0.001) * log(olc_ind(k,i) + 0.001 ) );\n\t\t\t    }\n\t\t\t}\n\t  }\n  \n    //----------------------------------------------------------\n    for (k=1;k<=nind;k++)\n\t  {\n\t\t\tif(nyrs_ind_age(k)>0)\n\t\t\t{\n\t\t\t  icol++;\n        for (int i=1;i<=nyrs_ind_age(k);i++)\n          if( iyr == yrs_ind_age(k,i))\n\t\t\t    {\n            cum_NLL(iyr,icol) -= value(n_sample_ind_age(k,i)*(oac_ind(k,i) + 0.001) * log(eac_ind(k,i) + 0.001 ) );\n            cum_NLL(iyr,icol) +=      (n_sample_ind_age(k,i)*(oac_ind(k,i) + 0.001) * log(oac_ind(k,i) + 0.001 ) );\n\t\t\t    }\n\t\t\t}\n\t\t}\n\t\tif(iyr<endyr)\n      cum_NLL(iyr+1) = cum_NLL(iyr) ; \n\t}\n  ofstream cum_like(\"cum_NLL.rep\");\n\treport<<\"Cumulative likelihoods\"<<endl;\n\tfor (int iyr=styr+1; iyr<=endyr;iyr++)\n\t{\n\t\tcum_like<< iyr<<\" \"<<cum_NLL(iyr)<<endl;\n\t\treport<< iyr<<\" \"<<cum_NLL(iyr)<<endl;\n\t}\n  //----------------------------------------------------------\n    if (!Popes)\n      for (k=1;k<=nfsh;k++)\n        Ftot += F(k);\n    log_param(Mest);\n    log_param(mean_log_rec);\n    log_param(steepness);\n    log_param(log_Rzero);\n    log_param(rec_dev);\n    log_param(log_sigmar);\n    log_param(fmort);\n    // log_param(log_selcoffs_fsh);\n    // log_param(log_sel_spl_fsh);\n    // log_param(logsel_slope_fsh);\n    // log_param(sel50_fsh);\n    // log_param(logsel_dslope_fsh);\n    // log_param(seld50_fsh);\n    log_param(rec_dev_future);\n    // log_param(log_q_ind);\n    // log_param(log_q_power_ind);\n    // log_param(log_selcoffs_ind);\n    // log_param(logsel_slope_ind);\n    // log_param(logsel_dslope_ind);\n    // log_param(sel50_ind);\n    // log_param(seld50_ind);\n  }\n    \n  if (oper_mod)\n    Oper_Model();\n\n  cout <<\"===============================================================\"<<endl;\n  if(last_phase())\n    cout<<\"||  ++++++ Completed phase \"<<current_phase()<<\" In last phase now +++++\"<< endl<<\"||\"<<endl<<\"||  \"<<cntrlfile_name <<endl;\n  else\n    cout<<\"||  ++++++ Completed phase \"<<current_phase()<<\" ++++++++++++++++\"<< endl<<\"||\"<<endl<<\"||  \"<<cntrlfile_name <<endl;\n  cout<<\"||\"<<endl<<\"||\"<<endl;\n  cout <<\"_______________________________________________________________\"<<endl;\n    adstring comma = adstring(\",\"); \n    report << model_name<<\" \"<< endl<< endl;\n    report << \"Estimated annual F's \" << endl;\n    Fmort.initialize();\n    for (k=1;k<=nfsh;k++)\n      for (i=styr;i<=endyr;i++) \n        Fmort(i) += mean(F(k,i));\n    report << Fmort<<endl;\n    report << \"Total mortality (Z)\"<<endl;\n    report << Z<<endl;\n    report << \"Estimated numbers of fish \" << endl;\n    for (i=styr;i<=endyr;i++) \n      report <<\"       Year: \"<< i << \" \"<< natage(i) << endl;\n    report << endl<< \"Estimated F mortality \" << endl;\n    for (k=1;k<=nfsh;k++)\n    {\n      report << \"Fishery \"<< k <<\" : \"<< endl ;\n      for (i=styr;i<=endyr;i++) \n        report << \"        Year: \"<<i<<\" \"<<F(k,i)<<  \" \"<< endl;\n    }\n\n    report << endl<< \"survey q \" << endl;\n    report <<q_ind<<endl;\n    report << endl<< \"Observed survey values \" << endl;\n    for (k=1;k<=nind;k++)\n    {\n      int ii=1;\n      report <<endl<< \"Yr_Obs_Pred_Survey \"<< k <<\" : \"<< endl ;\n      for (int iyr=styr;iyr<=endyr;iyr++)\n      {\n        dvariable pred_tmp ;\n        if (ii<=nyrs_ind(k))\n        {\n          pred_tmp = q_ind(k,ii) * pow(elem_prod(natage(iyr),pow(S(iyr),ind_month_frac(k))) * \n                        elem_prod(sel_ind(k,iyr) , wt_ind(k,iyr)),q_power_ind(k));\n          if (yrs_ind(k,ii)==iyr)\n          {\n            report << iyr<< \" \"<< \n                     obs_ind(k,ii) << \" \"<< pred_tmp <<endl;\n            ii++;\n          }\n          else\n            report << iyr<< \" -1 \"<< \" \"<< pred_tmp   <<endl;\n        }\n      }\n    }\n\n    report << endl<< \"Survey_Q:  \"<<q_ind << endl;\n\n    report << endl<< \"Observed Prop \" << endl;\n    for (k=1;k<=nfsh;k++)\n    {\n      report << \"ObsFishery \"<< k <<\" : \"<< endl ;\n      for (i=1;i<=nyrs_fsh_age(k);i++) \n        report << yrs_fsh_age(k,i)<< \" \"<< oac_fsh(k,i) << endl;\n    }\n    report << endl<< \"Predicted prop  \" << endl;\n    for (k=1;k<=nfsh;k++)\n    {\n      report << \"PredFishery \"<< k <<\" : \"<< endl;\n      for (i=1;i<=nyrs_fsh_age(k);i++) \n        report << yrs_fsh_age(k,i)<< \" \"<< eac_fsh(k,i) << endl;\n    }\n    for (k=1;k<=nfsh;k++)\n    {\n      report << \"Pobs_length_fishery_\"<< (k) <<\"\"<< endl;\n      for (i=1;i<=nyrs_fsh_length(k);i++) \n        report << yrs_fsh_length(k,i)<< \" \"<< olc_fsh(k,i) << endl;\n      report   << endl;\n    }\n    for (k=1;k<=nfsh;k++)\n    {\n      report << \"Pred_length_fishery_\"<< (k) <<\"\"<< endl;\n      for (i=1;i<=nyrs_fsh_length(k);i++) \n        report << yrs_fsh_length(k,i)<< \" \"<< elc_fsh(k,i) << endl;\n      report   << endl;\n    }\n    report << endl<< \"Observed prop Survey\" << endl;\n    for (k=1;k<=nind;k++)\n    {\n      report << \"ObsSurvey \"<<k<<\" : \"<<  endl;\n      for (i=1;i<=nyrs_ind_age(k);i++) \n        report << yrs_ind_age(k,i)<< \" \"<< oac_ind(k,i) << endl;\n    }\n    report << endl<< \"Predicted prop Survey\" << endl;\n    for (k=1;k<=nind;k++)\n    {\n      report << \"PredSurvey \"<<k<<\" : \"<<  endl;\n      for (i=1;i<=nyrs_ind_age(k);i++) \n        report << yrs_ind_age(k,i)<< \" \"<< eac_ind(k,i) << endl;\n    }\n    report << endl<< \"Observed catch biomass \" << endl;\n    report << catch_bio << endl;\n    report << \"predicted catch biomass \" << endl;\n    report << pred_catch << endl;\n\n    report << endl<< \"Estimated annual fishing mortality \" << endl;\n    for (k=1;k<=nfsh;k++)\n      report << \" Average_F_Fshry_\"<<k<< \" Full_selection_F_Fshry_\"<<k;\n\n    report << endl;\n    for (i=styr;i<=endyr;i++)\n    {\n      report<< i<< \" \";\n      for (k=1;k<=nfsh;k++)\n        report<< mean(F(k,i)) <<\" \"<< mean(F(k,i))*max(sel_fsh(k,i)) << \" \";\n\n      report<< endl;\n    }\n    report << endl<< \"Selectivity\" << endl;\n    for (k=1;k<=nfsh;k++)\n      for (i=styr;i<=endyr;i++)\n        report << \"Fishery \"<< k <<\"  \"<< i<<\" \"<<sel_fsh(k,i) << endl;\n    for (k=1;k<=nind;k++)\n      for (i=styr;i<=endyr;i++)\n        report << \"Survey  \"<< k <<\"  \"<< i<<\" \"<<sel_ind(k,i) << endl;\n\n    report << endl<< \"Stock Recruitment stuff \"<< endl;\n    for (i=styr_rec;i<=endyr;i++)\n      if (active(log_Rzero))\n        report << i<< \" \"<<Sp_Biom(i-rec_age)<< \" \"<< SRecruit(Sp_Biom(i-rec_age))<< \" \"<< mod_rec(i)<<endl;\n      else \n        report << i<< \" \"<<Sp_Biom(i-rec_age)<< \" \"<< \" 999\" << \" \"<< mod_rec(i)<<endl;\n\n    report << endl<< \"Curve to plot \"<< endl;\n    report <<\"stock Recruitment\"<<endl;\n    report <<\"0 0 \"<<endl;\n    dvariable stock;\n    for (i=1;i<=30;i++)\n    {\n      stock = double (i) * Bzero /25.;\n      if (active(log_Rzero))\n        report << stock <<\" \"<< SRecruit(stock)<<endl;\n      else\n        report << stock <<\" 99 \"<<endl;\n    }\n\n    report   << endl<<\"Likelihood Components\" <<endl;\n    report   << \"----------------------------------------- \" <<endl;\n    report   << \"  catch_like  age_like_fsh sel_like_fsh ind_like age_like_ind sel_like_ind rec_like fpen post_priors_indq post_priors residual total\"<<endl;\n    report   << \" \"<<obj_comps<<endl;\n\n    obj_comps(13)= obj_fun - sum(obj_comps) ; // Residual \n    obj_comps(14)= obj_fun ;                  // Total\n    report   <<\"  catch_like       \"<<setw(10)<<obj_comps(1) <<endl\n             <<\"  age_like_fsh     \"<<setw(10)<<obj_comps(2) <<endl\n             <<\"  length_like_fsh  \"<<setw(10)<<obj_comps(3) <<endl\n             <<\"  sel_like_fsh     \"<<setw(10)<<obj_comps(4) <<endl\n             <<\"  ind_like        \"<<setw(10)<<obj_comps(5) <<endl\n             <<\"  length_like_ind  \"<<setw(10)<<obj_comps(6) <<endl\n             <<\"  age_like_ind     \"<<setw(10)<<obj_comps(6) <<endl\n             <<\"  sel_like_ind     \"<<setw(10)<<obj_comps(7) <<endl\n             <<\"  rec_like         \"<<setw(10)<<obj_comps(8) <<endl\n             <<\"  fpen             \"<<setw(10)<<obj_comps(9) <<endl\n             <<\"  post_priors_indq \"<<setw(10)<<obj_comps(10) <<endl\n             <<\"  post_priors      \"<<setw(10)<<obj_comps(11)<<endl\n             <<\"  residual         \"<<setw(10)<<obj_comps(12)<<endl\n             <<\"  total            \"<<setw(10)<<obj_comps(13)<<endl;\n\n    report   << endl;\n    report   << \"Fit to Catch Biomass \"<<endl;\n    report   << \"-------------------------\" <<endl;\n    for (k=1;k<=nfsh;k++)\n      report << \"  Catch_like_Fshry_#\"<< k <<\"  \"<< catch_like(k) <<endl;\n    report   << endl;\n\n    report << \"Age likelihoods for fisheries :\"<<endl;\n    report   << \"-------------------------\" <<endl;\n    for (k=1;k<=nfsh;k++)\n      report << \"  Age_like_Fshry_#\"<< k <<\"  \"<< age_like_fsh(k) <<endl;\n    report   << endl;\n\n    report   << \"Selectivity penalties for fisheries :\"<<endl;\n    report   << \"-------------------------\" <<endl;\n    report   << \"  Fishery Curvature_Age Change_Time Dome_Shaped\"<<endl;\n    for (k=1;k<=nfsh;k++)\n      report << \"  Sel_Fshry_#\"<< k <<\"  \"<< sel_like_fsh(k,1) <<\" \"<<sel_like_fsh(k,2)<<\" \"<<sel_like_fsh(k,3)<< endl;\n    report   << endl;\n  \n    report   << \"survey Likelihood(s) \" <<endl;\n    report   << \"-------------------------\" <<endl;\n    for (k=1;k<=nind;k++)\n      report << \"  Survey_Index_#\"<< k <<\"  \" << ind_like(k)<<endl;\n    report   << endl;\n\n    report << setw(10)<< setfixed() << setprecision(5) <<endl;\n    report   << \"Age likelihoods for surveys :\"<<endl;\n    report   << \"-------------------------\" <<endl;\n    for (k=1;k<=nind;k++)\n      report << \"  Age_Survey_#\"<< k <<\"  \" << age_like_ind(k)<<endl;\n    report   << endl;\n\n    report   << \"Selectivity penalties for surveys :\"<<endl;\n    report   << \"-------------------------\" <<endl;\n    report   << \"  Survey Curvature_Age Change_Time Dome_Shaped\"<<endl;\n    for (k=1;k<=nind;k++)\n      report << \"  Sel_Survey_#\"<< k <<\"  \"<< sel_like_ind(k,1) <<\" \"<<sel_like_ind(k,2)<<\" \"<<sel_like_ind(k,3)<< endl;\n    report   << endl;\n\n    report << setw(10)<< setfixed() << setprecision(5) <<endl;\n    report   << \"Recruitment penalties: \" <<rec_like<<endl;\n    report   << \"-------------------------\" <<endl;\n    report   << \"  (sigmar)            \" <<sigmar<<endl;\n    report   << \"  S-R_Curve           \" <<rec_like(1)<< endl;\n    report   << \"  Regularity          \" <<rec_like(2)<< endl;\n    report   << \"  Future_Recruits     \" <<rec_like(3)<< endl;\n    report   << endl;\n\n    report   << \"F penalties:          \" <<endl;\n    report   << \"-------------------------\" <<endl;\n    report   << \"  Avg_F               \" <<fpen(1) <<endl;\n    report   << \"  Effort_Variability  \" <<fpen(2) <<endl;\n    report   << endl;\n\n    report   << \"Contribution of Priors:\"<<endl;\n    report   << \"-------------------------\" <<endl;\n    report   << \"Source                \";\n    report   <<           \" Posterior\";\n    report   <<           \" Param_Val\";\n    report   <<           \" Prior_Val\";\n    report   <<           \"  CV_Prior\"<<endl;\n  // (*ad_printf)(\"f = %lf\\n\",value(f));\n    for (k=1;k<=nind;k++)\n    {\n      report << \"Q_Survey_#\"<< k <<\"           \"\n             << setw(10)<<post_priors_indq(k) \n             << setw(10)<< q_ind(k)\n             << setw(10)<< qprior(k)\n             << setw(10)<< cvqprior(k)<<endl;\n\n      report << \"Q_power_Survey_#\"<< k <<\"           \"\n             << setw(10)<<post_priors_indq(k) \n             << setw(10)<< q_power_ind(k)\n             << setw(10)<< q_power_prior(k)\n             << setw(10)<< cvq_power_prior(k)<<endl;\n    }\n\n    // writerep(post_priors(1),repstring);\n    // cout <<repstring<<endl;\n    report   << \"Natural_Mortality     \"\n             << setw(10)<< post_priors(1)\n             << setw(10)<< M\n             << setw(10)<< natmortprior\n             << setw(10)<< cvnatmortprior <<endl;\n    report   << \"Steepness             \"\n             << setw(10)<< post_priors(2)\n             << setw(10)<< steepness\n             << setw(10)<< steepnessprior\n             << setw(10)<< cvsteepnessprior <<endl;\n    report   << \"SigmaR                \"\n             << setw(10)<< post_priors(3)\n             << setw(10)<< sigmar\n             << setw(10)<< sigmarprior\n             << setw(10)<< cvsigmarprior <<endl;\n    report   << endl;\n    report<<\"Num_parameters_Estimated \"<<initial_params::nvarcalc()<<endl;\n    \n  report <<cntrlfile_name<<endl;\n  report <<datafile_name<<endl;\n  report <<model_name<<endl;\n  if (SrType==2) \n    report<< \"Beverton-Holt\" <<endl;\n  else\n    report<< \"Ricker\" <<endl;\n  report<<\"Steepnessprior,_CV,_phase: \" <<steepnessprior<<\" \"<<\n    cvsteepnessprior<<\" \"<<\n    phase_srec<<\" \"<< endl;\n\n  report<<\"sigmarprior,_CV,_phase: \" <<sigmarprior<<\" \"<<  cvsigmarprior <<\" \"<<phase_sigmar<<endl;\n\n  report<<\"Rec_estimated_in_styr_endyr: \" <<styr_rec    <<\" \"<<endyr        <<\" \"<<endl;\n  report<<\"SR_Curve_fit__in_styr_endyr: \" <<styr_rec_est<<\" \"<<endyr_rec_est<<\" \"<<endl;\n  report<<\"Model_styr_endyr:            \" <<styr        <<\" \"<<endyr        <<\" \"<<endl;\n\n  report<<\"M_prior,_CV,_phase \"<< natmortprior<< \" \"<< cvnatmortprior<<\" \"<<phase_M<<endl;\n  report<<\"qprior,_CV,_phase \" <<qprior<<\" \"<<cvqprior<<\" \"<< phase_q<<endl;\n  report<<\"q_power_prior,_CV,_phase \" <<q_power_prior<<\" \"<<cvq_power_prior<<\" \"<< phase_q_power<<endl;\n\n  report<<\"cv_catchbiomass: \" <<cv_catchbiomass<<\" \"<<endl;\n  report<<\"Projection_years \"<< nproj_yrs<<endl;\n  for (k=1;k<=nfsh;k++)\n    report << \"Fsh_sel_opt_fish: \"<<k<<\" \"<<fsh_sel_opt(k)<<\" \"<<sel_change_in_fsh(k)<<endl;\n  for (k=1;k<=nind;k++)\n    report<<\"Survey_Sel_Opt_Survey: \" <<k<<\" \"<<(ind_sel_opt(k))<<endl;\n    \n  report <<\"Phase_survey_Sel_Coffs: \"<<phase_selcoff_ind<<endl; \n  report <<\"Fshry_Selages: \" << nselages_in_fsh  <<endl;\n  report <<\"Survy_Selages: \" << nselages_in_ind <<endl;\n  report << \"Phase_for_age-spec_fishery \"<<phase_selcoff_fsh<<endl;\n  report << \"Phase_for_logistic_fishery \"<<phase_logist_fsh<<endl;\n  report << \"Phase_for_dble_logistic_fishery \"<<phase_dlogist_fsh<<endl;\n  report << \"Phase_for_age-spec_survey  \"<<phase_selcoff_ind<<endl;\n  report << \"Phase_for_logistic_survey  \"<<phase_logist_ind<<endl;\n  report << \"Phase_for_dble_logistic_indy \"<<phase_dlogist_ind<<endl;\n\n  for (k=1; k<=nfsh;k++)\n  {\n    report <<\"Number_of_select_changes_fishery: \"<<k<<\" \"<<n_sel_ch_fsh(k)<<endl;\n    report<<\"Yrs_fsh_sel_change: \"<<yrs_sel_ch_fsh(k)<<endl;\n    report << \"sel_change_in: \"<<sel_change_in_fsh(k) << endl;\n  }\n  for (k=1; k<=nind;k++)\n  {\n    report <<\"Number_of_select_changes_survey: \"<<k<<\" \"<<n_sel_ch_ind(k)<<endl;\n    report<<\"Yrs_ind_sel_change: \"<<yrs_sel_ch_ind(k)<<endl;\n    report << \"sel_change_in: \"<<sel_change_in_ind(k) << endl;\n  }\n\nFUNCTION write_msy_out\n  ofstream msyout(\"msyout.dat\");\n  msyout << \" # Natural Mortality       \" <<endl;\n  for (j=1;j<=nages;j++) \n    msyout <<M <<\" \";\n  msyout <<endl;\n  msyout << spawnmo<< \"  # Spawnmo                   \" <<endl;\n  msyout <<\"# Wt spawn\"<<endl<< wt_pop<< endl;\n  msyout <<\"# Wt fish\"<<endl;\n  for (k=1;k<=nfsh;k++) \n    msyout <<wt_fsh(k,endyr)<< \" \";\n  msyout <<endl;\n  msyout <<\"# Maturity\"<<endl<< maturity<< endl;\n  msyout <<\"# selectivity\"<<endl;\n  for (k=1;k<=nfsh;k++) \n    msyout<< sel_fsh(k,endyr) <<\" \";\n  msyout<< endl;\n  msyout<<\"Srec_Option \"<<SrType<< endl;\n  msyout<<\"Alpha \"<<alpha<< endl;\n  msyout<<\"beta \"<<beta<< endl;\n  msyout<<\"steepness \"<<steepness<< endl;\n  msyout<<\"Bzero \"<<Bzero<< endl;\n  msyout<<\"Rzero \"<<Rzero<< endl;\n\n\n// Function to write out data file for projection model....just an output for alternative projections\nFUNCTION write_proj\n  ofstream projout( projfile_name );\n// Function to write out data file for projection model....\n projout << \"#model_name\"<<endl;\n projout << model_name<<endl;\n projout <<\"1    # SSLn species...\"<<endl;\n projout <<\"0    # Buffer of Dorn\"<<endl;\n projout <<nfsh<< \"    # Number of fsheries\"<<endl;\n projout <<\"1    # Number of sexes\"<<endl;\n dvariable sumF=0.;\n dmatrix seltmp(1,nfsh,1,nages) ;\n seltmp.initialize();\n Fratio.initialize();\n for (i = endyr-4;i<=endyr;i++) \n   for (k=1;k<=nfsh;k++)\n   {\n     Fratio(k) += (mean(F(k,i))) ;\n     sumF      += Fratio(k) ;\n     seltmp(k) += value(sel_fsh(k,i));\n   }\n sumF /= 5.;\n seltmp /= 5.;\n for (k=1;k<=nfsh;k++) seltmp(k) /= max(seltmp(k));\n projout << sumF << \"  # averagei 5yr f                  \" <<endl;\n // projout << mean(Fmort(endyr_r-4,endyr_r))<<\"  # averagei 5yr f                  \" <<endl;\n projout << \" 1  # author f                  \" <<endl;\n projout <<\" 0.4  # ABC SPR        \"<<endl;\n projout <<\" 0.35 # MSY/OFL SPR    \"<<endl;\n projout << \"# Spawnmo  \"<<endl<<spawnmo <<endl;\n projout <<nages<< \" # Number of ages\" <<endl;\n projout << \"# Fratio\"<<endl<<Fratio/sum(Fratio) <<endl;\n projout <<M(endyr) << \" # Natural Mortality       \" <<endl;\n projout <<\"# Maturity\"<<endl<< maturity/max(maturity)<< endl;\n projout <<\"# Wt spawn\"<<endl<< wt_pop     << endl;\n projout <<\"# Wt fsh\"<<endl; for (k=1;k<=nfsh;k++) projout << wt_fsh(k,endyr)<<endl;\n projout <<\"# selectivity\"<<endl; for (k=1;k<=nfsh;k++) projout << seltmp(k)<<endl;\n projout <<\"# natage\"<<endl<< natage(endyr) << endl;\n projout <<\"#_N_recruitment_years (not including last 1 estimates)\"<<endl<<endyr-(1977+rec_age+1) << endl;\n projout <<\"#_Recruitment_start_at_1977_yearclass=1978_for_age_1_recruits\"<<yy(1977+rec_age,endyr-1-rec_age)<<endl;\n projout <<mod_rec(1977+rec_age,endyr-1-rec_age)<< endl;\n // projout <<\"# Nrec\"<<endl<< endyr-1978<< endl;\n // projout <<\"# rec\"<<endl<< pred_rec(1978,endyr) << endl;\n projout <<\"# SpawningBiomass\"<<endl; // << Sp_Biom(1978-1,endyr-1) << endl;\n projout <<Sp_Biom(1977+rec_age,endyr-1-rec_age)<< endl;\n projout.close();\n\t\n\nFUNCTION write_projout\n// Function to write out data file for projection model....\n  ofstream projout( projfile_name );\n  \n  projout <<\"# \"<<model_name <<\" \"<< projfile_name<<endl;\n  projout <<\"123  # seed\"<<endl;\n  // Flag to tell if this is a SSL species                 \n  projout << \"1 # Flag to tell if this is a SSL forage species                 \"<<endl;\n  projout << \"0 # Flag to Dorn's version of a constant buffer                  \"<<endl;\n  // Flag to solve for F in first year or not 0==don't solve\n  projout<< \" 1 # Flag to solve for F in first year or not 0==don't solve\"<<endl;\n  // Flag to use 2nd-year catch/TAC\n  projout<< \"0 # Flag to use 2nd-year catch/TAC\"<<endl;\n  projout << nfsh<<\"   # Number of fisheries\"<<endl;\n  projout <<\"14   # Number of projection years\"<<endl;\n  projout <<\"1000 # Number of simulations\"<<endl;\n  projout <<endyr<< \" # Begin year of projection\" <<endl;\n  projout <<nages<< \" # Number of ages\" <<endl;\n  for (j=1;j<=nages;j++) \n    projout <<M(endyr,j) <<\" \";\n  projout << \" # Natural Mortality       \" <<endl;\n  double sumtmp;\n  sumtmp = 0.;\n  for (k=1;k<=nfsh;k++) \n    sumtmp += catch_bio(k,endyr);\n  projout << sumtmp<< \" # TAC in current year (assumed catch) \" <<endl;\n  projout << sumtmp<< \" # TAC in current year+1 (assumed catch) \" <<endl;\n  for (k=1;k<=nfsh;k++) \n    projout <<  F(k,endyr)/mean((F(k,endyr)))<<\" \"<<endl;\n   //  + fmort_dev(k,endyr)) /Fmort(endyr)<<\" \";\n\n  projout << \"   # Fratio                  \" <<endl;\n  dvariable sumF=0.;\n  for (k=1;k<=nfsh;k++)\n  {\n    Fratio(k) = sum(F(k,endyr)) ;\n    sumF += Fratio(k) ;\n  }\n  Fratio /= sumF;\n  projout << Fratio         <<endl;\n  projout <<\"  # average f\" <<endl;\n  projout << \" 1  # author f                  \" <<endl;\n  projout << spawnmo<< \"  # Spawnmo                   \" <<endl;\n  projout <<\"# Wt spawn\"<<endl<< wt_pop<< endl;\n  projout <<\"# Wt fish\"<<endl;\n  for (k=1;k<=nfsh;k++) \n    projout <<wt_fsh(k,endyr)<< \" \";\n  projout <<endl;\n  projout <<\"# Maturity\"<<endl<< maturity<< endl;\n  projout <<\"# selectivity\"<<endl;\n  for (k=1;k<=nfsh;k++) \n    projout<< sel_fsh(k,endyr) <<\" \"<<endl;\n  projout<< endl;\n  projout <<\"# natage\"<<endl<< natage(endyr) << endl;\n  if (styr<(1977-rec_age-1))\n  {\n    projout <<\"#_N_recruitment_years (not including last 1 estimates)\"<<endl<<endyr-(1977+rec_age+1) << endl;\n    projout <<\"#_Recruitment_start_at_1977_yearclass=1978_for_age_1_recruits\"<<yy(1977+rec_age,endyr-1)<<endl<<mod_rec(1977+rec_age,endyr-1)<< endl;\n  }\n\nFINAL_SECTION\n  /** Final section to compute projection input and profiles (over F) */\n  // Calc_Dependent_Vars();\n  // write_proj();\n  // write_projout();\n  // write_msy_out();\n  Profile_F();\n  Write_R();\nFUNCTION dvariable get_spr_rates(double spr_percent)\n  /**  Get the SPR rates given spr_percent */\n  RETURN_ARRAYS_INCREMENT();\n  dvar_matrix sel_tmp(1,nages,1,nfsh);\n  sel_tmp.initialize();\n  for (k=1;k<=nfsh;k++)\n    for (j=1;j<=nages;j++)\n      sel_tmp(j,k) = sel_fsh(k,endyr,j); // NOTE uses last-year of fishery selectivity for projections.\n  dvariable sumF=0.;\n  for (k=1;k<=nfsh;k++)\n  {\n    Fratio(k) = sum(F(k,endyr)) ;\n    sumF += Fratio(k) ;\n  }\n  Fratio /= sumF;\n  double df=1.e-3;\n  dvariable F1 ;\n  F1.initialize();\n  F1 = .8*natmortprior;\n  dvariable F2;\n  dvariable F3;\n  dvariable yld1;\n  dvariable yld2;\n  dvariable yld3;\n  dvariable dyld;\n  dvariable dyldp;\n  // Newton Raphson stuff to go here\n  for (int ii=1;ii<=6;ii++)\n  {\n    F2     = F1 + df;\n    F3     = F1 - df;\n    yld1   = -1000*square(log(spr_percent/spr_ratio(F1, sel_tmp,styr)));\n    yld2   = -1000*square(log(spr_percent/spr_ratio(F2, sel_tmp,styr)));\n    yld3   = -1000*square(log(spr_percent/spr_ratio(F3, sel_tmp,styr)));\n    dyld   = (yld2 - yld3)/(2*df);                          // First derivative (to find the root of this)\n    dyldp  = (yld3-(2*yld1)+yld2)/(df*df);  // Newton-Raphson approximation for second derivitive\n    F1    -= dyld/dyldp;\n  }\n  RETURN_ARRAYS_DECREMENT();\n  return(F1);\n\nFUNCTION dvariable spr_ratio(dvariable trial_F,dvar_matrix sel_tmp,int iyr)\n  /**  Get the SPR ratio given F, Selectivity and year */\n  dvariable SBtmp;\n  dvar_vector Ntmp(1,nages);\n  dvar_vector srvtmp(1,nages);\n  SBtmp.initialize();\n  Ntmp.initialize();\n  srvtmp.initialize();\n  dvar_matrix Ftmp(1,nages,1,nfsh); // note that this is in reverse order of usual indexing (age, fshery)\n  Ftmp = sel_tmp;\n  for (j=1;j<=nages;j++) \n  {\n    Ftmp(j) = elem_prod(Ftmp(j), trial_F * Fratio);\n    srvtmp(j)  = mfexp(-sum(Ftmp(j)) - M(iyr,j));\n  }\n  Ntmp(1)=1.;\n  j=1;\n  SBtmp  += Ntmp(j)*wt_mature(j)*pow(srvtmp(j),spmo_frac);\n  for (j=2;j<nages;j++)\n  {\n    Ntmp(j) = Ntmp(j-1)*srvtmp(j-1);\n    SBtmp  += Ntmp(j)*wt_mature(j)*pow(srvtmp(j),spmo_frac);\n  }\n  Ntmp(nages)=Ntmp(nages-1)*srvtmp(nages-1)/(1.-srvtmp(nages));\n  SBtmp  += Ntmp(nages)*wt_mature(nages)*pow(srvtmp(nages),spmo_frac);\n  return(SBtmp/phizero);\n\nFUNCTION dvariable spr_unfished(int i)\n  /**  Get the SPR ratio given no fishing */\n  dvariable Ntmp;\n  dvariable SBtmp;\n  SBtmp.initialize();\n  Ntmp = 1.;\n  for (j=1;j<nages;j++)\n  {\n    SBtmp += Ntmp*wt_mature(j)*exp(-spmo_frac * M(i,j));\n    Ntmp  *= mfexp( -M(i,j));\n  }\n  Ntmp    /= (1.-exp(-M(i,nages)));\n  SBtmp += Ntmp*wt_mature(nages)*exp(-spmo_frac * M(i,nages));\n  return(SBtmp);\n\nFUNCTION compute_spr_rates\n  /**  Get the SPR rate no fishing */\n  //Compute SPR Rates and add them to the likelihood for Females \n  dvariable sumF=0.;\n  for (k=1;k<=nfsh;k++)\n  {\n    Fratio(k) = sum(F(k,endyr)) ;\n    sumF += Fratio(k) ;\n  }\n  Fratio /= sumF;\n\n  F35_est = get_spr_rates(.35);\n  F50_est = get_spr_rates(.50);\n  F40_est = get_spr_rates(.40);\n\n  for (k=1;k<=nfsh;k++)\n  {\n    F50(k) = F50_est * (Fratio(k));\n    F40(k) = F40_est * (Fratio(k));\n    F35(k) = F35_est * (Fratio(k));\n  }\n  // cout << F50<<endl<<F40<<endl<<F35<<endl;\n\nFUNCTION void writerep(dvariable& tmp,adstring& tmpstring)\n  // cout <<tmpstring<<endl<<endl;\n  tmpstring = printf(\"3.5%f\",value(tmp));\n\nFUNCTION dvariable SolveF2(const int& iyr, const dvar_vector& N_tmp, const double&  TACin)\n  RETURN_ARRAYS_INCREMENT();\n  dvariable dd = 10.;\n  dvariable cc; \n  dvar_matrix Fratsel(1,nfsh,1,nages);\n  dvar_vector M_tmp(1,nages) ;\n  dvar_vector Z_tmp(1,nages) ;\n  dvar_vector S_tmp(1,nages) ;\n  dvar_vector Ftottmp(1,nages);\n  dvariable btmp =  N_tmp * elem_prod(sel_fsh(1,iyr),wt_pop);\n  dvariable ftmp;\n  M_tmp = M(iyr);\n  ftmp = TACin/btmp;\n    for (k=1;k<=nfsh;k++)\n      Fratsel(k) = Fratio(k)*sel_fsh(k,iyr);\n    for (int ii=1;ii<=5;ii++)\n    {\n      Ftottmp.initialize();\n      for (k=1;k<=nfsh;k++)\n        Ftottmp += ftmp*Fratsel(k);\n  \n      Z_tmp = Ftottmp  + M_tmp; \n      S_tmp = mfexp( -Z_tmp );\n      cc = 0.0;\n      for (k=1;k<=nfsh;k++)\n        cc += wt_fsh(k,endyr) * elem_prod(elem_div(ftmp*Fratsel(k),  Z_tmp),elem_prod(1.-S_tmp,N_tmp)); // Catch equation (vectors)\n  \n      dd = cc / TACin - 1.;\n      if (dd<0.) dd *= -1.;\n      ftmp += (TACin-cc) / btmp;\n    }\n  RETURN_ARRAYS_DECREMENT();\n  return(ftmp);\n\nFUNCTION dvar_vector SolveF2(const int& iyr, const dvector&  Catch)\n  // Returns vector of F's (given year) by fleet\n  // Requires: N and fleet specific wts & selectivities at age, catch \n  // iterate to get Z's right\n  RETURN_ARRAYS_INCREMENT();\n  dvariable dd = 10.;\n  dvariable cc; \n  dvar_matrix  seltmp(1,nfsh,1,nages);\n  dvar_matrix  wt_tmp(1,nfsh,1,nages);\n  dvar_matrix Fratsel(1,nfsh,1,nages);\n  dvar_vector N_tmp = natage(iyr);\n  dvar_vector M_tmp(1,nages) ;\n  dvar_vector Z_tmp(1,nages) ;\n  dvar_vector S_tmp(1,nages) ;\n  dvar_vector Ftottmp(1,nages);\n  dvar_vector Frat(1,nfsh);\n  dvar_vector btmp(1,nfsh);\n  dvar_vector ftmp(1,nfsh);\n  dvar_vector hrate(1,nfsh);\n  btmp.initialize(); \n  M_tmp = M(iyr);\n  // Initial guess for Fratio\n  for (k=1;k<=nfsh;k++)\n  {\n    seltmp(k)= sel_fsh(k,iyr); // Selectivity\n    wt_tmp(k)= wt_fsh(k,iyr); // \n    btmp(k)  =  N_tmp * elem_prod(seltmp(k),wt_tmp(k));\n    hrate(k) = Catch(k)/btmp(k);\n    Frat(k)  = Catch(k)/sum(Catch);\n    Fratsel(k) = Frat(k)*seltmp(k);\n    ftmp(k) = 1.1*(1.- posfun(1.-hrate(k),.10,fpen(4)));\n  }\n  // Initial fleet-specific F\n  // iterate to balance effect of multiple fisheries...........\n  for (int kk=1;kk<=nfsh;kk++) \n  {\n    for (k=1;k<=nfsh;k++)\n    {\n      if (hrate(k) <.9999) \n      {\n        for (int ii=1;ii<=8;ii++)\n        {\n          Ftottmp.initialize();\n          Ftottmp   = ftmp*Fratsel;\n          Z_tmp     = Ftottmp  + M_tmp; \n          S_tmp     = mfexp( -Z_tmp );\n          cc        = wt_tmp(k) * elem_prod(elem_div(ftmp(k)*Fratsel(k),  Z_tmp),elem_prod(1.-S_tmp,N_tmp)); // Catch equation (vectors)\n          ftmp(k)  += ( Catch(k)-cc ) / btmp(k);\n        }\n        Frat(k)    = ftmp(k)/sum(ftmp);\n        Fratsel(k) = Frat(k)*seltmp(k);\n      }\n    }\n  }\n  RETURN_ARRAYS_DECREMENT();\n  return(ftmp);\n\nFUNCTION Write_SimDatafile\n  {\n  int nsims;\n  // get the number of simulated datasets to create...\n  ifstream sim_in(\"nsims.dat\"); sim_in >> nsims; sim_in.close();\n  char buffer [33];\n  ofstream SimDB(\"simout.dat\",ios::app); \n  ofstream TruDB(\"truout.dat\",ios::app); \n  // compute the autocorrelation term for residuals of fit to indices...\n  // for (k=1;k<=nind;k++) ac(k) = get_AC(k);\n  // #int nyrs_fsh_age_sim = endyr-styr;\n  // #int nyrs_ind_sim     = 1+endyr-styr;\n  // #int nyrs_ind_age_sim = 1+endyr-styr;\n  // yrs_fsh_age_sim.fill_seqadd(1977,1);\n  // yrs_ind_sim.fill_seqadd(1977,1);\n  // yrs_ind_age_sim.fill_seqadd(1977,1);\n  // dvector new_ind_sim(1,nyrs_ind_sim);\n  // ivector n_sample_fsh_age_sim(1,nyrs_fsh_age_sim);\n  // ivector n_sample_ind_age_sim(1,nyrs_ind_age_sim);\n\n  ivector nyrs_fsh_age_sim  = nyrs_fsh_age;\n  ivector nyrs_ind_sim      = nyrs_ind;\n  ivector nyrs_ind_age_sim  = nyrs_ind_age;\n  //init_imatrix yrs_ind_in(1,nind,1,nyrs_ind)         //Years of index value (annual)\n  imatrix yrs_fsh_age_sim(1,nfsh,1,nyrs_fsh_age_sim);\n  imatrix yrs_ind_sim(1,nind,1,nyrs_ind_sim);\n  imatrix yrs_ind_age_sim(1,nind,1,nyrs_ind_sim);\n  imatrix n_sample_fsh_age_sim(1,nfsh,1,nyrs_fsh_age_sim);\n  imatrix n_sample_ind_age_sim(1,nind,1,nyrs_ind_age_sim);\n  yrs_fsh_age_sim       = yrs_fsh_age;\n  yrs_ind_sim           = yrs_ind;\n  yrs_ind_age_sim       = yrs_ind_age;\n  dmatrix new_ind_sim(1,nind,1,nyrs_ind);\n  dvector sim_rec_devs(styr_rec,endyr);\n  dvector sim_Sp_Biom(styr_rec,endyr);\n  dmatrix sim_natage(styr_rec,endyr,1,nages);\n  dmatrix catagetmp(styr,endyr,1,nages);\n  dvector sim_catchbio(styr,endyr);\n  double survtmp = value(mfexp(-natmort(styr)));\n  for (k=1;k<=nfsh;k++) Ftot += F(k);\n\n  for (int isim=1;isim<=nsims;isim++)\n  {\n    new_ind_sim.initialize();\n    sim_natage.initialize();\n    // Start w/ simulated population\n    // Simulate using new recruit series (same F's)\n    // fill vector with unit normal RVs\n    sim_rec_devs.fill_randn(rng);\n    sim_rec_devs *= value(sigmar);\n    sim_natage(styr_rec,1) = value(Rzero)*exp(sim_rec_devs(styr_rec));\n    for (j=2; j<=nages; j++)\n      sim_natage(styr_rec,j) = sim_natage(styr_rec,j-1) * survtmp;\n    sim_natage(styr_rec,nages) /= (1.-survtmp); \n  \n    // Simulate population w/ process errors in recruits\n    for (i=styr_rec;i<=endyr;i++)\n    {\n      sim_Sp_Biom(i) = sim_natage(i)*pow(survtmp,spmo_frac) * wt_mature; \n      if (i>styr_rec+rec_age)\n        sim_natage(i,1)          = value(SRecruit(sim_Sp_Biom(i-rec_age)))*mfexp(sim_rec_devs(i)); \n      else\n        sim_natage(i,1)          = value(SRecruit(sim_Sp_Biom(i)))*mfexp(sim_rec_devs(i)); \n  \n      if (i>=styr)\n      {\n        // apply estimated survival rates\n        sim_Sp_Biom(i)          = value( elem_prod(sim_natage(i),pow(S(i),spmo_frac)) * wt_mature); \n        catagetmp(i)            = value( elem_prod(elem_div(Ftot(i),Z(i)),elem_prod(1.-S(i),sim_natage(i))));\n        sim_catchbio(i)         = catagetmp(i)*wt_fsh(1,i);\n        if (i<endyr)\n        {\n          sim_natage(i+1)(2,nages) = value( ++elem_prod(sim_natage(i)(1,nages-1),S(i)(1,nages-1)));\n          sim_natage(i+1,nages)   += value( sim_natage(i,nages)*S(i,nages));\n        }\n      }\n      else\n      {\n        if (i<endyr)\n        {\n          sim_natage(i+1)(2,nages) = ++(sim_natage(i)(1,nages-1) * survtmp);\n          sim_natage(i+1,nages)   += sim_natage(i,nages)*survtmp;\n        }\n      }\n    }\n  \n    //===============================================\n    //Now write from simulated population\n    //\n    // Create the name of the simulated dataset\n    // simname = \"sim_\"+ adstring(itoa(isim,buffer,10)) + \".dat\";\n    // truname = \"tru_\"+ adstring(itoa(isim,buffer,10)) + \".dat\";\n\t\tsimname = \"sim_\"+ adstring(sprintf(buffer,\"%d\",isim)) + \".dat\";\n    truname = \"tru_\"+ adstring(sprintf(buffer,\"%d\",isim)) + \".dat\";\n    ofstream trudat(truname);\n    truth(Rzero);\n    truth(Fmsy);\n    truth(MSY);\n    dvector ntmp(1,nages);\n    dmatrix seltmp(1,nfsh,1,nages);\n    dmatrix Fatmp(1,nfsh,1,nages);\n    dvector Ztmp(1,nages);\n    seltmp.initialize();\n    Fatmp.initialize();\n    Ztmp.initialize();\n    ntmp.initialize();\n    for (k=1;k<=nfsh;k++)\n     seltmp(k) = value(sel_fsh(k,endyr));\n    Ztmp = value(natmort(styr));\n    for (k=1;k<=nfsh;k++)\n    { \n      Fatmp(k) = value(Fratio(k) * Fmsy * seltmp(k));\n      Ztmp    += Fatmp(k);\n    } \n    dvector survmsy = exp(-Ztmp);\n    ntmp(1) = value(Rmsy);\n    for (j=2;j<=nages;j++) \n      ntmp(j) = ntmp(j-1)*survmsy(j-1);\n    ntmp(nages) /= (1-survmsy(nages));\n    // dvariable phi    = elem_prod( ntmp , pow(survmsy,spmo_frac ) )* wt_mature;\n    truth(Rmsy);\n    truth(seltmp);\n    double SurvBmsy;\n    double q_ind_sim=value(mean(q_ind(1)));\n    SurvBmsy = value(elem_prod(wt_ind(1,endyr),elem_prod(pow(survmsy,ind_month_frac(1)), ntmp)) * q_ind_sim*sel_ind(1,endyr)); \n    truth(ntmp);\n    double Cmsy   = value(yield(Fratio,  Fmsy));\n    truth(Cmsy);\n    // Now do OFL for next year...\n    ntmp(1)       = value(SRecruit(sim_Sp_Biom(endyr+1-rec_age)));\n    ntmp(2,nages) = value( ++elem_prod(sim_natage(endyr)(1,nages-1),S(endyr)(1,nages-1)));\n    ntmp(nages)  += value( sim_natage(endyr,nages)*S(endyr,nages));\n    dvector ctmp(1,nages);\n    ctmp.initialize();\n    OFL=0.;\n    for (k=1;k<=nfsh;k++)\n    {\n      for ( j=1 ; j <= nages; j++ )\n        ctmp(j)      = ntmp(j) * Fatmp(k,j) * (1. - survmsy(j)) / Ztmp(j);\n      OFL  += wt_fsh(k,endyr) * ctmp;\n    }\n    double NextSurv = value(elem_prod(wt_ind(1,endyr),elem_prod(pow(survmsy,ind_month_frac(1)), ntmp)) * \n                        q_ind_sim*sel_ind(1,endyr)); \n    double NextSSB  = elem_prod(ntmp, pow(survmsy,spmo_frac)) * wt_mature; \n    // Catch at following year for Fmsy\n    truth(OFL);\n    truth(SurvBmsy);\n    truth(steepness);\n    truth(natmort);\n    truth(sim_natage);\n    truth(sim_Sp_Biom);\n    // Open the simulated dataset for writing\n    ofstream simdat(simname);\n    simdat << \"# first year\" <<endl;\n    simdat << styr <<endl;\n    simdat << \"# Last  year\" <<endl;\n    simdat << endyr <<endl;\n    simdat << \"# age recruit\" <<endl;\n    simdat << rec_age <<endl;\n    simdat << \"# oldest age\" <<endl;\n    simdat << oldest_age <<endl;\n    simdat << \"# Number of fisheries \" <<endl;\n    simdat << nfsh <<endl;                                   \n    simdat << fshnameread <<endl;                                   \n    simdat << \"# Catch biomass by fishery \" <<endl;\n    for (k=1;k<=nfsh;k++)\n    {\n      simdat << \"# \" <<fshname(k) <<\" \" << k <<endl;\n      simdat << sim_catchbio <<endl;\n    }\n    simdat << \"# Catch biomass uncertainty by fishery (std errors)\" <<endl;\n    for (k=1;k<=nfsh;k++)\n    {\n      simdat << \"# \" <<fshname(k) <<\" \" << k <<endl;\n      simdat << catch_bio_sd(k) <<endl;   \n    }\n    simdat << \"# number of years for fishery age data \" <<endl;\n    for (k=1;k<=nfsh;k++)\n    {\n      simdat << \"# \" <<fshname(k)<< \" \" << k <<endl;\n      simdat << nyrs_fsh_age_sim(k) <<endl;\n    }\n    simdat << \"# years for fishery age data \" <<endl;\n    for (k=1;k<=nfsh;k++)\n    {\n      simdat << \"# \" <<fshname(k)<< \" \" << k <<endl;\n      simdat << yrs_fsh_age_sim  <<endl;\n    }\n    simdat << \"# sample sizes for fishery age data \" <<endl;\n    for (k=1;k<=nfsh;k++)\n    {\n      n_sample_fsh_age_sim(k) = mean(n_sample_fsh_age(k));\n      simdat << \"# \" <<fshname(k)<< \" \" << k <<endl;\n      simdat << n_sample_fsh_age_sim(k)         <<endl;    \n    }\n    simdat << \"# Observed age compositions for fishery\" <<endl;\n    for (k=1;k<=nfsh;k++)\n    {\n      dvector p(1,nages);\n      double Ctmp; // total catch\n      dvector freq(1,nages);\n      simdat << \"# \" << fshname(k) <<endl;\n      for (i=1;i<=nyrs_fsh_age_sim(k);i++)\n      {\n        int iyr = yrs_fsh_age_sim(k,i);\n        // Add noise here\n        freq.initialize();\n        ivector bin(1,n_sample_fsh_age_sim(k,i));\n        p  = catagetmp(iyr);\n        p /= sum(p);\n        bin.fill_multinomial(rng,p); // fill a vector v\n        for (int j=1;j<=n_sample_fsh_age_sim(k,i);j++)\n          freq(bin(j))++;\n        // Apply ageing error to samples..............\n        // p = age_err *freq/sum(freq); \n        p = freq/sum(freq); \n        // cout << p  <<endl;\n        simdat << p  <<endl;\n        // Compute total catch given this sample size for catch-age\n        Ctmp = sim_catchbio(iyr) / (p*wt_fsh(k,iyr)); \n        // Simulated catage = proportion sampled\n        // sim_catage(k,i) = p * Ctmp;\n      }\n    }\n    simdat << \"# Annual wt-at-age for fishery\" <<endl;\n    for (k=1;k<=nfsh;k++)\n    {\n      simdat << \"# \" <<fshname(k)<< \" \" << (k) <<endl;\n      // Add noise here\n      simdat << wt_fsh(k)  <<endl;  \n    }\n    simdat << \"# number of indices\" <<endl;\n    simdat << nind <<endl;                                   \n    simdat << indnameread <<endl;                                   \n    simdat << \"# Number of years of index values (annual)\" <<endl;\n    for (k=1;k<=nind;k++)\n    {\n      simdat << \"# \" << indname(k) <<endl;\n      simdat << nyrs_ind_sim(k)  <<endl;                   \n    }\n    simdat << \"# Years of index values (annual)\" <<endl;\n    for (k=1;k<=nind;k++)\n    {\n      simdat << \"# \" << indname(k) <<endl;\n      simdat << yrs_ind_sim <<endl;         \n    }\n    simdat << \"# Month that index occurs \"<<endl;\n    for (k=1;k<=nind;k++)\n    {\n      simdat << \"# \" << indname(k) <<endl;\n      simdat << mo_ind(k) <<endl;\n    }\n    simdat << \"# values for indices (annual)\"<<endl;\n    // note assumes only one index...\n    double ind_sigma;\n    dmatrix ind_devs(1,nind,1,nyrs_ind_sim);\n    for (k=1;k<=nind;k++)\n    {\n      ind_sigma = mean(obs_lse_ind(k)) ;\n      //ind_sigma = 0.30 ;\n      simdat << \"# \" <<indname(k)<< \" \" << k <<endl;\n      // Add noise here\n      // fill vector with unit normal RVs\n      ind_devs.fill_randn(rng);\n      ind_devs(k) *= ind_sigma ;\n      for (i=1;i<=nyrs_ind_sim(k);i++)\n      {\n        int iyr=yrs_ind_sim(k,i);\n        //uncorrelated...corr_dev(k,i) = ac(k) * corr_dev(k,i-1) + sqrt(1.-square(ac(k))) * corr_dev(k,i);\n        new_ind_sim(k,i) = mfexp(ind_devs(k,i) - ind_sigma/2.) * value(elem_prod(wt_ind(k,iyr),elem_prod(pow(S(iyr),ind_month_frac(k)), \n                        sim_natage(iyr))) * q_ind_sim*sel_ind(k,iyr)); \n      }\n      simdat << new_ind_sim(k)     <<endl;\n      dvector ExactSurvey = elem_div(new_ind_sim(k),exp(ind_devs(k)-ind_sigma/2.));\n      truth(ExactSurvey);\n    }\n    simdat << \"# standard errors for indices (by year) \" <<endl;\n    for (k=1;k<=nind;k++)\n    {\n      simdat << \"# \" <<indname(k)<< \" \" << k <<endl;\n      // simdat << new_ind_sim*mean(elem_div(obs_se_ind(k),obs_ind(k)))  <<endl;\n      simdat << new_ind_sim(k)*ind_sigma  <<endl;\n    }\n    simdat << \"# Number of years of age data available for index\" <<endl;\n    for (k=1;k<=nind;k++)\n    {\n      simdat << \"# \" <<indname(k)<< \" \" << k <<endl;\n      simdat << nyrs_ind_age_sim(k) <<endl;\n    }\n    simdat << \"# Years of index values (annual)\" <<endl;\n    for (k=1;k<=nind;k++)\n    {\n      simdat << \"# \" <<indname(k)<< endl;\n      simdat << yrs_ind_age_sim(k) <<endl;\n    }\n    simdat << \"# Sample sizes for age data from indices\" <<endl;\n    for (k=1;k<=nind;k++)\n    {\n      n_sample_ind_age_sim(k) = mean(n_sample_ind_age(k));\n      simdat << \"# \" <<indname(k)<< endl;\n      simdat << n_sample_ind_age_sim(k) <<endl;\n    }\n    simdat << \"# values of proportions at age in index\" <<endl;\n    for (k=1;k<=nind;k++)\n    {\n      simdat << \"# \" <<indname(k)<< endl;\n      dvector p(1,nages);\n      dvector freq(1,nages);\n      for (i=1;i<=nyrs_ind_age_sim(k);i++)\n      {\n        int iyr = yrs_ind_age_sim(k,i);\n        // Add noise here\n        freq.initialize();\n        ivector bin(1,n_sample_ind_age_sim(k,i));\n        // p = age_err * value(elem_prod( elem_prod(pow(S(iyr),ind_month_frac(k)), sim_natage(iyr))*q_ind_sim , sel_ind(k,iyr))); \n        p = value(elem_prod( elem_prod(pow(S(iyr),ind_month_frac(k)), sim_natage(iyr))*q_ind_sim , sel_ind(k,iyr))); \n        p /= sum(p);\n        // fill vector with multinomial samples\n        bin.fill_multinomial(rng,p); // fill a vector v\n        for (int j=1;j<=n_sample_ind_age_sim(k,i);j++)\n          freq(bin(j))++;\n        simdat << \"# \" <<indname(k)<< \" year: \"<< iyr<< endl;\n        simdat << freq/sum(freq) <<endl;\n      }\n    }\n    simdat << \"# Mean wts at age for indices\" <<endl;\n    for (k=1;k<=nind;k++)\n    {\n      simdat << \"# \" <<indname(k)<< endl;\n      // Could add noise here\n      simdat <<  wt_ind(k)  <<endl;\n    }\n  \n    simdat << \"# Population mean wt at age\" <<endl;\n    simdat << wt_pop <<endl;\n  \n    simdat << \"# Population maturity at age\" <<endl;\n    simdat << maturity  <<endl;\n  \n    simdat << \"# Peak spawning month\" <<endl;\n    simdat << spawnmo <<endl;\n  \n    simdat << \"# ageing error \" <<endl;\n    simdat << age_err <<endl;\n\n    simdat <<endl<<endl<<\"Additional output\"<<endl;\n    simdat << \"# Fishery_Effort \" <<endl;\n    for (k=1;k<=nfsh;k++)\n    {\n      dvector ran_fsh_vect(styr,endyr);\n      // fill vector with unit normal RVs\n      ran_fsh_vect.fill_randn(rng);\n      // Sigma on effort is ~15% white noise (add red noise later)\n      ran_fsh_vect *= 0.15; \n      dvector avail_biom(styr,endyr);\n      for (i=styr;i<=endyr;i++)\n      {\n        avail_biom(i) = wt_fsh(k,i)*value(elem_prod(sim_natage(i),sel_fsh(k,i))); \n      }\n      act_eff(k) = elem_prod(exp(ran_fsh_vect), (elem_div(catch_bio(k), avail_biom)) );\n      // Normalize effort\n      act_eff(k) /= mean(act_eff(k));\n      for (i=styr;i<=endyr;i++)\n        simdat<<fshname(k)<<\" \"<<i<<\" \"<<act_eff(k,i) <<endl;\n    }\n    simdat << \"# Fishery catch-at-age \" <<endl;\n    for (k=1;k<=nfsh;k++)\n    {\n      simdat << \"# \" <<fshname(k)<< \" \" << k <<endl;\n      simdat << \"Fishery Year \"<<age_vector << endl;\n      for (i=1;i<=nyrs_fsh_age(k);i++)\n        simdat<<fshname(k)<<\" \"<<yrs_fsh_age(k,i)<<\" \"<<catagetmp(yrs_fsh_age(k,i)) <<endl;\n    }\n    // Write simple file by simulation\n    dmatrix ExactSurvey(1,nind,1,nyrs_ind) ;\n    for (k=1;k<=nind;k++)\n    {\n      ExactSurvey(k) = elem_div(new_ind_sim(k),exp(ind_devs(k)-ind_sigma/2.));\n      for (i=1;i<=nyrs_ind(k);i++)\n      {\n        SimDB<<model_name<<\" simIndex \"<<isim<<\" \"<< yrs_ind_sim(k,i) <<\" \"<< \n        new_ind_sim(k,i) <<\" \"<< \n        new_ind_sim(k,i)*ind_sigma  <<endl;\n      }\n    }\n      \n    for (k=1;k<=nfsh;k++)\n    {\n      ExactSurvey(k) = elem_div(new_ind_sim(k),exp(ind_devs(k)-ind_sigma/2.));\n      for (i=styr;i<=endyr;i++)\n      {\n       SimDB<<model_name<<\" simCatch \"<<isim<<\" \"<< i<<\" \"<< sim_catchbio(i)       <<\" \"<< endl;\n       TruDB<<model_name<<\" \" <<isim<<\" \"<< i<<\" \"<<\n        sim_catchbio(i)      <<\" \"<< \n        sim_natage(i,1)      <<\" \"<< \n        sim_Sp_Biom(i)       <<\" \"<< \n        steepness            <<\" \"<< \n        Bmsy                 <<\" \"<< \n        MSYL                 <<\" \"<< \n        MSY                  <<\" \"<< \n        SurvBmsy             <<\" \"<<\n        endl;\n    }\n    TruDB<<model_name<<\" \"<<isim<<\" \"<< endyr+1<<\" \"<<\n        OFL                  <<\" \"<< \n        SRecruit(sim_Sp_Biom(endyr+1-rec_age))<<\" \"<<\n        sim_Sp_Biom(endyr)   <<\" \"<< \n        NextSurv             <<\" \"<< \n        steepness            <<\" \"<< \n        Bmsy                 <<\" \"<< \n        MSYL                 <<\" \"<< \n        MSY                  <<\" \"<< \n        SurvBmsy             <<\" \"<<\n        endl;\n    }\n    trudat.close();\n  }\n  SimDB.close();\n  TruDB.close();\n  exit(1);\n  // End of simulating datasets...................\n  }\n\nFUNCTION Write_Datafile\n  dmatrix new_ind(1,nind,1,nyrs_ind);\n  new_ind.initialize();\n  int nsims;\n  // get the number of simulated datasets to create...\n  ifstream sim_in(\"nsims.dat\"); sim_in >> nsims; sim_in.close();\n  char buffer [33];\n  // compute the autocorrelation term for residuals of fit to indices...\n  for (k=1;k<=nind;k++)\n    ac(k) = get_AC(k);\n  for (int isim=1;isim<=nsims;isim++)\n  {\n    // Create the name of the simulated dataset\n    // simname = \"sim_\"+ adstring(itoa(isim,buffer,10)) + \".dat\";\n\t\tsimname = \"sim_\"+ adstring(sprintf(buffer,\"%d\",isim)) + \".dat\";\n    // Open the simulated dataset for writing\n    ofstream simdat(simname);\n    simdat << \"# first year\" <<endl;\n    simdat << styr <<endl;\n    simdat << \"# Last  year\" <<endl;\n    simdat << endyr <<endl;\n    simdat << \"# age recruit\" <<endl;\n    simdat << rec_age <<endl;\n    simdat << \"# oldest age\" <<endl;\n    simdat << oldest_age <<endl;\n    simdat << \"# Number of fisheries \" <<endl;\n    simdat << nfsh <<endl;                                   \n    simdat << fshnameread <<endl;                                   \n    simdat << \"# Catch biomass by fishery \" <<endl;\n    for (k=1;k<=nfsh;k++)\n    {\n      simdat << \"# \" <<fshname(k) <<\" \" << k <<endl;\n      simdat << catch_bio(k) <<endl;\n    }\n    simdat << \"# Catch biomass uncertainty by fishery (std errors)\" <<endl;\n    for (k=1;k<=nfsh;k++)\n    {\n      simdat << \"# \" <<fshname(k) <<\" \" << k <<endl;\n      simdat << catch_bio_sd(k) <<endl;   \n    }\n    simdat << \"# number of years for fishery age data \" <<endl;\n    for (k=1;k<=nfsh;k++)\n    {\n      simdat << \"# \" <<fshname(k)<< \" \" << k <<endl;\n      simdat << nyrs_fsh_age(k) <<endl;\n    }\n    simdat << \"# years for fishery age data \" <<endl;\n    for (k=1;k<=nfsh;k++)\n    {\n      simdat << \"# \" <<fshname(k)<< \" \" << k <<endl;\n      simdat << yrs_fsh_age(k)  <<endl;\n    }\n    simdat << \"# sample sizes for fishery age data \" <<endl;\n    for (k=1;k<=nfsh;k++)\n    {\n      simdat << \"# \" <<fshname(k)<< \" \" << k <<endl;\n      simdat << n_sample_fsh_age(k)  <<endl;    \n    }\n    simdat << \"# Observed age compositions for fishery\" <<endl;\n    for (k=1;k<=nfsh;k++)\n    {\n      dvector p(1,nages);\n      double Ctmp; // total catch\n      dvector freq(1,nages);\n      simdat << \"# \" << fshname(k) <<endl;\n      for (i=1;i<=nyrs_fsh_age(k);i++)\n      {\n        int iyr = yrs_fsh_age(k,i);\n        // Add noise here\n        freq.initialize();\n        ivector bin(1,n_sample_fsh_age(k,i));\n        p  = value(catage(k,iyr));\n        p /= sum(p);\n        bin.fill_multinomial(rng,p); // fill a vector v\n        for (int j=1;j<=n_sample_fsh_age(k,i);j++)\n          freq(bin(j))++;\n        // Apply ageing error to samples..............\n        p = age_err *freq/sum(freq); \n        // cout << p  <<endl;\n        simdat << p  <<endl;\n        // Compute total catch given this sample size\n        Ctmp = catch_bio(k,iyr) / (p*wt_fsh(k,iyr)); \n        // Simulated catage = proportion sampled\n        catage(k,i) = p * Ctmp;\n      }\n    }\n    simdat << \"# Annual wt-at-age for fishery\" <<endl;\n    for (k=1;k<=nfsh;k++)\n    {\n      simdat << \"# \" <<fshname(k)<< \" \" << (k) <<endl;\n      // Add noise here\n      simdat << wt_fsh(k)  <<endl;  \n    }\n    simdat << \"# number of indices\" <<endl;\n    simdat << nind <<endl;                                   \n    simdat << indnameread <<endl;                                   \n    simdat << \"# Number of years of index values (annual)\" <<endl;\n    for (k=1;k<=nind;k++)\n    {\n      simdat << \"# \" << indname(k) <<endl;\n      simdat << nyrs_ind(k)  <<endl;                   \n    }\n    simdat << \"# Years of index values (annual)\" <<endl;\n    for (k=1;k<=nind;k++)\n    {\n      simdat << \"# \" << indname(k) <<endl;\n      simdat << yrs_ind(k)  <<endl;         \n    }\n    simdat << \"# Month that index occurs \"<<endl;\n    for (k=1;k<=nind;k++)\n    {\n      simdat << \"# \" << indname(k) <<endl;\n      simdat << mo_ind(k) <<endl;\n    }\n    simdat << \"# values for indices (annual)\"<<endl;\n    for (k=1;k<=nind;k++)\n    {\n      simdat << \"# \" <<indname(k)<< \" \" << k <<endl;\n      // Add noise here\n      dvector ran_ind_vect(1,nyrs_ind(k));\n      // fill vector with unit normal RVs\n      ran_ind_vect.fill_randn(rng);\n      // do first year uncorrelated\n      i=1;\n      int iyr=yrs_ind(k,i);\n      corr_dev(k)  = ran_ind_vect;\n      new_ind(k,i) = mfexp(corr_dev(k,i) * obs_lse_ind(k,i) ) * \n                     value(elem_prod(wt_ind(k,iyr),elem_prod(pow(S(iyr),ind_month_frac(k)), natage(iyr)))*\n                     q_ind(k,i)*sel_ind(k,iyr)); \n      // do next years correlated with previous\n      for (i=2;i<=nyrs_ind(k);i++)\n      {\n        iyr=yrs_ind(k,i);\n        corr_dev(k,i) = ac(k) * corr_dev(k,i-1) + sqrt(1.-square(ac(k))) * corr_dev(k,i);\n        new_ind(k,i) = mfexp(corr_dev(k,i) * obs_lse_ind(k,i) ) * \n                        value(elem_prod(wt_ind(k,iyr),elem_prod(pow(S(iyr),ind_month_frac(k)), \n                        natage(iyr))) * q_ind(k,i)*sel_ind(k,iyr)); \n      }\n      simdat << new_ind(k)      <<endl;\n    }\n    simdat << \"# standard errors for indices (by year) \" <<endl;\n    for (k=1;k<=nind;k++)\n    {\n      simdat << \"# \" <<indname(k)<< \" \" << k <<endl;\n      simdat << obs_se_ind(k)  <<endl;\n    }\n    simdat << \"# Number of years of age data available for index\" <<endl;\n    for (k=1;k<=nind;k++)\n    {\n      simdat << \"# \" <<indname(k)<< \" \" << k <<endl;\n      simdat << nyrs_ind_age(k)  <<endl;\n    }\n    simdat << \"# Years of index values (annual)\" <<endl;\n    for (k=1;k<=nind;k++)\n    {\n      simdat << \"# \" <<indname(k)<< endl;\n      simdat << yrs_ind_age(k)  <<endl;\n    }\n    simdat << \"# Sample sizes for age data from indices\" <<endl;\n    for (k=1;k<=nind;k++)\n    {\n      simdat << \"# \" <<indname(k)<< endl;\n      simdat << n_sample_ind_age(k)  <<endl;\n    }\n    simdat << \"# values of proportions at age in index\" <<endl;\n    for (k=1;k<=nind;k++)\n    {\n      simdat << \"# \" <<indname(k)<< endl;\n      dvector p(1,nages);\n      dvector freq(1,nages);\n      for (i=1;i<=nyrs_ind_age(k);i++)\n      {\n        int iyr = yrs_ind_age(k,i);\n        // Add noise here\n        freq.initialize();\n        ivector bin(1,n_sample_ind_age(k,i));\n        p = age_err * value(elem_prod( elem_prod(pow(S(iyr),ind_month_frac(k)), natage(iyr))*q_ind(k,i) , sel_ind(k,iyr))); \n        p /= sum(p);\n        // fill vector with multinomial samples\n        bin.fill_multinomial(rng,p); // fill a vector v\n        for (int j=1;j<=n_sample_ind_age(k,i);j++)\n          freq(bin(j))++;\n        simdat << \"# \" <<indname(k)<< \" year: \"<< iyr<< endl;\n        simdat << freq/sum(freq) <<endl;\n      }\n    }\n    simdat << \"# Mean wts at age for indices\" <<endl;\n    for (k=1;k<=nind;k++)\n    {\n      simdat << \"# \" <<indname(k)<< endl;\n      // Could add noise here\n      simdat <<  wt_ind(k)  <<endl;\n    }\n  \n    simdat << \"# Population mean wt at age\" <<endl;\n    simdat << wt_pop <<endl;\n  \n    simdat << \"# Population maturity at age\" <<endl;\n    simdat << maturity  <<endl;\n  \n    simdat << \"# Peak spawning month\" <<endl;\n    simdat << spawnmo <<endl;\n  \n    simdat << \"# ageing error \" <<endl;\n    simdat << age_err <<endl;\n\n    simdat <<endl<<endl<<\"Additional output\"<<endl;\n    simdat << \"# Fishery_Effort \" <<endl;\n    for (k=1;k<=nfsh;k++)\n    {\n      dvector ran_fsh_vect(styr,endyr);\n      // fill vector with unit normal RVs\n      ran_fsh_vect.fill_randn(rng);\n      // Sigma on effort is ~15% white noise (add red noise later)\n      ran_fsh_vect *= 0.15; \n      dvector avail_biom(styr,endyr);\n      for (i=styr;i<=endyr;i++)\n      {\n        avail_biom(i) = wt_fsh(k,i)*value(elem_prod(natage(i),sel_fsh(k,i))); \n      }\n      act_eff(k) = elem_prod(exp(ran_fsh_vect), (elem_div(catch_bio(k), avail_biom)) );\n      // Normalize effort\n      act_eff(k) /= mean(act_eff(k));\n      for (i=styr;i<=endyr;i++)\n        simdat<<fshname(k)<<\" \"<<i<<\" \"<<act_eff(k,i) <<endl;\n    }\n    simdat << \"# Fishery catch-at-age \" <<endl;\n    for (k=1;k<=nfsh;k++)\n    {\n      simdat << \"# \" <<fshname(k)<< \" \" << k <<endl;\n      simdat << \"Fishery Year \"<<age_vector << endl;\n      for (i=1;i<=nyrs_fsh_age(k);i++)\n        simdat<<fshname(k)<<\" \"<<yrs_fsh_age(k,i)<<\" \"<<catage(k,i) <<endl;\n    }\n  }\n  exit(1);\n  // End of simulating datasets...................\n  \n\nFUNCTION Write_R\n  ofstream R_report(\"For_R.rep\");\n  for (k=1;k<=nfsh;k++)\n  {\n    R_report<< \"$sel_p1_fsh_\"<<k<<endl<<sel_p1_fsh(k)<<endl;\n    R_report<< \"$sel_p2_fsh_\"<<k<<endl<<sel_p2_fsh(k)<<endl;\n    R_report<< \"$sel_p3_fsh_\"<<k<<endl<<sel_p3_fsh(k)<<endl;\n  }\n  for (k=1;k<=nind;k++)\n  {\n    R_report<< \"$sel_p1_ind_\"<<k<<endl<<sel_p1_ind(k)<<endl;\n    R_report<< \"$sel_p2_ind_\"<<k<<endl<<sel_p2_ind(k)<<endl;\n    R_report<< \"$sel_p3_ind_\"<<k<<endl<<sel_p3_ind(k)<<endl;\n  }\n  R_Report(phizero);\n  R_Report(B100);\n  R_Report(B100.sd);\n  R_report<< \"$repl_yld\"<<endl<<repl_yld<<endl; \n  R_report<< \"$repl_SSB\"<<endl<<repl_SSB<<endl; \n  R_report<<\"$M\"<<endl; \n  R_report<<M<<endl;\n  for (k=1;k<=nind;k++)\n  {\n    R_report<<\"$q_\"<<k<<endl; \n    for (i=1;i<nyrs_ind(k);i++)\n    {        \n      int iyr=yrs_ind(k,i);\n      for (int ii=iyr;ii<yrs_ind(k,i+1);ii++)\n        R_report<<ii<<\" \"<<pow(q_ind(k,i),q_power_ind(k))<<endl;\n    }\n    R_report<<yrs_ind(k,nyrs_ind(k))<<\" \"<<pow(q_ind(k,nyrs_ind(k)),q_power_ind(k))<<endl;\n  }\n  R_report<<\"$M_equil\"<<endl; R_report<<natmort<<endl;\n  R_report<<\"$SurvNextYr\"<<endl; R_report<< pred_ind_nextyr <<endl;\n  R_report<<\"$Yr\"<<endl; for (i=styr;i<=endyr;i++) R_report<<i<<\" \"; R_report<<endl;\n  R_Report(P_age2len);\n  R_Report(len_bins);\n  R_report<<\"$TotF\"<<endl << Ftot<<endl;\n  R_report<<\"$TotBiom_NoFish\"<<endl; for (i=styr;i<=endyr;i++) \n  {\n    double lb=value(totbiom_NoFish(i)/exp(2.*sqrt(log(1+square(totbiom_NoFish.sd(i))/square(totbiom_NoFish(i))))));\n    double ub=value(totbiom_NoFish(i)*exp(2.*sqrt(log(1+square(totbiom_NoFish.sd(i))/square(totbiom_NoFish(i))))));\n    R_report<<i<<\" \"<<totbiom_NoFish(i)<<\" \"<<totbiom_NoFish.sd(i)<<\" \"<<lb<<\" \"<<ub<<endl;\n  }\n  R_report<<\"$SSB_NoFishR\"<<endl; for (i=styr+1;i<=endyr;i++) \n  {\n    double lb=value(Sp_Biom_NoFishRatio(i)/exp(2.*sqrt(log(1+square(Sp_Biom_NoFishRatio.sd(i))/square(Sp_Biom_NoFishRatio(i))))));\n    double ub=value(Sp_Biom_NoFishRatio(i)*exp(2.*sqrt(log(1+square(Sp_Biom_NoFishRatio.sd(i))/square(Sp_Biom_NoFishRatio(i))))));\n    R_report<<i<<\" \"<<Sp_Biom_NoFishRatio(i)<<\" \"<< Sp_Biom_NoFishRatio.sd(i)<<\" \"<<lb<<\" \"<<ub<<endl;\n  }\n\n  R_report<<\"$TotBiom\"<<endl; \n  for (i=styr;i<=endyr+1;i++) \n  {\n    double lb=value(totbiom(i)/exp(2.*sqrt(log(1+square(totbiom.sd(i))/square(totbiom(i))))));\n    double ub=value(totbiom(i)*exp(2.*sqrt(log(1+square(totbiom.sd(i))/square(totbiom(i))))));\n    R_report<<i<<\" \"<<totbiom(i)<<\" \"<<totbiom.sd(i)<<\" \"<<lb<<\" \"<<ub<<endl;\n  }\n\n  for (k=1;k<=5;k++){\n    R_report<<\"$SSB_fut_\"<<k<<endl; \n    for (i=styr_fut;i<=endyr_fut;i++) \n    {\n      double lb=value(SSB_fut(k,i)/exp(2.*sqrt(log(1+square(SSB_fut.sd(k,i))/square(SSB_fut(k,i))))));\n      double ub=value(SSB_fut(k,i)*exp(2.*sqrt(log(1+square(SSB_fut.sd(k,i))/square(SSB_fut(k,i))))));\n      R_report<<i<<\" \"<<SSB_fut(k,i)<<\" \"<<SSB_fut.sd(k,i)<<\" \"<<lb<<\" \"<<ub<<endl;\n    }\n  }\n  double ctmp;\n  for (k=1;k<=5;k++){\n    R_report<<\"$Catch_fut_\"<<k<<endl; \n    for (i=styr_fut;i<=endyr_fut;i++) \n    {\n      if (k==5) ctmp=0.;else ctmp=value(catch_future(k,i));\n      R_report<<i<<\" \"<<ctmp<<endl;\n    }\n  }\n\n  R_report<<\"$SSB\"<<endl; for (i=styr_sp;i<=endyr+1;i++) \n  {\n    double lb=value(Sp_Biom(i)/exp(2.*sqrt(log(1+square(Sp_Biom.sd(i))/square(Sp_Biom(i))))));\n    double ub=value(Sp_Biom(i)*exp(2.*sqrt(log(1+square(Sp_Biom.sd(i))/square(Sp_Biom(i))))));\n    R_report<<i<<\" \"<<Sp_Biom(i)<<\" \"<<Sp_Biom.sd(i)<<\" \"<<lb<<\" \"<<ub<<endl;\n  }\n\n  R_report<<\"$R\"<<endl; for (i=styr;i<=endyr;i++) \n  {\n    double lb=value(recruits(i)/exp(2.*sqrt(log(1+square(recruits.sd(i))/square(recruits(i))))));\n    double ub=value(recruits(i)*exp(2.*sqrt(log(1+square(recruits.sd(i))/square(recruits(i))))));\n    R_report<<i<<\" \"<<recruits(i)<<\" \"<<recruits.sd(i)<<\" \"<<lb<<\" \"<<ub<<endl;\n  }\n    R_report << \"$N\"<<endl;\n    for (i=styr;i<=endyr;i++) \n      R_report <<   i << \" \"<< natage(i) << endl;\n      R_report   << endl;\n\n    for (k=1;k<=nfsh;k++)\n    {\n      R_report << \"$F_age_\"<< (k) <<\"\"<< endl ;\n      for (i=styr;i<=endyr;i++) \n        R_report <<i<<\" \"<<F(k,i)<<\" \"<< endl;\n        R_report   << endl;\n    }\n\n    R_report <<endl<< \"$Fshry_names\"<< endl;\n    for (k=1;k<=nfsh;k++)\n      R_report << fshname(k) << endl ;\n\n    R_report <<endl<< \"$Index_names\"<< endl;\n    for (k=1;k<=nind;k++)\n      R_report << indname(k) << endl ;\n\n    for (k=1;k<=nind;k++)\n    {\n      int ii=1;\n\t\t\tdouble qtmp;\n\t\t\tqtmp = value(q_ind(k,1));\n      R_report <<endl<< \"$Obs_Survey_\"<< k <<\"\"<< endl ;\n      for (i=styr;i<=endyr;i++)\n      {\n        if (ii<=yrs_ind(k).indexmax())\n        {\n          if (yrs_ind(k,ii)==i)\n          {\n\t\t\t\t\t\tqtmp = value(q_ind(k,ii));\n            double PearsResid   =  value((obs_ind(k,ii)-pred_ind(k,ii))/obs_se_ind(k,ii) );\n            double lnPearsResid =  value((log(obs_ind(k,ii))-log(pred_ind(k,ii)))/obs_lse_ind(k,ii) );\n            R_report << i<< \" \"<< obs_ind(k,ii)   <<\" \"<< \n                                  pred_ind(k,ii)  <<\" \"<< \n                                  obs_se_ind(k,ii)<<\" \"<<  \n                                  PearsResid      <<\" \"<<\n                                  lnPearsResid    << endl; //values of survey index value (annual)\n            ii++;\n          }\n          else\n          {\n             int iyr=i; \n             double predtmp = value(qtmp * pow(elem_prod(natage(iyr),pow(S(iyr),ind_month_frac(k))) * \n                              elem_prod(sel_ind(k,iyr) , wt_ind(k,iyr)),q_power_ind(k)) );\n            R_report << i<< \" NA \"<< \" \"<< predtmp <<\" NA NA NA\"<<endl;\n          }\n        }\n        else\n        {\n          int iyr=i; \n          double predtmp = value(qtmp * pow(elem_prod(natage(iyr),pow(S(iyr),ind_month_frac(k))) * \n                            elem_prod(sel_ind(k,iyr) , wt_ind(k,iyr)),q_power_ind(k)) );\n          R_report << i<< \" NA \"<< \" \"<< predtmp <<\" NA NA NA\"<<endl;\n        }\n      }\n      R_report   << endl;\n      R_report << endl<< \"$Index_Q_\"<<k<<endl;\n      R_report<< q_ind(k) << endl;\n    }\n    R_report   << endl;\n    for (k=1;k<=nfsh;k++)\n    {\n      if (nyrs_fsh_age(k)>0) \n      { \n        R_report << \"$pobs_fsh_\"<< (k) <<\"\"<< endl;\n        for (i=1;i<=nyrs_fsh_age(k);i++) \n          R_report << yrs_fsh_age(k,i)<< \" \"<< oac_fsh(k,i) << endl;\n        R_report   << endl;\n\n        R_report << \"$phat_fsh_\"<< (k) <<\"\"<< endl;\n        for (i=1;i<=nyrs_fsh_age(k);i++) \n          R_report << yrs_fsh_age(k,i)<< \" \"<< eac_fsh(k,i) << endl;\n          R_report   << endl;\n\n        R_report << \"$sdnr_age_fsh_\"<< (k) <<\"\"<< endl;\n        for (i=1;i<=nyrs_fsh_age(k);i++) \n          R_report << yrs_fsh_age(k,i)<< \" \"<< sdnr( eac_fsh(k,i),oac_fsh(k,i),n_sample_fsh_age(k,i)) << endl;\n        R_report   << endl;\n      }\n      if (nyrs_fsh_length(k)>0) \n      { \n        R_report << \"$pobs_len_fsh_\"<< (k) <<\"\"<< endl;\n        for (i=1;i<=nyrs_fsh_length(k);i++) \n          R_report << yrs_fsh_length(k,i)<< \" \"<< olc_fsh(k,i) << endl;\n        R_report   << endl;\n\n        R_report << \"$phat_len_fsh_\"<< (k) <<\"\"<< endl;\n        for (i=1;i<=nyrs_fsh_length(k);i++) \n          R_report << yrs_fsh_length(k,i)<< \" \"<< elc_fsh(k,i) << endl;\n        R_report   << endl;\n\n        R_report << \"$sdnr_length_fsh_\"<< (k) <<\"\"<< endl;\n        for (i=1;i<=nyrs_fsh_length(k);i++) \n          R_report << yrs_fsh_length(k,i)<< \" \"<< sdnr( elc_fsh(k,i),olc_fsh(k,i),n_sample_fsh_length(k,i)) << endl;\n        R_report   << endl;\n      }\n    }\n    for (k=1;k<=nind;k++)\n    {\n      if (nyrs_ind_age(k)>0) \n      { \n        R_report << \"$pobs_ind_\"<<(k)<<\"\"<<  endl;\n        for (i=1;i<=nyrs_ind_age(k);i++) \n          R_report << yrs_ind_age(k,i)<< \" \"<< oac_ind(k,i) << endl;\n        R_report   << endl;\n        \n        R_report << \"$phat_ind_\"<<(k)<<\"\"<<  endl;\n        for (i=1;i<=nyrs_ind_age(k);i++) \n          R_report << yrs_ind_age(k,i)<< \" \"<< eac_ind(k,i) << endl;\n        R_report   << endl;\n\n        R_report << \"$sdnr_age_ind_\"<< (k) <<\"\"<< endl;\n        for (i=1;i<=nyrs_ind_age(k);i++) \n          R_report << yrs_ind_age(k,i)<< \" \"<< sdnr( eac_ind(k,i),oac_ind(k,i),n_sample_ind_age(k,i)) << endl;\n        R_report   << endl;\n      }\n      if (nyrs_ind_length(k)>0) \n      { \n        R_report << \"$pobs_len_ind_\"<< (k) <<\"\"<< endl;\n        for (i=1;i<=nyrs_ind_length(k);i++) \n          R_report << yrs_ind_length(k,i)<< \" \"<< olc_ind(k,i) << endl;\n        R_report   << endl;\n        R_report << \"$phat_len_ind_\"<< (k) <<\"\"<< endl;\n        for (i=1;i<=nyrs_ind_length(k);i++) \n          R_report << yrs_ind_length(k,i)<< \" \"<< elc_ind(k,i) << endl;\n        R_report   << endl;\n        R_report << \"$sdnr_length_ind_\"<< (k) <<\"\"<< endl;\n        for (i=1;i<=nyrs_ind_length(k);i++) \n          R_report << yrs_ind_length(k,i)<< \" \"<< sdnr( eac_ind(k,i),oac_ind(k,i),n_sample_ind_length(k,i)) << endl;\n        R_report   << endl;\n\n      } \n    }\n    for (k=1;k<=nind;k++)\n\t\t{\n      R_report <<\"$sdnr_ind_\"<<k<<endl;\n\t\t\tR_report << std_dev(elem_div((pred_ind(k)-obs_ind(k)),obs_se_ind(k)))<<endl;\n\t\t}\n    for (k=1;k<=nfsh;k++)\n    {\n      R_report << endl<< \"$Obs_catch_\"<<(k) << endl;\n      R_report << catch_bio(k) << endl;\n      R_report   << endl;\n      R_report << \"$Pred_catch_\" <<(k) << endl;\n      R_report << pred_catch(k) << endl;\n      R_report   << endl;\n    }\n\n    for (k=1;k<=nfsh;k++)\n    {\n      R_report << \"$F_fsh_\"<<(k)<<\" \"<<endl;\n      for (i=styr;i<=endyr;i++)\n      {\n        R_report<< i<< \" \";\n        R_report<< mean(F(k,i)) <<\" \"<< mean(F(k,i))*max(sel_fsh(k,i)) << \" \";\n        R_report<< endl;\n      }\n    }\n\n    for (k=1;k<=nfsh;k++)\n    {\n      R_report << endl<< \"$sel_fsh_\"<<(k)<<\"\" << endl;\n      for (i=styr;i<=endyr;i++)\n        R_report << k <<\"  \"<< i<<\" \"<<sel_fsh(k,i) << endl; \n      R_report   << endl;\n    }\n\n    for (k=1;k<=nind;k++)\n    {\n      R_report << endl<< \"$sel_ind_\"<<(k)<<\"\" << endl;\n      for (i=styr;i<=endyr;i++)\n        R_report << k <<\"  \"<< i<<\" \"<<sel_ind(k,i) << endl;\n        R_report << endl;\n\n    }\n    R_report << endl<< \"$Stock_Rec\"<< endl;\n    for (i=styr_rec;i<=endyr;i++)\n      if (active(log_Rzero))\n        R_report << i<< \" \"<<Sp_Biom(i-rec_age)<< \" \"<< SRecruit(Sp_Biom(i-rec_age))<< \" \"<< mod_rec(i)<<endl;\n      else \n        R_report << i<< \" \"<<Sp_Biom(i-rec_age)<< \" \"<< \" 999\" << \" \"<< mod_rec(i)<<endl;\n        \n        R_report   << endl;\n\n    R_report <<\"$stock_Rec_Curve\"<<endl;\n    R_report <<\"0 0\"<<endl;\n    dvariable stock;\n    for (i=1;i<=30;i++)\n    {\n      stock = double (i) * Bzero /25.;\n      if (active(log_Rzero))\n        R_report << stock <<\" \"<< SRecruit(stock)<<endl;\n      else\n        R_report << stock <<\" 99 \"<<endl;\n    }\n    R_report   << endl;\n\n    R_report   << endl<<\"$Like_Comp\" <<endl;\n    obj_comps(13)= obj_fun - sum(obj_comps) ; // Residual \n    obj_comps(14)= obj_fun ;                  // Total\n    R_report   <<obj_comps<<endl;\n    R_report   << endl;\n    R_report   << endl<<\"$Like_Comp_names\" <<endl;\n    R_report   <<\"catch_like     \"<<endl\n             <<\"age_like_fsh     \"<<endl\n             <<\"length_like_fsh     \"<<endl\n             <<\"sel_like_fsh     \"<<endl\n             <<\"ind_like        \"<<endl\n             <<\"age_like_ind     \"<<endl\n               <<\"length_like_ind  \"<<endl\n             <<\"sel_like_ind     \"<<endl\n             <<\"rec_like         \"<<endl\n             <<\"fpen             \"<<endl\n             <<\"post_priors_indq \"<<endl\n             <<\"post_priors      \"<<endl\n             <<\"residual         \"<<endl\n             <<\"total            \"<<endl;\n    for (k=1;k<=nfsh;k++)\n    {\n      R_report << \"$Sel_Fshry_\"<< (k) <<\"\"<<endl;\n      R_report << sel_like_fsh(k) << endl;\n    }\n    R_report   << endl;\n  \n    for (k=1;k<=nind;k++)\n    {\n      R_report << \"$Survey_Index_\"<< (k) <<\"\" <<endl;\n      R_report<< ind_like(k)<<endl;\n    }\n    R_report   << endl;\n\n    R_report << setw(10)<< setfixed() << setprecision(5) <<endl;\n    for (k=1;k<=nind;k++)\n    {\n      R_report << \"$Age_Survey_\"<< (k) <<\"\" <<endl;\n      R_report << age_like_ind(k)<<endl;\n    }\n    R_report   << endl;\n\n    for (k=1;k<=nind;k++)\n    {\n      R_report << \"$Sel_Survey_\"<< (k) <<\"\"<<endl;\n      R_report<< sel_like_ind(k,1) <<\" \"<<sel_like_ind(k,2)<<\" \"<<sel_like_ind(k,3)<< endl;\n    }\n    R_report   << endl;\n\n    R_report << setw(10)<< setfixed() << setprecision(5) <<endl;\n    R_report   << \"$Rec_Pen\" <<endl<<sigmar<<\"  \"<<rec_like<<endl;\n    R_report   << endl;\n    R_Report(m_sigmar);\n    R_Report(sigmar);\n\n    R_report   << \"$F_Pen\" <<endl;\n    R_report<<fpen(1)<<\"  \"<<fpen(2)<<endl;\n    R_report   << endl;\n    for (k=1;k<=nind;k++)\n    {\n      R_report << \"$Q_Survey_\"<< (k) <<\"\"<<endl\n             << \" \"<<post_priors_indq(k)\n             << \" \"<< q_ind(k,1)\n             << \" \"<< qprior(k)\n             << \" \"<< cvqprior(k)<<endl;\n      R_report << \"$Q_power_Survey_\"<< (k) <<\"\"<<endl\n             << \" \"<<post_priors_indq(k)\n             << \" \"<< q_power_ind(k)\n             << \" \"<< q_power_prior(k)\n             << \" \"<< cvq_power_prior(k)<<endl;\n    }\n             R_report   << endl;\n    R_report << \"$Mest\"<<endl;\n    R_report << \" \"<< post_priors(1)\n             << \" \"<< Mest\n             << \" \"<< natmortprior\n             << \" \"<< cvnatmortprior <<endl;\n    R_report   << endl;\n    R_report << \"$Steep\"<<endl;\n    R_report << \" \"<< post_priors(2)\n             << \" \"<< steepness\n             << \" \"<< steepnessprior\n             << \" \"<< cvsteepnessprior <<endl;\n    R_report   << endl;\n    R_report << \"$Sigmar\"<<endl;\n    R_report << \" \"<< post_priors(3)\n             << \" \"<< sigmar\n             << \" \"<< sigmarprior\n             << \" \"<< cvsigmarprior <<endl;\n    R_report   << endl;\n    R_report<<\"$Num_parameters_Est\"<<endl;\n    R_report<<initial_params::nvarcalc()<<endl;\n    R_report   << endl;\n    \n  R_report<<\"$Steep_Prior\" <<endl;\n  R_report<<steepnessprior<<\" \"<<\n    cvsteepnessprior<<\" \"<<\n    phase_srec<<\" \"<< endl;\n    R_report   << endl;\n\n  R_report<<\"$sigmarPrior \" <<endl;\n  R_report<<sigmarprior<<\" \"<<  cvsigmarprior <<\" \"<<phase_sigmar<<endl;\n  R_report   << endl;\n\n  R_report<<\"$Rec_estimated_in_styr_endyr \" <<endl;\n  R_report<<styr_rec    <<\" \"<<endyr        <<\" \"<<endl;\n  R_report   << endl;\n  R_report<<\"$SR_Curve_fit__in_styr_endyr \" <<endl;\n  R_report<<styr_rec_est<<\" \"<<endyr_rec_est<<\" \"<<endl;\n  R_report   << endl;\n  R_report<<\"$Model_styr_endyr\" <<endl;\n  R_report<<styr        <<\" \"<<endyr        <<\" \"<<endl;\n  R_report   << endl;\n\n  R_report<<\"$M_prior \"<<endl;\n  R_report<< natmortprior<< \" \"<< cvnatmortprior<<\" \"<<phase_M<<endl;\n  R_report   << endl;\n  R_report<<\"$qprior \" <<endl;\n  R_report<< qprior<<\" \"<<cvqprior<<\" \"<< phase_q<<endl;\n  R_report<<\"$q_power_prior \" <<endl;\n  R_report<< q_power_prior<<\" \"<<cvq_power_prior<<\" \"<< phase_q_power<<endl;\n  R_report   << endl;\n\n  R_report<<\"$cv_catchbiomass \" <<endl;\n  R_report<<cv_catchbiomass<<\" \"<<endl;\n  R_report   << endl;\n  R_report<<\"$Projection_years\"<<endl;\n  R_report<< nproj_yrs<<endl;\n  R_report   << endl;\n  \n  R_report << \"$Fsh_sel_opt_fish \"<<endl;\n  for (k=1;k<=nfsh;k++)\n    R_report<<k<<\" \"<<fsh_sel_opt(k)<<\" \"<<sel_change_in_fsh(k)<<endl;\n    R_report   << endl;\n   R_report<<\"$Survey_Sel_Opt_Survey \" <<endl;\n  for (k=1;k<=nind;k++)\n  R_report<<k<<\" \"<<(ind_sel_opt(k))<<endl;\n  R_report   << endl;\n    \n  R_report <<\"$Phase_survey_Sel_Coffs \"<<endl;\n  R_report <<phase_selcoff_ind<<endl;\n  R_report   << endl;\n  R_report <<\"$Fshry_Selages \" << endl;\n  R_report << nselages_in_fsh  <<endl;\n  R_report   << endl;\n  R_report <<\"$Survy_Selages \" <<endl;\n  R_report <<nselages_in_ind <<endl;\n  R_report   << endl;\n\n  R_report << \"$Phase_for_age_spec_fishery\"<<endl;\n  R_report <<phase_selcoff_fsh<<endl;\n  R_report   << endl;\n  R_report << \"$Phase_for_logistic_fishery\"<<endl;\n  R_report <<phase_logist_fsh<<endl;\n  R_report   << endl;\n  R_report << \"$Phase_for_dble_logistic_fishery \"<<endl;\n  R_report <<phase_dlogist_fsh<<endl;\n  R_report   << endl;\n\n  R_report << \"$Phase_for_age_spec_survey  \"<<endl;\n  R_report <<phase_selcoff_ind<<endl;\n  R_report   << endl;\n  R_report << \"$Phase_for_logistic_survey  \"<<endl;\n  R_report <<phase_logist_ind<<endl;\n  R_report   << endl;\n  R_report << \"$Phase_for_dble_logistic_indy \"<<endl;\n  R_report <<phase_dlogist_ind<<endl;\n  R_report   << endl;\n  \n  for (k=1;k<=nfsh;k++)\n  {\n    if (nyrs_fsh_age(k)>0)\n    {\n      R_report << \"$Francis_wt_fsh_age_\"<<k<<endl;\n      double fwtmp;\n      fwtmp = calc_Francis_weights(oac_fsh(k),eac_fsh(k),n_sample_fsh_age(k)) ;\n      R_report << fwtmp <<endl;\n      // cout << fwtmp <<endl;\n      R_report <<\"$EffN_Fsh_\"<<(k)<<\"\"<<endl;\n      for (i=1;i<=nyrs_fsh_age(k);i++)\n      {\n        double sda_tmp = Sd_age(oac_fsh(k,i));\n        R_report << yrs_fsh_age(k,i);\n        R_report << \" \"<<Eff_N(oac_fsh(k,i),eac_fsh(k,i)) ;\n        R_report << \" \"<<Eff_N2(oac_fsh(k,i),eac_fsh(k,i));\n        R_report << \" \"<<mn_age(oac_fsh(k,i));\n        R_report << \" \"<<mn_age(eac_fsh(k,i));\n        R_report << \" \"<<sda_tmp;\n        R_report << \" \"<<mn_age(oac_fsh(k,i)) - sda_tmp *2. / sqrt(n_sample_fsh_age(k,i));\n        R_report << \" \"<<mn_age(oac_fsh(k,i)) + sda_tmp *2. / sqrt(n_sample_fsh_age(k,i));\n        R_report <<endl;\n      }\n    }\n  }\n  \n  for (k=1;k<=nfsh;k++)\n  {\n    if (nyrs_fsh_length(k)>0)\n    {\n      R_report << \"$Francis_wt_fsh_len_\"<<k<<endl;\n      R_report << calc_Francis_weights(olc_fsh(k),elc_fsh(k),n_sample_fsh_length(k)) <<endl;\n      R_report <<\"$EffN_Length_Fsh_\"<<(k)<<\"\"<<endl;\n      for (i=1;i<=nyrs_fsh_length(k);i++)\n      {\n        double sda_tmp = Sd_length(olc_fsh(k,i));\n        R_report << yrs_fsh_length(k,i);\n        R_report << \" \"<<Eff_N(olc_fsh(k,i),elc_fsh(k,i)) ;\n        R_report << \" \"<<Eff_N2_L(olc_fsh(k,i),elc_fsh(k,i));\n        R_report << \" \"<<mn_length(olc_fsh(k,i));\n        R_report << \" \"<<mn_length(elc_fsh(k,i));\n        R_report << \" \"<<sda_tmp;\n        R_report << \" \"<<mn_length(olc_fsh(k,i)) - sda_tmp *2. / sqrt(n_sample_fsh_length(k,i));\n        R_report << \" \"<<mn_length(olc_fsh(k,i)) + sda_tmp *2. / sqrt(n_sample_fsh_length(k,i));\n        R_report <<endl;\n      }\n    }\n  }\n\n\n  for (k=1;k<=nfsh;k++)\n  {\n    R_report <<\"$C_fsh_\" <<(k)<<\"\" << endl; \n    for (i=styr;i<=endyr;i++)\n      R_report <<i<<\" \"<<catage(k,i)<< endl;\n  }\n\n  R_report <<\"$wt_a_pop\" << endl<< wt_pop  <<endl;\n  R_report <<\"$mature_a\" << endl<< maturity<<endl;\n  for (k=1;k<=nfsh;k++)\n  {\n    R_report <<\"$wt_fsh_\"<<(k)<<\"\"<<endl;\n    for (i=styr;i<=endyr;i++)\n      R_report <<i<<\" \"<<wt_fsh(k,i)<< endl;\n  }\n  \n  for (k=1;k<=nind;k++)\n  {\n    R_report <<\"$wt_ind_\"<<(k)<<\"\"<<endl;\n    for (i=styr;i<=endyr;i++)\n      R_report <<i<<\" \"<<wt_ind(k,i)<< endl;\n  }\n  for (k=1;k<=nind;k++)\n  {\n    if (nyrs_ind_age(k)>0)\n    {\n      R_report << \"$Francis_wt_ind_age_\"<<k<<endl;\n      R_report << calc_Francis_weights(oac_ind(k),eac_ind(k),n_sample_ind_age(k)) <<endl;\n      R_report <<\"$EffN_Survey_\"<<(k)<<\"\"<<endl;\n      for (i=1;i<=nyrs_ind_age(k);i++)\n      {\n        double sda_tmp = Sd_age(oac_ind(k,i));\n        R_report << yrs_ind_age(k,i)\n                 << \" \"<<Eff_N(oac_ind(k,i),eac_ind(k,i)) \n                 << \" \"<<Eff_N2(oac_ind(k,i),eac_ind(k,i))\n                 << \" \"<<mn_age(oac_ind(k,i))\n                 << \" \"<<mn_age(eac_ind(k,i))\n                 << \" \"<<sda_tmp\n                 << \" \"<<mn_age(oac_ind(k,i)) - sda_tmp *2. / sqrt(n_sample_ind_age(k,i))\n                 << \" \"<<mn_age(oac_ind(k,i)) + sda_tmp *2. / sqrt(n_sample_ind_age(k,i))\n                 <<endl;\n      }\n    }\n  }\n  for (k=1;k<=nind;k++)\n  {\n    if (nyrs_ind_length(k)>0)\n    {\n      R_report << \"$Francis_wt_ind_len_\"<<k<<endl;\n      R_report << calc_Francis_weights(olc_ind(k),elc_ind(k),n_sample_ind_length(k)) <<endl;\n      R_report <<\"$EffN_Length_Survey_\"<<(k)<<\"\"<<endl;\n      for (i=1;i<=nyrs_ind_length(k);i++)\n      {\n        double sda_tmp = Sd_age(olc_ind(k,i));\n        R_report << yrs_ind_length(k,i)\n                 << \" \"<<Eff_N(olc_ind(k,i),elc_ind(k,i)) \n                 << \" \"<<Eff_N2_L(olc_ind(k,i),elc_ind(k,i))\n                 << \" \"<<mn_length(olc_ind(k,i))\n                 << \" \"<<mn_length(elc_ind(k,i))\n                 << \" \"<<sda_tmp\n                 << \" \"<<mn_length(olc_ind(k,i)) - sda_tmp *2. / sqrt(n_sample_ind_length(k,i))\n                 << \" \"<<mn_length(olc_ind(k,i)) + sda_tmp *2. / sqrt(n_sample_ind_length(k,i))\n                 <<endl;\n      }\n    }\n  }\n  \n  R_report<<\"$msy_mt\"<<endl; \n  dvar_matrix sel_tmp(1,nages,1,nfsh);\n  dvariable sumF;\n  sel_tmp.initialize();\n  for (i=styr;i<=endyr;i++) \n  { \n    sumF=0.;\n    for (k=1;k<=nfsh;k++)\n    {\n      Fratio(k) = sum(F(k,i)) ;\n      sumF += Fratio(k) ;\n    }\n    Fratio /= sumF;\n    sumF /= nages;\n    for (k=1;k<=nfsh;k++)\n      for (j=1;j<=nages;j++)\n        sel_tmp(j,k) = sel_fsh(k,i,j); \n    get_msy(i);\n    // important for time-varying natural mortality...\n    dvariable spr_mt_ft = spr_ratio(sumF,sel_tmp,i)  ;\n    // Yr Fspr 1-Fspr F/Fmsy Fmsy F Fsprmsy MSY MSYL Bmsy Bzero B/Bmsy\n    R_report<< i<<\n            \" \"<< spr_mt_ft                   <<\n            \" \"<< (1.-spr_mt_ft)              << \n            \" \"<< Fcur_Fmsy                   <<\n            \" \"<< Fmsy                        <<\n            \" \"<< sumF                        <<\n            \" \"<< spr_ratio(Fmsy,sel_tmp,i)   <<\n            \" \"<< MSY                         <<\n            \" \"<< MSYL                        <<\n            \" \"<< Bmsy                        <<\n            \" \"<< Bzero                       <<\n            \" \"<< Sp_Biom(i)                  <<\n            \" \"<< Bcur_Bmsy                   <<\n            endl ;\n  }\n  R_report<<\"$age2len\"<<endl; \n  R_report<<P_age2len<<endl;\n  R_report<<\"$msy_m0\"<<endl; \n  sel_tmp.initialize();\n  // NOTE Danger here\n  dvar_matrix mtmp = M;\n  for (i=styr;i<=endyr;i++) \n  { \n    M(i) = M(styr);\n    sumF=0.;\n    for (k=1;k<=nfsh;k++)\n    {\n      Fratio(k) = sum(F(k,i)) ;\n      sumF += Fratio(k) ;\n    }\n    Fratio /= sumF;\n    for (k=1;k<=nfsh;k++)\n      for (j=1;j<=nages;j++)\n        sel_tmp(j,k) = sel_fsh(k,i,j); \n    get_msy(i);\n    sumF /= nages;\n    // important for time-varying natural mortality...\n    dvariable spr_mt_ft = spr_ratio(sumF,sel_tmp,i)  ;\n    dvariable spr_mt_f0 = spr_ratio(0.,sel_tmp,i)  ;\n    R_report<< i<<\n            \" \"<< spr_mt_ft                   <<\n            \" \"<< spr_mt_f0                   <<\n            \" \"<< (1.-spr_mt_f0)/(1-spr_mt_ft)<< \n            \" \"<< Fcur_Fmsy                   <<\n            \" \"<< Fmsy                        <<\n            \" \"<< sumF                        <<\n            \" \"<< spr_ratio(Fmsy,sel_tmp,i)   <<\n            \" \"<< MSY                         <<\n            \" \"<< Bmsy                        <<\n            \" \"<< MSYL                        <<\n            \" \"<< Bcur_Bmsy                   <<\n            endl ;\n  }\n\n  M = mtmp;\n  R_Report(F40_est);\n  R_Report(F35_est);      \n\n  R_report<<\"$sumBiom\"<<endl; \n  for (i=styr;i<=endyr+1;i++) \n  {\n    double lb=value(sumBiom(i)/exp(2.*sqrt(log(1+square(sumBiom.sd(i))/square(sumBiom(i))))));\n    double ub=value(sumBiom(i)*exp(2.*sqrt(log(1+square(sumBiom.sd(i))/square(sumBiom(i))))));\n    R_report<<i<<\" \"<<sumBiom(i)<<\" \"<<sumBiom.sd(i)<<\" \"<<lb<<\" \"<<ub<<endl;\n  }\n  R_Report(tau);      \n\n  R_report.close();\n\n\nFUNCTION double mn_age(const dvector& pobs)\n  // int lb1 = pobs.indexmin();\n  // int ub1 = pobs.indexmax();\n  // dvector av = age_vector(lb1,ub1)  ;\n  // double mobs = value(pobs.shift(rec_age)*age_vector);\n  double mobs = (pobs*age_vector);\n  return mobs;\n\nFUNCTION double mn_age(const dvar_vector& pobs)\n  // int lb1 = pobs.indexmin();\n  // int ub1 = pobs.indexmax();\n  // dvector av = age_vector(lb1,ub1)  ;\n  // double mobs = value(pobs.shift(rec_age)*age_vector);\n  double mobs = value(pobs*age_vector);\n  return mobs;\n\nFUNCTION double Sd_age(const dvector& pobs)\n  // double mobs = (pobs.shift(rec_age)*age_vector);\n  // double stmp = (sqrt(elem_prod(age_vector,age_vector)*pobs.shift(rec_age) - mobs*mobs));\n  double mobs = (pobs*age_vector);\n  double stmp = sqrt((elem_prod(age_vector,age_vector)*pobs) - mobs*mobs);\n  return stmp;\n\nFUNCTION double mn_length(const dvector& pobs)\n  double mobs = (pobs*len_bins);\n  return mobs;\n\nFUNCTION double mn_length(const dvar_vector& pobs)\n  double mobs = value(pobs*len_bins);\n  return mobs;\n\nFUNCTION double Sd_length(const dvector& pobs)\n  double mobs = (pobs*len_bins);\n  double stmp = sqrt((elem_prod(len_bins,len_bins)*pobs) - mobs*mobs);\n  return stmp;\n\nFUNCTION double Eff_N_adj(const double, const dvar_vector& pobs, const dvar_vector& phat)\n  int lb1 = pobs.indexmin();\n  int ub1 = pobs.indexmax();\n  dvector av = age_vector(lb1,ub1)  ;\n  double mobs = value(pobs*av);\n  double mhat = value(phat*av );\n  double rtmp = mobs-mhat;\n  double stmp = value(sqrt(elem_prod(av,av)*pobs - mobs*mobs));\n  return square(stmp)/square(rtmp);\n\nFUNCTION double Eff_N2(const dvector& pobs, const dvar_vector& phat)\n  int lb1 = pobs.indexmin();\n  int ub1 = pobs.indexmax();\n  dvector av = age_vector(lb1,ub1)  ;\n  double mobs =      (pobs*av);\n  double mhat = value(phat*av );\n  double rtmp = mobs-mhat;\n  double stmp = (sqrt(elem_prod(av,av)*pobs - mobs*mobs));\n  return square(stmp)/square(rtmp);\n\nFUNCTION double Eff_N(const dvector& pobs, const dvar_vector& phat)\n  dvar_vector rtmp = elem_div((pobs-phat),sqrt(elem_prod(phat,(1-phat))));\n  double vtmp;\n  vtmp = value(norm2(rtmp)/size_count(rtmp));\n  return 1./vtmp;\n\n /**\n   * @brief Calculate Francis weights\n   * @details this code based on equation TA1.8 in Francis(2011) should be changed so separate weights if by sex\n   *\n   * Produces the new weight that should be used.\n  **/\nFUNCTION double calc_Francis_weights(const dmatrix oac, const dvar_matrix eac, const ivector sam )\n  {\n    int nobs;\n    int i1=oac.rowmin();\n    int i2=oac.rowmax();\n    double lfwt,Var,Pre,Obs;\n    dvector ages(oac.colmin(),nages);\n    for (int i=oac.colmin();i<=nages;i++) \n      ages(i) = double(i)+.5;\n    nobs = oac.rowsize();\n    // cout <<nobs<<endl;\n    dvector resid(i1,i2);\n    resid.initialize();\n    for ( int i = i1; i <= i2; i++ )\n    {\n      // Obs = sum(elem_prod(oac(i), ages+.5));\n      Obs = oac(i) * (ages+.5);\n      // Pre = sum(elem_prod(value(eac(i)), ages+.5));\n      Pre = value(eac(i)) * (ages+.5);\n      Var = value(eac(i)) * square(ages+.5);\n      Var -= square(Pre);\n      resid(i) = (Obs - Pre) / sqrt(Var * 1.0 / (sam(i) ));\n      // cout<<Obs<<\" \"<<Pre<<\" \"<<Var<<\" \"<<resid(i)<<endl;\n    }\n    lfwt = 1.0 / (square(std_dev(resid)) * ((nobs - 1.0) / nobs * 1.0));\n    // lfwt(k) *= lf_lambda(k);\n    // cout <<\"FWt \"<<lfwt<<endl;\n    return lfwt;\n  }\n\nFUNCTION double Eff_N2_L(const dvector& pobs, const dvar_vector& phat)\n  dvector av = len_bins  ;\n  double mobs =      (pobs*av);\n  double mhat = value(phat*av );\n  double rtmp = mobs-mhat;\n  double stmp = (sqrt(elem_prod(av,av)*pobs - mobs*mobs));\n  return square(stmp)/square(rtmp);\n\nFUNCTION double get_AC(const int& indind)\n  // Functions to compute autocorrelation in residuals \n  int i1,i2,iyr;\n  i1 = 1;\n  i2 = nyrs_ind(indind);\n  double actmp;\n  dvector res(1,i2);\n  for (i=1;i<=i2;i++)\n  {\n    iyr = int(yrs_ind(indind,i));\n    cout<<iyr<<\" \"<<obs_ind(indind,i)<<\" \" <<pred_ind(indind,iyr)<<endl;\n    res(i) = log(obs_ind(indind,i)) - value(log(pred_ind(indind,iyr)));\n  }\n  double m1 = (mean(res(i1,i2-1)));\n  double m2 = (mean(res(i1+1,i2))); \n  actmp = mean( elem_prod( ++res(i1,i2-1) - m1, res(i1+1,i2) - m2)) /\n          (sqrt(mean( square(res(i1,i2-1) - m1 )))  * sqrt(mean(square(res(i1+1,i2) - m2 ))) );\n  return(actmp);\n\n \nGLOBALS_SECTION\n  //#include <logistic-normal.h>\n  #include <admodel.h>  \n\t#undef write_SIS_rep \n  /// Writes SIS report objects\n\t#define write_SIS_rep(object) SIS_rep << #object \"\\n\" << object << endl;\n\t#undef truth \n  /// Writes true model values (for OM testing)\n\t#define truth(object) trudat << #object \"\\n\" << object << endl;\n\t#undef REPORT \n  /// Martells report \n\t#define REPORT(object) REPORT << #object \"\\n\" << object << endl;\n\t#undef R_Report \n  /// for R report \n\t#define R_Report(object) R_report << \"$\"#object \"\\n\" << object << endl;\n\t/** Prints name and value of \\a object on ADMB report %ofstream file.  */\n\t#undef log_input\n\t#define log_input(object) write_input_log << \"# \" #object \"\\n\" << object << endl;\n\t#undef log_param\n  // #define log_param(object) for(int i=0;i<initial_params::num_initial_params;i++) {if(withinbound(0,(initial_params::varsptr[i])->phase_start, initial_params::current_phase)) { int sc= (initial_params::varsptr[i])->size_count(); if (sc>0) { write_input_log << \"# \" << initial_params::varsptr[i] ->label() << \"\\n\" << object<<endl; } }}\n  //\n\t#define log_param(object) if (active(object)) write_input_log << \"# \" #object \"\\n\" << object << endl;\n  ofstream write_input_log(\"input.log\");\n  ofstream SIS_rep(\"SIS_out.rep\");\n\n // void get_sel_changes(int& k);\n  adstring_array fshname;\n  adstring_array indname;\n  adstring truname;\n  adstring simname;\n  adstring model_name;\n  adstring projfile_name;\n  adstring datafile_name;\n  adstring cntrlfile_name;\n  adstring tmpstring;\n  adstring repstring;\n  adstring version_info;\n\n \nFUNCTION Write_SIS\n  /** Writes out SIS output format file */\n  SIS_rep << \" # constants ############################ \\n\"\n          << \" # species  \\n\"\n\t\n          << \" # region     (AI AK BOG BSAI EBS GOA)  \\n\" \n\t\n          << \" # assess_year  \\n\"\n  \n          << \" # split_sex (True or false) (1 or 0) (if true, FEMALE, Male, else combined)  \\n\"\n\t\n          << \" # number of fisheries  \\n \"\n\t\n          << \" # list of fisheries (ALL TWL LGL POT FIX FOR DOM ...) separated w/ %  \\n \"\n\t\n          << \" # mulitiplier for recruitment and N at age     (1,1000,1000000)  \\n\" \n\t\n          << \" # mulitiplier for biomass mt, catch mt, and surveybiomass mt    (1,1000,1000000)  \\n\"\n\t\n          << \" # recruitment age used by model  \\n\"\n\t\n          << \" # age+ used for biomass estimate  \\n\"\n\t\n          << \" # number of surveys  \\n \"\n  \n          << \" # list of surveys (longline, trawl, acoustic) separated w/ %  \\n\"\n\n          << \"#YEARS -list all years used in model (starting w/ first year of catch)  \\n\"\n\n          << \"#AGES -list ages used in model  \\n\"\n\n          << \"#RECRUITMENT -Number of recruits by model year (see multiplier above)  \\n\" \n\n          << \"#SPAWNBIOMASS -Spawning biomass by model year (see mt multiplier above)  \\n\"\n\n          << \"#TOTALBIOMASS -Total biomass by year (see mt multiplier above and age+ above)  \\n\"\n\n          << \"#TOTFSHRYMORT -Fishing mortality rate by year  \\n\"\n\n          << \"#TOTALCATCH -Total catch by year (see mt multiplier above)  \\n\"\n\n          << \"#FISHERYMORT -Fishing mortality rates by year (a line for each fishery) only if multiple fisheries  \\n\"\n\n          << \"#FISHERYCATCH -Catches by year (a line for each fishery) only if multiple fisheries  \\n\"\n\n          << \"#MATURITY -Maturity ratio by age  \\n\"\n\n          << \"#SPAWNWT -Average Spawning weight (in kg) by age  \\n\"\n\n          << \"#NATMORT -Natural mortality rate by age (a line for each sex)  \\n\"\n\n          << \"#N_AT_AGE -N at age by age (see number multiplier above)(a line for each sex)  \\n\"\n\n          << \"#FSHRY_WT_KG_SEX1 -Fishery weight at age (in kg)(a line for each fishery)  \\n\"\n\n          << \"#FSHRY_WT_KG_SEX2 -Fishery weight at age (in kg)(a line for each fishery)  \\n\"\n\n          << \"#SELECTIVITY_SEX1 -Fishery selectivity (a line for each fishery)  \\n\"\n\n          << \"#SELECTIVITY_SEX2 -Fishery selectivity (a line for each fishery)  \\n\"\n\n          << \"#SURVEYYEARS - list the survey years (a line for each survey)  \\n\"\n\n          << \"#SURVEYBIOMASS -Survey biomass by survey year (see mt multiplier above)(a line for each survey)  \\n\"\n\n          << endl;\n\nFUNCTION double sdnr(const dvar_vector& pred,const dvector& obs,double m)\n  RETURN_ARRAYS_INCREMENT();\n  double sdnr;\n  dvector pp = value(pred)+0.000001;\n  sdnr = std_dev(elem_div(obs+0.000001-pp,sqrt(elem_prod(pp,(1.-pp))/m)));\n  RETURN_ARRAYS_DECREMENT();\n  return sdnr;\n\n"},"evals":[],"jsHooks":[]}</script>
<script type="application/htmlwidget-sizing" data-for="htmlwidget-157d6f182872bd098853">{"viewer":{"width":450,"height":350,"padding":15,"fill":true},"browser":{"width":960,"height":500,"padding":40,"fill":false}}</script>
</body>
</html>
